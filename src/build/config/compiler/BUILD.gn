# Copyright 2013 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/buildflag_header.gni")
import("//build/config/android/config.gni")
import("//build/config/c++/c++.gni")
import("//build/config/chrome_build.gni")
import("//build/config/chromeos/args.gni")
import("//build/config/chromeos/ui_mode.gni")
import("//build/config/clang/clang.gni")
import("//build/config/compiler/compiler.gni")
import("//build/config/coverage/coverage.gni")
import("//build/config/dcheck_always_on.gni")
import("//build/config/gclient_args.gni")
import("//build/config/host_byteorder.gni")
import("//build/config/pch.gni")
import("//build/config/rust.gni")
import("//build/config/ui.gni")
import("//build/config/unwind.gni")
import("//build/toolchain/cros/cros_config.gni")
import("//build/toolchain/rbe.gni")
import("//build/toolchain/toolchain.gni")
import("//build_overrides/build.gni")

if (current_cpu == "arm" || current_cpu == "arm64") {
  import("//build/config/arm.gni")
}
if (current_cpu == "mipsel" || current_cpu == "mips64el" ||
    current_cpu == "mips" || current_cpu == "mips64") {
  import("//build/config/mips.gni")
}
if (is_mac) {
  import("//build/config/apple/symbols.gni")
}
if (is_ios) {
  import("//build/config/ios/ios_sdk.gni")
}
if (is_nacl) {
  # To keep NaCl variables out of builds that don't include NaCl, all
  # variables defined in nacl/config.gni referenced here should be protected by
  # is_nacl conditions.
  import("//build/config/nacl/config.gni")
}

lld_path = ""
if (!is_clang) {
  declare_args() {
    # This allows overriding the location of lld.
    lld_path = rebase_path("$clang_base_path/bin", root_build_dir)
  }
} else {
  # clang looks for lld next to it, no need for -B.
  lld_path = ""
}

declare_args() {
  # Normally, Android builds are lightly optimized, even for debug builds, to
  # keep binary size down. Setting this flag to true disables such optimization
  android_full_debug = false

  # Compile in such a way as to make it possible for the profiler to unwind full
  # stack frames. Setting this flag has a large effect on the performance of the
  # generated code than just setting profiling, but gives the profiler more
  # information to analyze.
  # Requires profiling to be set to true.
  enable_full_stack_frames_for_profiling = false

  # Enable fatal linker warnings. Building Chromium with certain versions
  # of binutils can cause linker warning.
  fatal_linker_warnings = true

  # Build with C++ RTTI enabled. Chromium builds without RTTI by default,
  # but some sanitizers are known to require it, like CFI diagnostics
  # and UBsan variants.
  use_rtti = use_cfi_diag || is_ubsan_vptr || is_ubsan_security

  # AFDO (Automatic Feedback Directed Optimizer) is a form of profile-guided
  # optimization that GCC supports. It used by ChromeOS in their official
  # builds. To use it, set auto_profile_path to the path to a file containing
  # the needed gcov profiling data.
  auto_profile_path = ""

  # Optimize for coverage guided fuzzing (balance between speed and number of
  # branches)
  optimize_for_fuzzing = false

  # Path to an AFDO profile to use while building with clang, if any. Empty
  # implies none.
  clang_sample_profile_path = ""

  # Some configurations have default sample profiles. If this is true and
  # clang_sample_profile_path is empty, we'll fall back to the default.
  #
  # We currently only have default profiles for Chromium in-tree, so we disable
  # this by default for all downstream projects, since these profiles are likely
  # nonsensical for said projects.
  clang_use_default_sample_profile =
      chrome_pgo_phase == 0 && build_with_chromium && is_official_build &&
      ((is_android && !is_high_end_android) || chromeos_is_browser_only)

  # This configuration is used to select a default profile in Chrome OS based on
  # the microarchitectures we are using. This is only used if
  # clang_use_default_sample_profile is true and clang_sample_profile_path is
  # empty.
  chromeos_afdo_platform = "atom"

  # Emit debug information for profiling wile building with clang.
  # Only enable this for ChromeOS official builds for AFDO.
  clang_emit_debug_info_for_profiling = is_chromeos_device && is_official_build

  # Turn this on to have the compiler output extra timing information.
  compiler_timing = false

  # Turn this on to use ghash feature of lld for faster debug link on Windows.
  # http://blog.llvm.org/2018/01/improving-link-time-on-windows-with.html
  use_ghash = true

  # Whether to enable ThinLTO optimizations. Turning ThinLTO optimizations on
  # can substantially increase link time and binary size, but they generally
  # also make binaries a fair bit faster.
  #
  # TODO(gbiv): We disable optimizations by default on most platforms because
  # the space overhead is too great. We should use some mixture of profiles and
  # optimization settings to better tune the size increase.
  thin_lto_enable_optimizations =
      (is_chromeos || is_android || is_win || is_linux || is_mac ||
       (is_ios && use_lld)) && is_official_build

  # Whether to enable thin lto incremental builds.
  # See: https://clang.llvm.org/docs/ThinLTO.html#incremental
  # The cache can lead to non-determinism: https://crbug.com/1486045
  thin_lto_enable_cache = true

  # Initialize all local variables with a pattern. This flag will fill
  # uninitialized floating-point types (and 32-bit pointers) with 0xFF and the
  # rest with 0xAA. This makes behavior of uninitialized memory bugs consistent,
  # recognizable in the debugger, and crashes on memory accesses through
  # uninitialized pointers.
  #
  # Flag discussion: https://crbug.com/977230
  #
  # TODO(crbug.com/40721698): This regresses binary size by ~1MB on Android and
  # needs to be evaluated before enabling it there as well.
  init_stack_vars = !(is_android && is_official_build)

  # Zero init has favorable performance/size tradeoffs for Chrome OS
  # but was not evaluated for other platforms.
  init_stack_vars_zero = is_chromeos

  # This argument is to control whether enabling text section splitting in the
  # final binary. When enabled, the separated text sections with prefix
  # '.text.hot', '.text.unlikely', '.text.startup' and '.text.exit' will not be
  # merged to '.text' section. This allows us to identify the hot code section
  # ('.text.hot') in the binary, which allows our data collection pipelines to
  # more easily identify code that we assume to be hot/cold that doesn't turn
  # out to be such in the field.
  use_text_section_splitting = is_chromeos

  # Enable DWARF v5.
  use_dwarf5 = false

  # Override this to put full paths to PDBs in Windows PE files. This helps
  # windbg and Windows Performance Analyzer with finding the PDBs in some local-
  # build scenarios. This is never needed for bots or official builds. Because
  # this puts the output directory in the DLLs/EXEs it breaks build determinism.
  # Bugs have been reported to the windbg/WPA teams and this workaround will be
  # removed when they are fixed.
  use_full_pdb_paths = false

  # Enable -H, which prints the include tree during compilation.
  # For use by tools/clang/scripts/analyze_includes.py
  show_includes = false

  # Enable Profi algorithm. Profi can infer block and edge counts.
  # https://clang.llvm.org/docs/UsersManual.html#using-sampling-profilers
  # TODO(crbug.com/1375958i:) Possibly enable this for Android too.
  use_profi = is_chromeos

  # If true, linker crashes will be rerun with `--reproduce` which causes
  # a reproducer file to be saved.
  save_reproducers_on_lld_crash = false

  # Enable ShadowCallStack for compiled binaries. SCS stores a pointer to a
  # shadow call stack in register x18. Hence, x18 must not be used by the OS
  # or libraries. We assume that to be the case for high end Android
  # configurations. For more details see
  # https://clang.llvm.org/docs/ShadowCallStack.html
  enable_shadow_call_stack = false

  # Use DWARF simple template names, with the following exceptions:
  #
  # * Windows is not supported as it doesn't use DWARF.
  # * Apple platforms (e.g. MacOS, iPhone, iPad) aren't supported because xcode
  #   lldb doesn't have the needed changes yet.
  # TODO(crbug.com/40244196): Remove if the upstream default ever changes.
  #
  # This greatly reduces the size of debug builds, at the cost of
  # debugging information which is required by some specialized
  # debugging tools.
  simple_template_names = is_clang && !is_nacl && !is_win && !is_apple
}

declare_args() {
  # Set to true to use icf, Identical Code Folding.
  use_icf = (is_posix || is_fuchsia) && !is_debug && !using_sanitizer &&
            !use_clang_coverage && current_os != "zos" &&
            !(is_android && use_order_profiling) && use_lld
}

if (is_android) {
  # Set the path to use orderfile for linking Chrome
  # Note that this is for using only one orderfile for linking
  # the Chrome binary/library.
  declare_args() {
    chrome_orderfile_path = ""

    # The orderfile is trained on PGO builds (for arm64) and AFDO builds (for
    # arm32), so apply them only in these cases.
    if (defined(default_chrome_orderfile)) {
      if (((current_cpu == "arm64" || current_cpu == "x64") &&
           chrome_pgo_phase == 2) ||
          ((current_cpu == "arm" || current_cpu == "x86") &&
           clang_use_default_sample_profile)) {
        chrome_orderfile_path = default_chrome_orderfile
      }
    }
  }
}

declare_args() {
  # Turn off the --call-graph-profile-sort flag for lld by default. Enable
  # selectively for targets where it's beneficial.
  enable_call_graph_profile_sort =
      chrome_pgo_phase == 2 ||
      (is_chromeos &&
       (clang_use_default_sample_profile || clang_sample_profile_path != ""))
}

assert(!(llvm_force_head_revision && use_remoteexec && host_os != "linux"),
       "rbe with locally built clang only works on linux")

# default_include_dirs ---------------------------------------------------------
#
# This is a separate config so that third_party code (which would not use the
# source root and might have conflicting versions of some headers) can remove
# this and specify their own include paths.
config("default_include_dirs") {
  include_dirs = [
    "//",
    root_gen_dir,
  ]
}

# Compiler instrumentation can introduce dependencies in DSOs to symbols in
# the executable they are loaded into, so they are unresolved at link-time.
config("no_unresolved_symbols") {
  if (!using_sanitizer &&
      (is_linux || is_chromeos || is_android || is_fuchsia)) {
    ldflags = [
      "-Wl,-z,defs",
      "-Wl,--as-needed",
    ]
  }
}

# compiler ---------------------------------------------------------------------
#
# Base compiler configuration.
#
# See also "runtime_library" below for related stuff and a discussion about
# where stuff should go. Put warning related stuff in the "warnings" config.

config("compiler") {
  asmflags = []
  cflags = []
  cflags_c = []
  cflags_cc = []
  cflags_objc = []
  cflags_objcc = []
  rustflags = []
  ldflags = []
  defines = []
  configs = []

  # System-specific flags. If your compiler flags apply to one of the
  # categories here, add it to the associated file to keep this shared config
  # smaller.
  if (is_win) {
    configs += [ "//build/config/win:compiler" ]
  } else if (is_android) {
    configs += [ "//build/config/android:compiler" ]
  } else if (is_linux || is_chromeos) {
    configs += [ "//build/config/linux:compiler" ]
  } else if (is_nacl) {
    configs += [ "//build/config/nacl:compiler" ]
  } else if (is_mac) {
    configs += [ "//build/config/mac:compiler" ]
  } else if (is_ios) {
    configs += [ "//build/config/ios:compiler" ]
  } else if (is_fuchsia) {
    configs += [ "//build/config/fuchsia:compiler" ]
  } else if (current_os == "aix") {
    configs += [ "//build/config/aix:compiler" ]
  } else if (current_os == "zos") {
    configs += [ "//build/config/zos:compiler" ]
  }

  configs += [
    # See the definitions below.
    ":clang_revision",
    ":rustc_revision",
    ":compiler_cpu_abi",
    ":compiler_codegen",
    ":compiler_deterministic",
  ]

  # Here we enable -fno-delete-null-pointer-checks, which makes various nullptr
  # operations (e.g. dereferencing) into defined behavior. This avoids deletion
  # of some security-critical code: see https://crbug.com/1139129.
  # The older NaCl toolchain does not support the flag. And, we still want UBSan
  # to catch undefined behavior related to nullptrs, so do not add this flag if
  # UBSan is enabled. GCC seems to have some bugs compiling constexpr code when
  # this is defined, so only enable it if using_clang.
  # See: https://gcc.gnu.org/PR97913
  # TODO(mpdenton): remove is_clang once GCC bug is fixed.
  if ((!is_nacl || is_nacl_saigo) && !is_ubsan && is_clang) {
    cflags += [ "-fno-delete-null-pointer-checks" ]
  }

  # Make signed overflow and pointer overflowdefined to wrap.
  # This avoids risking miscompilations and security bugs on overflow.
  # When UBSan is enabled, we want to continue flagging overflows as a bug.
  if (!is_ubsan && (!is_win || is_clang)) {
    if (is_win) {
      cflags += [ "/clang:-fwrapv" ]
    } else {
      cflags += [ "-fwrapv" ]
    }
  }

  # Don't emit the GCC version ident directives, they just end up in the
  # .comment section or debug info taking up binary size, and makes comparing
  # .o files built with different compiler versions harder.
  if (!is_win || is_clang) {
    cflags += [ "-fno-ident" ]
  }

  # In general, Windows is totally different, but all the other builds share
  # some common compiler and linker configuration.
  if (!is_win) {
    # Common POSIX compiler flags setup.
    # --------------------------------
    cflags += [ "-fno-strict-aliasing" ]  # See http://crbug.com/32204

    # Stack protection. ShadowCallStack and Stack protector address the same
    # problems. Therefore, we only enable one or the other. Clang advertises SCS as
    # a stronger alternative to StackProtector, so we give SCS precedence over SP.
    if (enable_shadow_call_stack) {
      # On Aarch64, SCS requires the x18 register to be unused because it will hold
      # a pointer to the shadow stack. For Android we know that Clang doesn't use
      # x18 by default. On other OSs adding "-ffixed-x18" might be required.
      assert(is_android)

      scs_parameters = [
        "-fsanitize=shadow-call-stack",
        "-fno-stack-protector",
      ]
      cflags += scs_parameters
      ldflags += scs_parameters
    } else {
      if (is_apple) {
        # The strong variant of the stack protector significantly increases
        # binary size, so only enable it in debug mode.
        if (is_debug) {
          cflags += [ "-fstack-protector-strong" ]
        } else {
          cflags += [ "-fstack-protector" ]
        }
      } else if (is_chromeos) {
        cflags += [ "-fstack-protector-strong" ]
      } else if ((is_posix && !is_nacl) || is_fuchsia) {
        if (current_os != "aix") {
          # Not available on aix.
          cflags += [ "-fstack-protector" ]
        }
      }
    }

    if (use_lld) {
      ldflags += [ "-fuse-ld=lld" ]
      if (lld_path != "") {
        ldflags += [ "-B$lld_path" ]
      }
    }

    # Linker warnings.
    if (fatal_linker_warnings && !is_apple && current_os != "aix" &&
        current_os != "zos") {
      ldflags += [ "-Wl,--fatal-warnings" ]
    }
    if (fatal_linker_warnings && is_apple) {
      ldflags += [ "-Wl,-fatal_warnings" ]
    }
  }

  if (is_clang && is_debug) {
    # Allow comparing the address of references and 'this' against 0
    # in debug builds. Technically, these can never be null in
    # well-defined C/C++ and Clang can optimize such checks away in
    # release builds, but they may be used in asserts in debug builds.
    cflags_cc += [
      "-Wno-undefined-bool-conversion",
      "-Wno-tautological-undefined-compare",
    ]
  }

  # Non-Apple Posix and Fuchsia compiler flags setup.
  # -----------------------------------
  if ((is_posix && !is_apple) || is_fuchsia) {
    if (enable_profiling) {
      if (!is_debug) {
        cflags += [ "-g" ]

        if (enable_full_stack_frames_for_profiling) {
          cflags += [
            "-fno-inline",
            "-fno-optimize-sibling-calls",
          ]
        }
      }
    }

    # Explicitly pass --build-id to ld. Compilers used to always pass this
    # implicitly but don't any more (in particular clang when built without
    # ENABLE_LINKER_BUILD_ID=ON).
    if (is_official_build || is_chrome_branded) {
      # The sha1 build id has lower risk of collision but is more expensive to
      # compute, so only use it in the official build to avoid slowing down
      # links.
      ldflags += [ "-Wl,--build-id=sha1" ]
    } else if (current_os != "aix" && current_os != "zos") {
      if (use_lld && !is_nacl) {
        ldflags += [ "-Wl,--build-id=fast" ]
      } else {
        ldflags += [ "-Wl,--build-id" ]
      }
    }

    if (!is_android) {
      defines += [
        # _FILE_OFFSET_BITS=64 should not be set on Android in order to maintain
        # the behavior of the Android NDK from earlier versions.
        # See https://android-developers.googleblog.com/2017/09/introducing-android-native-development.html
        "_FILE_OFFSET_BITS=64",
        "_LARGEFILE_SOURCE",
        "_LARGEFILE64_SOURCE",
      ]
    }

    if (!is_nacl) {
      if (exclude_unwind_tables) {
        cflags += [
          "-fno-unwind-tables",
          "-fno-asynchronous-unwind-tables",
        ]
        rustflags += [ "-Cforce-unwind-tables=no" ]
        defines += [ "NO_UNWIND_TABLES" ]
      } else {
        cflags += [ "-funwind-tables" ]
        rustflags += [ "-Cforce-unwind-tables=yes" ]
      }
    }
  }

  # Apple compiler flags setup.
  # ---------------------------------
  if (is_apple) {
    # On Intel, clang emits both Apple's "compact unwind" information and
    # DWARF eh_frame unwind information by default, for compatibility reasons.
    # This flag limits emission of eh_frame information to functions
    # whose unwind information can't be expressed in the compact unwind format
    # (which in practice means almost everything gets only compact unwind
    # entries). This reduces object file size a bit and makes linking a bit
    # faster.
    # On arm64, this is already the default behavior.
    if (current_cpu == "x64") {
      asmflags += [ "-femit-dwarf-unwind=no-compact-unwind" ]
      cflags += [ "-femit-dwarf-unwind=no-compact-unwind" ]
    }

    # dsymutil is not available in the system, on bots, for rustc to call. Our
    # linker_driver.py script runs dsymutil itself, which is set to be the
    # linker for Rust targets as well.
    rustflags += [ "-Csplit-debuginfo=unpacked" ]
  }

  # Linux/Android/Fuchsia common flags setup.
  # ---------------------------------
  if (is_linux || is_chromeos || is_android || is_fuchsia) {
    asmflags += [ "-fPIC" ]
    cflags += [ "-fPIC" ]
    ldflags += [ "-fPIC" ]
    rustflags += [ "-Crelocation-model=pic" ]

    if (!is_clang) {
      # Use pipes for communicating between sub-processes. Faster.
      # (This flag doesn't do anything with Clang.)
      cflags += [ "-pipe" ]
    }

    ldflags += [
      "-Wl,-z,noexecstack",
      "-Wl,-z,relro",
    ]

    if (!is_component_build) {
      ldflags += [ "-Wl,-z,now" ]
    }
  }

  # Linux-specific compiler flags setup.
  # ------------------------------------
  if (use_icf && (!is_apple || use_lld)) {
    ldflags += [ "-Wl,--icf=all" ]
  }

  if (is_linux || is_chromeos) {
    cflags += [ "-pthread" ]
    # Do not use the -pthread ldflag here since it becomes a no-op
    # when using -nodefaultlibs, which would cause an unused argument
    # error.  "-lpthread" is added in //build/config:default_libs.
  }

  # ChromeOS-specific compiler flags setup.
  # ---------------------------------------
  if (is_chromeos) {
    cflags += [ "-Werror=poison-system-directories" ]
  }

  # Clang-specific compiler flags setup.
  # ------------------------------------
  if (is_clang) {
    cflags += [ "-fcolor-diagnostics" ]

    # Enable -fmerge-all-constants. This used to be the default in clang
    # for over a decade. It makes clang non-conforming, but is fairly safe
    # in practice and saves some binary size. We might want to consider
    # disabling this (https://bugs.llvm.org/show_bug.cgi?id=18538#c13),
    # but for now it looks like our build might rely on it
    # (https://crbug.com/829795).
    cflags += [ "-fmerge-all-constants" ]

    # TODO(crbug.com/345541122): investigate the fuchsia binary size increase.
    if (is_win) {
      cflags += [ "/Zc:sizedDealloc-" ]
    } else {
      cflags += [ "-fno-sized-deallocation" ]
    }
  }

  if (use_lld) {
    # TODO(thakis): Make the driver pass --color-diagnostics to the linker
    # if -fcolor-diagnostics is passed to it, and pass -fcolor-diagnostics
    # in ldflags instead.
    if (is_win) {
      # On Windows, we call the linker directly, instead of calling it through
      # the driver.
      ldflags += [ "--color-diagnostics" ]
    } else {
      ldflags += [ "-Wl,--color-diagnostics" ]
    }
  }

  # Enable text section splitting only on linux when using lld for now. Other
  # platforms can be added later if needed.
  if ((is_linux || is_chromeos) && use_lld && use_text_section_splitting) {
    ldflags += [ "-Wl,-z,keep-text-section-prefix" ]
  }

  if (is_clang && !is_nacl) {
    cflags += [ "-fcrash-diagnostics-dir=" + clang_diagnostic_dir ]
    if (save_reproducers_on_lld_crash && use_lld) {
      ldflags += [
        "-fcrash-diagnostics=all",
        "-fcrash-diagnostics-dir=" + clang_diagnostic_dir,
      ]
    }

    # TODO(hans): Remove this once Clang generates better optimized debug info
    # by default. https://crbug.com/765793
    cflags += [
      "-mllvm",
      "-instcombine-lower-dbg-declare=0",
    ]
    if (!is_debug && use_thin_lto && is_a_target_toolchain) {
      if (is_win) {
        ldflags += [ "-mllvm:-instcombine-lower-dbg-declare=0" ]
      } else {
        ldflags += [ "-Wl,-mllvm,-instcombine-lower-dbg-declare=0" ]
      }
    }

    # TODO(crbug.com/40283598): This causes binary size growth and potentially
    # other problems.
    # TODO(crbug.com/40284925): This isn't supported by Cronet's mainline llvm version.
    if (default_toolchain != "//build/toolchain/cros:target" &&
        !llvm_android_mainline) {
      cflags += [
        "-mllvm",
        "-split-threshold-for-reg-with-hint=0",
      ]
      if (use_thin_lto && is_a_target_toolchain) {
        if (is_win) {
          ldflags += [ "-mllvm:-split-threshold-for-reg-with-hint=0" ]
        } else {
          ldflags += [ "-Wl,-mllvm,-split-threshold-for-reg-with-hint=0" ]
        }
      }
    }

    # TODO(crbug.com/40192287): Investigate why/if this should be needed.
    if (is_win) {
      cflags += [ "/clang:-ffp-contract=off" ]
    } else {
      cflags += [ "-ffp-contract=off" ]
    }

    # Enable ELF CREL (see crbug.com/357878242) for all platforms that use ELF
    # (excluding toolchains that use an older version of LLVM).
    # TODO(crbug.com/376278218): This causes segfault on Linux ARM builds.
    if (is_linux && !llvm_android_mainline && current_cpu != "arm" &&
        default_toolchain != "//build/toolchain/cros:target") {
      cflags += [ "-Wa,--crel,--allow-experimental-crel" ]
    }
  }

  # C11/C++11 compiler flags setup.
  # ---------------------------
  if (is_linux || is_chromeos || is_android || (is_nacl && is_clang) ||
      current_os == "aix") {
    if (is_clang) {
      standard_prefix = "c"

      # Since we build with -std=c* and not -std=gnu*, _GNU_SOURCE will not be
      # defined by the compiler.  However, lots of code relies on the
      # non-standard features that _GNU_SOURCE enables, so define it manually.
      defines += [ "_GNU_SOURCE" ]

      if (is_nacl) {
        # Undefine __STRICT_ANSI__ to get non-standard features which would
        # otherwise not be enabled by NaCl's sysroots.
        cflags += [ "-U__STRICT_ANSI__" ]
      }
    } else {
      # Gcc does not support ##__VA_ARGS__ when in standards-conforming mode,
      # but we use this feature in several places in Chromium.
      # TODO(thomasanderson): Replace usages of ##__VA_ARGS__ with the
      # standard-compliant __VA_OPT__ added by C++20, and switch the gcc build
      # to -std=c*.
      standard_prefix = "gnu"
    }

    cflags_c += [ "-std=${standard_prefix}11" ]
    if (is_nacl && !is_nacl_saigo) {
      # This is for the pnacl_newlib toolchain. It's only used to build
      # a few independent ppapi test files that don't pull in any other
      # dependencies.
      cflags_cc += [ "-std=${standard_prefix}++14" ]
      if (is_clang) {
        cflags_cc += [ "-fno-trigraphs" ]
      }
    } else if (is_clang) {
      if (defined(use_cxx17) && use_cxx17) {
        cflags_cc += [ "-std=${standard_prefix}++17" ]
      } else {
        cflags_cc += [ "-std=${standard_prefix}++20" ]
      }
    } else {
      # The gcc bots are currently using GCC 9, which is not new enough to
      # support "c++20"/"gnu++20".
      cflags_cc += [ "-std=${standard_prefix}++2a" ]
    }
  } else if (is_win) {
    cflags_c += [ "/std:c11" ]
    if (defined(use_cxx17) && use_cxx17) {
      cflags_cc += [ "/std:c++17" ]
    } else {
      cflags_cc += [ "/std:c++20" ]
    }
    if (!is_clang) {
      # Required for the __cplusplus macro definition to match the C++ version
      # on MSVC. clang-cl defines it by default and doesn't need this flag.
      # See: https://learn.microsoft.com/en-us/cpp/build/reference/zc-cplusplus
      cflags_cc += [ "/Zc:__cplusplus" ]
    }
  } else if (!is_nacl) {
    # TODO(mcgrathr) - the NaCl GCC toolchain doesn't support either
    # gnu11/gnu++11 or c11/c++11; we technically don't need this toolchain any
    # more, but there are still a few buildbots using it, so until those are
    # turned off we need the !is_nacl clause and the (is_nacl && is_clang)
    # clause, above.
    cflags_c += [ "-std=c11" ]

    if (defined(use_cxx17) && use_cxx17) {
      cflags_cc += [ "-std=c++17" ]
    } else {
      cflags_cc += [ "-std=c++20" ]
    }
  }

  if (is_clang) {
    # C++17 removes trigraph support, but clang still warns that it ignores
    # them when seeing them.  Don't.
    cflags_cc += [ "-Wno-trigraphs" ]
  }

  if (use_relative_vtables_abi) {
    cflags_cc += [ "-fexperimental-relative-c++-abi-vtables" ]
    ldflags += [ "-fexperimental-relative-c++-abi-vtables" ]
  }

  # Add flags for link-time optimization. These flags enable
  # optimizations/transformations that require whole-program visibility at link
  # time, so they need to be applied to all translation units, and we may end up
  # with miscompiles if only part of the program is compiled with LTO flags. For
  # that reason, we cannot allow targets to enable or disable these flags, for
  # example by disabling the optimize configuration.
  # TODO(pcc): Make this conditional on is_official_build rather than on gn
  # flags for specific features.
  #
  # High-end Android: While Full LTO provides a small performance improvement
  # (according to Speedometer), it also results in an unacceptable increase in
  # build time. Thin LTO appears to provide the best build time-optimization
  # tradeoff. As of April 2024, Full LTO:
  #   - Increases build time by ~1:30 hours, to ~2:40 hours (from ~1:10 hours
  #     with Thin LTO) on Chromium builders.
  #   - Increases Speedometer 2.1 score by 1.1% [0].
  #   - Increases Speedometer 3.0 score by 1.2% [1].
  # ... over Thin LTO.
  #
  # [0]: https://pinpoint-dot-chromeperf.appspot.com/job/15efb0313e0000
  # [1]: https://pinpoint-dot-chromeperf.appspot.com/job/157f0b42be0000
  if (!is_debug && use_thin_lto && is_a_target_toolchain) {
    assert(use_lld, "LTO is only supported with lld")

    cflags += [
      "-flto=thin",
      "-fsplit-lto-unit",
    ]

    if (thin_lto_enable_cache) {
      # Limit the size of the ThinLTO cache to the lesser of 10% of
      # available disk space, 40GB and 100000 files.
      cache_policy =
          "cache_size=10%:cache_size_bytes=40g:cache_size_files=100000"
      cache_dir = rebase_path("$root_out_dir/thinlto-cache", root_build_dir)
      if (is_win) {
        ldflags += [
          "/lldltocache:$cache_dir",
          "/lldltocachepolicy:$cache_policy",
        ]
      } else {
        if (is_apple) {
          ldflags += [ "-Wl,-cache_path_lto,$cache_dir" ]
        } else {
          ldflags += [ "-Wl,--thinlto-cache-dir=$cache_dir" ]
        }
        ldflags += [ "-Wl,--thinlto-cache-policy=$cache_policy" ]
      }
    }

    # An import limit of 30 has better performance (per speedometer) and lower
    # binary size than the default setting of 100.
    # TODO(gbiv): We ideally shouldn't need to specify this; ThinLTO
    # should be able to better manage binary size increases on its own.
    #
    # For high-end Android, 30 seems to be the right trade-off between performance
    # and binary size, at least based on Speedometer. For example, increasing
    # `import_instr_limit`to 50 improves Speedometer 2.1 score by 0.7% [0], while
    # Speedometer 3.0 score remains roughly the same (-0.1%) [1]. The binary size
    # increases by about 2MB [2] (or 1.1%: the arm64 native code size in M124 is
    # 178MB).
    # [0]: https://pinpoint-dot-chromeperf.appspot.com/job/16984a18be0000
    # [1]: https://pinpoint-dot-chromeperf.appspot.com/job/11984a18be0000
    # [2]: https://ci.chromium.org/ui/p/chromium/builders/try/android-binary-size/1848442
    import_instr_limit = 30

    if (is_win) {
      ldflags += [
        "/opt:lldltojobs=all",
        "-mllvm:-import-instr-limit=$import_instr_limit",
        "-mllvm:-disable-auto-upgrade-debug-info",
      ]
    } else {
      ldflags += [ "-flto=thin" ]

      # Enabling ThinLTO on Chrome OS too, in an effort to reduce the memory
      # usage in crbug.com/1038040. Note this will increase build time in
      # Chrome OS.

      # In ThinLTO builds, we run at most one link process at a time,
      # and let it use all cores.
      # TODO(thakis): Check if '=0' (that is, number of cores, instead
      # of "all" which means number of hardware threads) is faster.
      ldflags += [ "-Wl,--thinlto-jobs=all" ]

      if (is_chromeos) {
        # ARM was originally set lower than x86 to keep the size
        # bloat of ThinLTO to <10%, but that's potentially no longer true.
        # FIXME(inglorion): maybe tune these?
        # TODO(b/271459198): Revert limit on amd64 to 30 when fixed.
        import_instr_limit = 20
      } else if (is_android && optimize_for_size) {
        # TODO(crbug.com/40219076): Investigate if we can get the > 6% perf win
        # of import_instr_limit 30 with a binary size hit smaller than ~2 MiB.
        import_instr_limit = 5
      }

      ldflags += [ "-Wl,-mllvm,-import-instr-limit=$import_instr_limit" ]

      if (is_apple) {
        ldflags += [ "-Wcrl,object_path_lto" ]
      }

      # We only use one version of LLVM within a build so there's no need to
      # upgrade debug info, which can be expensive since it runs the verifier.
      ldflags += [ "-Wl,-mllvm,-disable-auto-upgrade-debug-info" ]
    }

    if (!optimize_for_size) {
      # Ideally the compiler would handle this automatically with PGO (see
      # comments at https://crrev.com/c/5440500).
      cflags += [
        "-mllvm",
        "-inlinehint-threshold=360",
      ]
      if (is_win) {
        ldflags += [ "-mllvm:-inlinehint-threshold=360" ]
      } else {
        ldflags += [ "-Wl,-mllvm,-inlinehint-threshold=360" ]
      }
    }

    # TODO(crbug.com/40182783): investigate why this isn't effective on
    # arm32.
    if (!is_android || current_cpu == "arm64") {
      cflags += [ "-fwhole-program-vtables" ]

      if (toolchain_supports_rust_thin_lto) {
        # whole-program-vtables implies -fsplit-lto-unit, and Rust needs to match
        # behaviour. Rust needs to know the linker will be doing LTO in this case
        # or it rejects the Zsplit-lto-unit flag.
        rustflags += [
          "-Zsplit-lto-unit",
          "-Clinker-plugin-lto=yes",
        ]
      } else {
        # Don't include bitcode if it won't be used.
        rustflags += [ "-Cembed-bitcode=no" ]
      }

      if (!is_win) {
        ldflags += [ "-fwhole-program-vtables" ]
      }
    }

    # This flag causes LTO to create an .ARM.attributes section with the correct
    # architecture. This is necessary because LLD will refuse to link a program
    # unless the architecture revision in .ARM.attributes is sufficiently new.
    # TODO(pcc): The contents of .ARM.attributes should be based on the
    # -march flag passed at compile time (see llvm.org/pr36291).
    if (current_cpu == "arm") {
      ldflags += [ "-march=$arm_arch" ]
    }
  }

  if (compiler_timing) {
    if (is_clang && !is_nacl) {
      cflags += [ "-ftime-trace" ]
      if (use_lld && is_mac) {
        ldflags += [ "-Wl,--time-trace" ]
      }
    } else if (is_win) {
      cflags += [
        # "Documented" here:
        # http://aras-p.info/blog/2017/10/23/Best-unknown-MSVC-flag-d2cgsummary/
        "/d2cgsummary",
      ]
    }
  }

  # Pass flag to LLD so Android builds can allow debuggerd to properly symbolize
  # stack crashes (http://crbug.com/919499).
  if (use_lld && is_android) {
    ldflags += [ "-Wl,--no-rosegment" ]
  }

  # TODO(crbug.com/40242425): Cleanup undefined symbol errors caught by
  # --no-undefined-version.
  if (use_lld && !is_win && !is_mac && !is_ios) {
    ldflags += [ "-Wl,--undefined-version" ]
  }

  if (use_lld && is_apple) {
    ldflags += [ "-Wl,--strict-auto-link" ]
  }

  # LLD does call-graph-sorted binary layout by default when profile data is
  # present. On Android this increases binary size due to more thinks for long
  # jumps. Turn it off by default and enable selectively for targets where it's
  # beneficial.
  if (use_lld && !enable_call_graph_profile_sort) {
    if (is_win) {
      ldflags += [ "/call-graph-profile-sort:no" ]
    } else {
      ldflags += [ "-Wl,--no-call-graph-profile-sort" ]
    }
  }

  if (is_clang && !is_nacl && show_includes) {
    if (is_win) {
      cflags += [
        "/clang:-H",
        "/clang:-fshow-skipped-includes",
      ]
    } else {
      cflags += [
        "-H",
        "-fshow-skipped-includes",
      ]
    }
  }

  # This flag enforces that member pointer base types are complete. It helps
  # prevent us from running into problems in the Microsoft C++ ABI (see
  # https://crbug.com/847724).
  if (is_clang && !is_nacl && target_os != "chromeos" &&
      (is_win || use_custom_libcxx)) {
    cflags += [ "-fcomplete-member-pointers" ]
  }

  # Use DWARF simple template names.
  if (simple_template_names) {
    cflags_cc += [ "-gsimple-template-names" ]
  }

  # MLGO specific flags. These flags enable an ML-based inliner trained on
  # Chrome on Android (arm32) with ThinLTO enabled, optimizing for size.
  # The "release" ML model is embedded into clang as part of its build.
  # Currently, the ML inliner is only enabled when targeting Android due to:
  # a) Android is where size matters the most.
  # b) MLGO presently has the limitation of only being able to embed one model
  #    at a time; It is unclear if the embedded model is beneficial for
  #    non-Android targets.
  # MLGO is only officially supported on linux.
  if (use_ml_inliner && is_a_target_toolchain) {
    assert(
        is_android && host_os == "linux",
        "MLGO is currently only supported for targeting Android on a linux host")
    if (use_thin_lto) {
      ldflags += [ "-Wl,-mllvm,-enable-ml-inliner=release" ]
      if (is_high_end_android) {
        # Besides using the arm64 - trained model, instruct the inline advisor
        # to not use the ML policy (which will aim to reduce size) for any
        # callsites where the caller is not cold. This avoids performance
        # regressions while still bringing size benefits.
        # Profile quality is essential here.
        ldflags += [
          "-Wl,-mllvm,-ml-inliner-model-selector=arm64-mixed",
          "-Wl,-mllvm,-ml-inliner-skip-policy=if-caller-not-cold",
        ]
      } else {
        ldflags += [ "-Wl,-mllvm,-ml-inliner-model-selector=arm32-size" ]
      }
    }
  }

  if (clang_embed_bitcode) {
    assert(!use_thin_lto,
           "clang_embed_bitcode is only supported in non-ThinLTO builds")
    cflags += [
      "-Xclang",
      "-fembed-bitcode=all",
    ]
  }

  if (lld_emit_indexes_and_imports) {
    assert(use_thin_lto,
           "lld_emit_indexes_and_imports is only supported with ThinLTO builds")
    ldflags += [
      "-Wl,--save-temps=import",
      "-Wl,--thinlto-emit-index-files",
    ]
  }

  # Pass the same C/C++ flags to the objective C/C++ compiler.
  cflags_objc += cflags_c
  cflags_objcc += cflags_cc

  # Assign any flags set for the C compiler to asmflags so that they are sent
  # to the assembler. The Windows assembler takes different types of flags
  # so only do so for posix platforms.
  if (is_posix || is_fuchsia) {
    asmflags += cflags
    asmflags += cflags_c
  }

  if (is_chromeos_device && !is_nacl) {
    # On ChromeOS devices, we want to ensure we're using Chrome's allocator
    # symbols for all C++ new/delete operator overloads. PartitionAlloc
    # and other local allocators should always take precedence over system or
    # preloaded allocators. These are the mangled symbol names.
    # See b/280115910 for details.
    ldflags += [
      "-Wl,--export-dynamic-symbol=_ZdaPv,-u,_ZdaPv",
      "-Wl,--export-dynamic-symbol=_ZdaPvRKSt9nothrow_t,-u,_ZdaPvRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_ZdlPv,-u,_ZdlPv",
      "-Wl,--export-dynamic-symbol=_ZdlPvm,-u,_ZdlPvm",
      "-Wl,--export-dynamic-symbol=_ZdlPvRKSt9nothrow_t,-u,_ZdlPvRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_Znam,-u,_Znam",
      "-Wl,--export-dynamic-symbol=_ZnamRKSt9nothrow_t,-u,_ZnamRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_Znwm,-u,_Znwm",
      "-Wl,--export-dynamic-symbol=_ZnwmRKSt9nothrow_t,-u,_ZnwmRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_ZdaPvmSt11align_val_t,-u,_ZdaPvmSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZdaPvSt11align_val_t,-u,_ZdaPvSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZdaPvSt11align_val_tRKSt9nothrow_t,-u,_ZdaPvSt11align_val_tRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_ZdlPvmSt11align_val_t,-u,_ZdlPvmSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZdlPvSt11align_val_t,-u,_ZdlPvSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZdlPvSt11align_val_tRKSt9nothrow_t,-u,_ZdlPvSt11align_val_tRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_ZnamSt11align_val_t,-u,_ZnamSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZnamSt11align_val_tRKSt9nothrow_t,-u,_ZnamSt11align_val_tRKSt9nothrow_t",
      "-Wl,--export-dynamic-symbol=_ZnwmSt11align_val_t,-u,_ZnwmSt11align_val_t",
      "-Wl,--export-dynamic-symbol=_ZnwmSt11align_val_tRKSt9nothrow_t,-u,_ZnwmSt11align_val_tRKSt9nothrow_t",
    ]
  }

  # Rust compiler flags setup.
  # ---------------------------
  rustflags += [
    # By default Rust passes `-nodefaultlibs` to the linker, however this
    # conflicts with our `--unwind=none` flag for Android dylibs, as the latter
    # is then unused and produces a warning/error. So this removes the
    # `-nodefaultlibs` from the linker invocation from Rust, which would be used
    # to compile dylibs on Android, such as for constructing unit test APKs.
    "-Cdefault-linker-libraries",

    # To make Rust .d files compatible with ninja
    "-Zdep-info-omit-d-target",

    # If a macro panics during compilation, show which macro and where it is
    # defined.
    "-Zmacro-backtrace",

    # For deterministic builds, keep the local machine's current working
    # directory from appearing in build outputs.
    "-Zremap-cwd-prefix=.",

    # We use clang-rt sanitizer runtimes.
    "-Zexternal-clangrt",
  ]

  if (!is_win || force_rustc_color_output) {
    # Colorize error output. The analogous flag is passed for clang. This must
    # be platform-gated since rustc will unconditionally output ANSI escape
    # sequences, ignoring the platform, when stderr is not a terminal.
    rustflags += [ "--color=always" ]
  }
  if (rust_abi_target != "") {
    rustflags += [ "--target=$rust_abi_target" ]
  }
  if (!use_thin_lto || !toolchain_supports_rust_thin_lto) {
    # Don't include bitcode if it won't be used.
    rustflags += [ "-Cembed-bitcode=no" ]

    # Disable "automatic" ThinLTO between codegen units. The weak symbol
    # resolution across units can have surprising effects on linking, see
    # crbug.com/324126269 and github.com/rust-lang/rust/issues/120842.
    rustflags += [ "-Clto=no" ]
  }
  if (is_official_build) {
    rustflags += [ "-Ccodegen-units=1" ]
  }
  if (!rust_prebuilt_stdlib) {
    # When building against the Chromium Rust stdlib (which we compile) always
    # abort instead of unwinding when panic occurs. In official builds, panics
    # abort immediately (this is configured in the stdlib) to keep binary size
    # down. So we unconditionally match behaviour in unofficial too.
    rustflags += [
      "-Cpanic=abort",
      "-Zpanic_abort_tests",
    ]
  }

  # 64-bit Android sometimes defines __ARM_NEON but not __ARM_NEON__.
  # 32-bit Android builds and macOS, however, define __ARM_NEON__,
  # and code typically checks for this.
  #
  # Reduce confusion by making the __ARM_NEON__ #define always available,
  # as NEON is a mandatory part of ARMv8 anyway.
  if (current_cpu == "arm64") {
    defines += [ "__ARM_NEON__=1" ]
  }
}

# Don't allow unstable features to be enabled by `#![feature()]` without
# additional command line flags.
config("disallow_unstable_features") {
  rustflags = [ "-Zallow-features=" ]
}

config("libcxx_hardening") {
  # Normally, this would be defined in the `runtime_library` config but NaCl
  # saigo libc++ does not use the custom hermetic libc++. Unfortunately, there
  # isn't really a better config to add this define for the define to
  # consistently apply in both Chromium and non-Chromium code *and* non-NaCl and
  # NaCl code.
  #
  # TODO(crbug.com/40511454): Move this back to the `runtime_library` config
  # when NaCl is removed.
  if (use_safe_libcxx) {
    defines = [ "_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_EXTENSIVE" ]
  } else {
    defines = [ "_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_NONE" ]
  }

  # Enable libstdc++ hardening lightweight assertions. Those have a low
  # performance penalty but are considered a bare minimum for security.
  if (use_safe_libstdcxx) {
    defines += [ "_GLIBCXX_ASSERTIONS=1" ]
  }
}

# The BUILDCONFIG file sets this config on targets by default, which means when
# building with ThinLTO, no optimization is performed in the link step.
config("thinlto_optimize_default") {
  if (!is_debug && use_thin_lto && is_a_target_toolchain) {
    lto_opt_level = 0

    if (is_win) {
      ldflags = [ "/opt:lldlto=" + lto_opt_level ]
    } else {
      ldflags = [ "-Wl,--lto-O" + lto_opt_level ]
    }

    if (toolchain_supports_rust_thin_lto) {
      # We always point Rust to a linker that performs LTO, so we don't want Rust
      # to preemptively do so during compilation too or they conflict. But we do
      # want Rust to generate LTO metadata in order for the linker to do its job.
      rustflags = [ "-Clinker-plugin-lto=yes" ]
    } else {
      # Don't include bitcode if it won't be used.
      rustflags = [ "-Cembed-bitcode=no" ]
    }
  }
}

# Use this to enable optimization in the ThinLTO link step for select targets
# when thin_lto_enable_optimizations is set by doing:
#
#   configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
#   configs += [ "//build/config/compiler:thinlto_optimize_max" ]
#
# Since it makes linking significantly slower and more resource intensive, only
# use it on important targets such as the main browser executable or dll.
config("thinlto_optimize_max") {
  if (!is_debug && use_thin_lto && is_a_target_toolchain) {
    if (thin_lto_enable_optimizations) {
      lto_opt_level = 2
    } else {
      lto_opt_level = 0
    }

    if (is_win) {
      ldflags = [ "/opt:lldlto=" + lto_opt_level ]
    } else {
      ldflags = [ "-Wl,--lto-O" + lto_opt_level ]
    }

    if (toolchain_supports_rust_thin_lto) {
      # We always point Rust to a linker that performs LTO, so we don't want Rust
      # to preemptively do so during compilation too or they conflict. But we do
      # want Rust to generate LTO metadata in order for the linker to do its job.
      rustflags = [ "-Clinker-plugin-lto=yes" ]
    } else {
      # Don't include bitcode if it won't be used.
      rustflags = [ "-Cembed-bitcode=no" ]
    }
  }
}

# This provides the basic options to select the target CPU and ABI.
# It is factored out of "compiler" so that special cases can use this
# without using everything that "compiler" brings in.  Options that
# tweak code generation for a particular CPU do not belong here!
# See "compiler_codegen", below.
config("compiler_cpu_abi") {
  cflags = []
  ldflags = []
  defines = []

  configs = []
  if (is_chromeos) {
    configs += [ "//build/config/chromeos:compiler_cpu_abi" ]
  }

  if ((is_posix && !is_apple) || is_fuchsia) {
    # CPU architecture. We may or may not be doing a cross compile now, so for
    # simplicity we always explicitly set the architecture.
    if (current_cpu == "x64") {
      cflags += [
        "-m64",
        "-msse3",
      ]

      # Minimum SIMD support for devices running lacros.
      # See https://crbug.com/1475858
      if (is_chromeos_lacros) {
        cflags += [
          "-mssse3",
          "-msse4",
          "-msse4.1",
          "-msse4.2",
        ]
      }
      ldflags += [ "-m64" ]
    } else if (current_cpu == "x86") {
      cflags += [ "-m32" ]
      ldflags += [ "-m32" ]
      if (!is_nacl) {
        cflags += [
          "-mfpmath=sse",
          "-msse3",
        ]
      }
    } else if (current_cpu == "arm") {
      if (is_clang && !is_android && !is_nacl && !is_chromeos_device) {
        cflags += [ "--target=arm-linux-gnueabihf" ]
        ldflags += [ "--target=arm-linux-gnueabihf" ]
      }
      if (!is_nacl) {
        cflags += [
          "-march=$arm_arch",
          "-mfloat-abi=$arm_float_abi",
        ]
      }
      if (arm_tune != "") {
        cflags += [ "-mtune=$arm_tune" ]
      }
    } else if (current_cpu == "arm64") {
      if (is_clang && !is_android && !is_nacl && !is_fuchsia &&
          !is_chromeos_device) {
        cflags += [ "--target=aarch64-linux-gnu" ]
        ldflags += [ "--target=aarch64-linux-gnu" ]
      }
    } else if (current_cpu == "mipsel" && !is_nacl) {
      ldflags += [ "-Wl,--hash-style=sysv" ]
      if (custom_toolchain == "") {
        if (is_clang) {
          if (is_android) {
            cflags += [ "--target=mipsel-linux-android" ]
            ldflags += [ "--target=mipsel-linux-android" ]
          } else {
            cflags += [ "--target=mipsel-linux-gnu" ]
            ldflags += [ "--target=mipsel-linux-gnu" ]
          }
        } else {
          cflags += [ "-EL" ]
          ldflags += [ "-EL" ]
        }
      }

      if (mips_arch_variant == "r6") {
        cflags += [ "-mno-odd-spreg" ]
        ldflags += [ "-mips32r6" ]
        if (is_clang) {
          cflags += [
            "-march=mipsel",
            "-mcpu=mips32r6",
          ]
        } else {
          cflags += [
            "-mips32r6",
            "-Wa,-mips32r6",
          ]
          if (is_android) {
            ldflags += [ "-Wl,-melf32ltsmip" ]
          }
        }
        if (mips_use_msa == true) {
          cflags += [
            "-mmsa",
            "-mfp64",
          ]
        }
      } else if (mips_arch_variant == "r2") {
        ldflags += [ "-mips32r2" ]
        if (is_clang) {
          cflags += [
            "-march=mipsel",
            "-mcpu=mips32r2",
          ]
        } else {
          cflags += [
            "-mips32r2",
            "-Wa,-mips32r2",
          ]
          if (mips_float_abi == "hard" && mips_fpu_mode != "") {
            cflags += [ "-m$mips_fpu_mode" ]
          }
        }
      } else if (mips_arch_variant == "r1") {
        ldflags += [ "-mips32" ]
        if (is_clang) {
          cflags += [
            "-march=mipsel",
            "-mcpu=mips32",
          ]
        } else {
          cflags += [
            "-mips32",
            "-Wa,-mips32",
          ]
        }
      } else if (mips_arch_variant == "loongson3") {
        defines += [ "_MIPS_ARCH_LOONGSON" ]
        cflags += [
          "-march=loongson3a",
          "-mno-branch-likely",
          "-Wa,-march=loongson3a",
        ]
      }

      if (mips_dsp_rev == 1) {
        cflags += [ "-mdsp" ]
      } else if (mips_dsp_rev == 2) {
        cflags += [ "-mdspr2" ]
      }

      cflags += [ "-m${mips_float_abi}-float" ]
    } else if (current_cpu == "mips" && !is_nacl) {
      ldflags += [ "-Wl,--hash-style=sysv" ]
      if (custom_toolchain == "") {
        if (is_clang) {
          cflags += [ "--target=mips-linux-gnu" ]
          ldflags += [ "--target=mips-linux-gnu" ]
        } else {
          cflags += [ "-EB" ]
          ldflags += [ "-EB" ]
        }
      }

      if (mips_arch_variant == "r6") {
        cflags += [
          "-mips32r6",
          "-Wa,-mips32r6",
        ]
        if (mips_use_msa == true) {
          cflags += [
            "-mmsa",
            "-mfp64",
          ]
        }
      } else if (mips_arch_variant == "r2") {
        cflags += [
          "-mips32r2",
          "-Wa,-mips32r2",
        ]
        if (mips_float_abi == "hard" && mips_fpu_mode != "") {
          cflags += [ "-m$mips_fpu_mode" ]
        }
      } else if (mips_arch_variant == "r1") {
        cflags += [
          "-mips32",
          "-Wa,-mips32",
        ]
      }

      if (mips_dsp_rev == 1) {
        cflags += [ "-mdsp" ]
      } else if (mips_dsp_rev == 2) {
        cflags += [ "-mdspr2" ]
      }

      cflags += [ "-m${mips_float_abi}-float" ]
    } else if (current_cpu == "mips64el") {
      cflags += [ "-D__SANE_USERSPACE_TYPES__" ]
      ldflags += [ "-Wl,--hash-style=sysv" ]
      if (custom_toolchain == "") {
        if (is_clang) {
          if (is_android) {
            cflags += [ "--target=mips64el-linux-android" ]
            ldflags += [ "--target=mips64el-linux-android" ]
          } else {
            cflags += [ "--target=mips64el-linux-gnuabi64" ]
            ldflags += [ "--target=mips64el-linux-gnuabi64" ]
          }
        } else {
          cflags += [
            "-EL",
            "-mabi=64",
          ]
          ldflags += [
            "-EL",
            "-mabi=64",
          ]
        }
      }

      if (mips_arch_variant == "r6") {
        if (is_clang) {
          cflags += [
            "-march=mips64el",
            "-mcpu=mips64r6",
          ]
        } else {
          cflags += [
            "-mips64r6",
            "-Wa,-mips64r6",
          ]
          ldflags += [ "-mips64r6" ]
        }
        if (mips_use_msa == true) {
          cflags += [
            "-mmsa",
            "-mfp64",
          ]
        }
      } else if (mips_arch_variant == "r2") {
        ldflags += [ "-mips64r2" ]
        if (is_clang) {
          cflags += [
            "-march=mips64el",
            "-mcpu=mips64r2",
          ]
        } else {
          cflags += [
            "-mips64r2",
            "-Wa,-mips64r2",
          ]
        }
      } else if (mips_arch_variant == "loongson3") {
        defines += [ "_MIPS_ARCH_LOONGSON" ]
        cflags += [
          "-march=loongson3a",
          "-mno-branch-likely",
          "-Wa,-march=loongson3a",
        ]
      }
    } else if (current_cpu == "mips64") {
      ldflags += [ "-Wl,--hash-style=sysv" ]
      if (custom_toolchain == "") {
        if (is_clang) {
          cflags += [ "--target=mips64-linux-gnuabi64" ]
          ldflags += [ "--target=mips64-linux-gnuabi64" ]
        } else {
          cflags += [
            "-EB",
            "-mabi=64",
          ]
          ldflags += [
            "-EB",
            "-mabi=64",
          ]
        }
      }

      if (mips_arch_variant == "r6") {
        cflags += [
          "-mips64r6",
          "-Wa,-mips64r6",
        ]
        ldflags += [ "-mips64r6" ]

        if (mips_use_msa == true) {
          cflags += [
            "-mmsa",
            "-mfp64",
          ]
        }
      } else if (mips_arch_variant == "r2") {
        cflags += [
          "-mips64r2",
          "-Wa,-mips64r2",
        ]
        ldflags += [ "-mips64r2" ]
      }
    } else if (current_cpu == "ppc64") {
      if (current_os == "aix") {
        cflags += [ "-maix64" ]
        ldflags += [ "-maix64" ]
      } else {
        cflags += [ "-m64" ]
        ldflags += [ "-m64" ]
      }
    } else if (current_cpu == "riscv64") {
      if (is_clang && !is_android) {
        cflags += [ "--target=riscv64-linux-gnu" ]
        ldflags += [ "--target=riscv64-linux-gnu" ]
      }
      cflags += [ "-mabi=lp64d" ]
    } else if (current_cpu == "loong64") {
      if (is_clang) {
        cflags += [ "--target=loongarch64-linux-gnu" ]
        ldflags += [ "--target=loongarch64-linux-gnu" ]
      }
      cflags += [
        "-mabi=lp64d",
        "-mcmodel=medium",
      ]
    } else if (current_cpu == "s390x") {
      cflags += [ "-m64" ]
      ldflags += [ "-m64" ]
    }
  }

  asmflags = cflags
}

# This provides options to tweak code generation that are necessary
# for particular Chromium code or for working around particular
# compiler bugs (or the combination of the two).
config("compiler_codegen") {
  configs = []
  cflags = []
  ldflags = []

  if (is_nacl) {
    configs += [ "//build/config/nacl:compiler_codegen" ]
  }

  if (current_cpu == "arm64" && !is_win && is_clang) {
    # Disable outlining everywhere on arm64 except Win. For more information see
    # crbug.com/931297 for Android and crbug.com/1410297 for iOS.
    # TODO(crbug.com/40890229): Enable this on Windows if possible.
    cflags += [ "-mno-outline" ]

    # This can be removed once https://bugs.llvm.org/show_bug.cgi?id=40348
    # has been resolved, and -mno-outline is obeyed by the linker during
    # ThinLTO.
    ldflags += [ "-Wl,-mllvm,-enable-machine-outliner=never" ]
  }

  asmflags = cflags
}

# This provides options that make the build deterministic, so that the same
# revision produces the same output, independent of the name of the build
# directory and of the computer the build is done on.
# The relative path from build dir to source dir makes it into the build
# outputs, so it's recommended that you use a build dir two levels deep
# (e.g. "out/Release") so that you get the same "../.." path as all the bots
# in your build outputs.
config("compiler_deterministic") {
  cflags = []
  ldflags = []
  swiftflags = []

  # Eliminate build metadata (__DATE__, __TIME__ and __TIMESTAMP__) for
  # deterministic build.  See https://crbug.com/314403
  if (!is_official_build) {
    if (is_win && !is_clang) {
      cflags += [
        "/wd4117",  # Trying to define or undefine a predefined macro.
        "/D__DATE__=",
        "/D__TIME__=",
        "/D__TIMESTAMP__=",
      ]
    } else {
      cflags += [
        "-Wno-builtin-macro-redefined",
        "-D__DATE__=",
        "-D__TIME__=",
        "-D__TIMESTAMP__=",
      ]
    }
  }

  # Makes builds independent of absolute file path.
  if (is_clang && strip_absolute_paths_from_debug_symbols) {
    # If debug option is given, clang includes $cwd in debug info by default.
    # For such build, this flag generates reproducible obj files even we use
    # different build directory like "out/feature_a" and "out/feature_b" if
    # we build same files with same compile flag.
    # Other paths are already given in relative, no need to normalize them.
    if (is_nacl) {
      # TODO(https://crbug.com/1231236): Use -ffile-compilation-dir= here.
      cflags += [
        "-Xclang",
        "-fdebug-compilation-dir",
        "-Xclang",
        ".",
      ]
    } else {
      # -ffile-compilation-dir is an alias for both -fdebug-compilation-dir=
      # and -fcoverage-compilation-dir=.
      cflags += [ "-ffile-compilation-dir=." ]

      # Convert absolute paths to relative paths. Expands to, for example:
      #   -file-prefix-map /path/to/chromium/src=../..
      swiftflags += [
        "-file-prefix-map",
        rebase_path("//.", "") + "=" + rebase_path("//.", root_build_dir),
      ]
    }
    if (!is_win) {
      # We don't use clang -cc1as on Windows (yet? https://crbug.com/762167)
      asmflags = [ "-Wa,-fdebug-compilation-dir,." ]
    }

    if (is_win && use_lld) {
      if (symbol_level == 2 || (is_clang && using_sanitizer)) {
        # Absolutize source file paths for PDB. Pass the real build directory
        # if the pdb contains source-level debug information and if linker
        # reproducibility is not critical.
        ldflags += [ "/PDBSourcePath:" + rebase_path(root_build_dir) ]
      } else {
        # Use a fake fixed base directory for paths in the pdb to make the pdb
        # output fully deterministic and independent of the build directory.
        ldflags += [ "/PDBSourcePath:o:\fake\prefix" ]
      }
    }
  }

  # Tells the compiler not to use absolute paths when passing the default
  # paths to the tools it invokes. We don't want this because we don't
  # really need it and it can mess up the RBE cache entries.
  if (is_clang && (!is_nacl || is_nacl_saigo)) {
    cflags += [ "-no-canonical-prefixes" ]

    # Same for links: Let the compiler driver invoke the linker
    # with a relative path and pass relative paths to built-in
    # libraries. Not needed on Windows because we call the linker
    # directly there, not through the compiler driver.
    # We don't link on RBE, so this change is just for cleaner
    # internal linker invocations, for people who work on the build.
    if (!is_win) {
      ldflags += [ "-no-canonical-prefixes" ]
    }
  }
}

config("clang_revision") {
  if (is_clang && clang_base_path == default_clang_base_path &&
      current_os != "zos") {
    update_args = [
      "--print-revision",
      "--verify-version=$clang_version",
    ]
    if (llvm_force_head_revision) {
      update_args += [ "--llvm-force-head-revision" ]
    }
    clang_revision = exec_script("//tools/clang/scripts/update.py",
                                 update_args,
                                 "trim string")

    # This is here so that all files get recompiled after a clang roll and
    # when turning clang on or off. (defines are passed via the command line,
    # and build system rebuild things when their commandline changes). Nothing
    # should ever read this define.
    defines = [ "CR_CLANG_REVISION=\"$clang_revision\"" ]
  }
}

config("rustc_revision") {
  if (rustc_revision != "") {
    # Similar to the above config, this is here so that all files get recompiled
    # after a rustc roll. Nothing should ever read this cfg. This will not be
    # set if a custom toolchain is used.
    rustflags = [
      "--cfg",
      "cr_rustc_revision=\"$rustc_revision\"",
    ]
  }
}

config("compiler_arm_fpu") {
  if (current_cpu == "arm" && !is_ios && !is_nacl) {
    cflags = [ "-mfpu=$arm_fpu" ]
    if (!arm_use_thumb) {
      cflags += [ "-marm" ]
    }
    asmflags = cflags
  }
}

config("compiler_arm_thumb") {
  if (current_cpu == "arm" && arm_use_thumb && is_posix &&
      !(is_apple || is_nacl)) {
    cflags = [ "-mthumb" ]
  }
}

config("compiler_arm") {
  if (current_cpu == "arm" && is_chromeos) {
    # arm is normally the default mode for clang, but on chromeos a wrapper
    # is used to pass -mthumb, and therefor change the default.
    cflags = [ "-marm" ]
  }
}

config("libcxx_module") {
  if (use_libcxx_modules) {
    modulemap = rebase_path("//third_party/libc++/src/include/module.modulemap",
                            root_build_dir)
    cflags_cc = [
      "-fmodules",
      "-fmodule-map-file=" + modulemap,
      "-fno-implicit-module-maps",
      "-fbuiltin-module-map",
      "-fmodules-cache-path=" +
          rebase_path("$libcxx_module_prefix/module_cache", root_build_dir),

      "-Xclang",
      "-fmodules-local-submodule-visibility",  # required for builtins

      # TODO(crbug.com/1456385): Figure out if this can be removed.
      "-Wno-modules-ambiguous-internal-linkage",

      # TODO(crbug.com/40440396): Clean up.
      "-Wno-modules-import-nested-redundant",

      # Needed to allow using builtin modules when the headers are
      # unnecessarily using extern "C".
      "-Wno-module-import-in-extern-c",
    ]
  }
}

# runtime_library -------------------------------------------------------------
#
# Sets the runtime library and associated options.
#
# How do you determine what should go in here vs. "compiler" above? Consider if
# a target might choose to use a different runtime library (ignore for a moment
# if this is possible or reasonable on your system). If such a target would want
# to change or remove your option, put it in the runtime_library config. If a
# target wants the option regardless, put it in the compiler config.

config("runtime_library") {
  configs = []

  # The order of this config is important: it must appear before
  # android:runtime_library.  This is to ensure libc++ appears before
  # libandroid_support in the -isystem include order.  Otherwise, there will be
  # build errors related to symbols declared in math.h.
  if (use_custom_libcxx) {
    configs += [ "//build/config/c++:runtime_library" ]
  }

  # Rust and C++ both provide intrinsics for LLVM to call for math operations. We
  # want to use the C++ intrinsics, not the ones in the Rust compiler_builtins
  # library. The Rust symbols are marked as weak, so that they can be replaced by
  # the C++ symbols. This config ensures the C++ symbols exist and are strong in
  # order to cause that replacement to occur by explicitly linking in clang's
  # compiler-rt library.
  if (is_clang && !is_nacl && !is_cronet_build) {
    configs += [ "//build/config/clang:compiler_builtins" ]
  }

  # TODO(crbug.com/40570904): Come up with a better name for is POSIX + Fuchsia
  # configuration.
  if (is_posix || is_fuchsia) {
    configs += [ "//build/config/posix:runtime_library" ]

    if (use_custom_libunwind) {
      # Instead of using an unwind lib from the toolchain,
      # buildtools/third_party/libunwind will be built and used directly.
      ldflags = [ "--unwindlib=none" ]
    }
  }

  # System-specific flags. If your compiler flags apply to one of the
  # categories here, add it to the associated file to keep this shared config
  # smaller.
  if (is_win) {
    configs += [ "//build/config/win:runtime_library" ]
  } else if (is_linux || is_chromeos) {
    configs += [ "//build/config/linux:runtime_library" ]
    if (is_chromeos) {
      configs += [ "//build/config/chromeos:runtime_library" ]
    }
  } else if (is_ios) {
    configs += [ "//build/config/ios:runtime_library" ]
  } else if (is_mac) {
    configs += [ "//build/config/mac:runtime_library" ]
  } else if (is_android) {
    configs += [ "//build/config/android:runtime_library" ]
  }

  if (is_component_build) {
    defines = [ "COMPONENT_BUILD" ]
  }
}

# treat_warnings_as_errors ----------------------------------------------------
#
# Adding this config causes the compiler to treat warnings as fatal errors.
# This is used as a subconfig of both chromium_code and no_chromium_code, and
# is broken out separately so nocompile tests can force-enable this setting
# independently of the default warning flags.
config("treat_warnings_as_errors") {
  if (is_win) {
    cflags = [ "/WX" ]
  } else {
    cflags = [ "-Werror" ]

    # The compiler driver can sometimes (rarely) emit warnings before calling
    # the actual linker.  Make sure these warnings are treated as errors as
    # well.
    ldflags = [ "-Werror" ]
  }

  # Turn rustc warnings into the "deny" lint level, which produce compiler
  # errors. The equivalent of -Werror for clang/gcc.
  #
  # Note we apply the actual lint flags in config("compiler"). All warnings
  # are suppressed in third-party crates.
  rustflags = [ "-Dwarnings" ]
}

# default_warnings ------------------------------------------------------------
#
# Collects all warning flags that are used by default.  This is used as a
# subconfig of both chromium_code and no_chromium_code.  This way these
# flags are guaranteed to appear on the compile command line after -Wall.
config("default_warnings") {
  cflags = []
  cflags_c = []
  cflags_cc = []
  ldflags = []
  configs = []

  if (is_win) {
    if (fatal_linker_warnings) {
      arflags = [ "/WX" ]
      ldflags = [ "/WX" ]
    }
    defines = [
      # Without this, Windows headers warn that functions like wcsnicmp
      # should be spelled _wcsnicmp. But all other platforms keep spelling
      # it wcsnicmp, making this warning unhelpful. We don't want it.
      "_CRT_NONSTDC_NO_WARNINGS",

      # TODO(thakis): winsock wants us to use getaddrinfo instead of
      # gethostbyname. Fires mostly in non-Chromium code. We probably
      # want to remove this define eventually.
      "_WINSOCK_DEPRECATED_NO_WARNINGS",
    ]
    if (!is_clang) {
      # TODO(thakis): Remove this once
      # https://swiftshader-review.googlesource.com/c/SwiftShader/+/57968 has
      # rolled into angle.
      cflags += [ "/wd4244" ]
    }
  } else {
    if ((is_apple || is_android) && !is_nacl) {
      # Warns if a method is used whose availability is newer than the
      # deployment target.
      cflags += [ "-Wunguarded-availability" ]
    }

    if (is_ios) {
      # When compiling Objective-C, warns if a selector named via @selector has
      # not been defined in any visible interface.
      cflags += [ "-Wundeclared-selector" ]

      # Blink builds use a higher deployment target than non-Blink builds, so
      # suppress deprecation warnings in these builds.
      if (use_blink) {
        cflags += [ "-Wno-deprecated-declarations" ]
      }
    }

    # Suppress warnings about ABI changes on ARM (Clang doesn't give this
    # warning).
    if (current_cpu == "arm" && !is_clang) {
      cflags += [ "-Wno-psabi" ]
    }

    if (!is_clang) {
      cflags_cc += [
        # See comment for -Wno-c++11-narrowing.
        "-Wno-narrowing",
      ]

      # -Wno-class-memaccess warns about hash table and vector in blink.
      # But the violation is intentional.
      if (!is_nacl) {
        cflags_cc += [ "-Wno-class-memaccess" ]
      }

      # -Wunused-local-typedefs is broken in gcc,
      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63872
      cflags += [ "-Wno-unused-local-typedefs" ]

      # Don't warn about "maybe" uninitialized. Clang doesn't include this
      # in -Wall but gcc does, and it gives false positives.
      cflags += [ "-Wno-maybe-uninitialized" ]
      cflags += [ "-Wno-deprecated-declarations" ]

      # -Wcomment gives too many false positives in the case a
      # backslash ended comment line is followed by a new line of
      # comments
      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61638
      cflags += [ "-Wno-comments" ]

      # -Wpacked-not-aligned complains all generated mojom-shared-internal.h
      # files.
      cflags += [ "-Wno-packed-not-aligned" ]
    }
  }

  # Common Clang and GCC warning setup.
  if (!is_win || is_clang) {
    cflags += [
      # Disables.
      "-Wno-missing-field-initializers",  # "struct foo f = {0};"
      "-Wno-unused-parameter",  # Unused function parameters.
    ]

    cflags_cc += [
      # Disables for C++ only
      "-Wno-invalid-offsetof",  # offsetof on non-standard-layout type
                                # (crbug.com/40285259)
    ]

    if (!is_nacl || is_nacl_saigo) {
      cflags += [
        # An ABI compat warning we don't care about, https://crbug.com/1102157
        # TODO(thakis): Push this to the (few) targets that need it,
        # instead of having a global flag.
        "-Wno-psabi",
      ]
    }
  }

  if (is_clang) {
    cflags += [
      "-Wloop-analysis",

      # TODO(thakis): This used to be implied by -Wno-unused-function,
      # which we no longer use. Check if it makes sense to remove
      # this as well. http://crbug.com/316352
      "-Wno-unneeded-internal-declaration",
    ]

    if (!is_nacl || is_nacl_saigo) {
      if (is_win) {
        # TODO(thakis): https://crbug.com/617318
        # Currently RBE can not handle case sensitiveness for windows well.
        cflags += [ "-Wno-nonportable-include-path" ]
      }

      if (is_fuchsia) {
        cflags_cc += [
          # TODO(crbug.com/42050603): fix and reenable
          "-Wno-missing-field-initializers",
        ]
      }

      cflags += [
        # TODO(crbug.com/330524456): -Wcast-function-type is under -Wextra now.
        "-Wno-cast-function-type",

        # TODO(crbug.com/40284799): Fix and re-enable.
        "-Wno-thread-safety-reference-return",
      ]

      cflags_cc += [
        # TODO(crbug.com/328490295): Fix and re-enable for C flags.
        "-Wenum-compare-conditional",
      ]

      if (!is_nacl) {
        cflags_cc += [
          # TODO(crbug.com/41486292): Fix and re-enable.
          "-Wno-c++11-narrowing-const-reference",
        ]

        # TODO(crbug.com/344680447): Fix and re-enable.
        cflags_cc += [ "-Wno-missing-template-arg-list-after-template-kw" ]

        # TODO(crbug.com/376641662): Fix and re-enable.
        cflags += [ "-Wno-nontrivial-memcall" ]
      }
    }

    # Some builders, such as Cronet, use a different version of Clang than
    # Chromium. This can cause minor errors when compiling Chromium changes. We
    # want to avoid these errors.
    if (llvm_android_mainline) {
      cflags += [
        "-Wno-error=unknown-warning-option",
        "-Wno-error=unused-command-line-argument",
        "-Wno-error=unknown-pragmas",
      ]
    }
  }

  # TODO(crbug.com/354162568): Clean up and enable.
  if (is_apple && use_lld) {
    ldflags += [ "-Wl,--no-warn-duplicate-rpath" ]
  }

  # TODO(crbug.com/355446806): Clean up and enable.
  if (is_apple) {
    ldflags += [ "-Wl,-no_warn_duplicate_libraries" ]
  }

  # Rust warnings

  # Require `unsafe` blocks even in `unsafe` fns. This is intended to become
  # an error by default eventually; see
  # https://github.com/rust-lang/rust/issues/71668
  rustflags = [ "-Dunsafe_op_in_unsafe_fn" ]
}

# prevent_unsafe_narrowing ----------------------------------------------------
#
# Warnings that prevent narrowing or comparisons of integer types that are
# likely to cause out-of-bound read/writes or Undefined Behaviour. In
# particular, size_t is used for memory sizes, allocation, indexing, and
# offsets. Using other integer types along with size_t produces risk of
# memory-safety bugs and thus security exploits.
#
# In order to prevent these bugs, allocation sizes were historically limited to
# sizes that can be represented within 31 bits of information, allowing `int` to
# be safely misused instead of `size_t` (https://crbug.com/169327). In order to
# support increasing the allocation limit we require strictly adherence to
# using the correct types, avoiding lossy conversions, and preventing overflow.
# To do so, enable this config and fix errors by converting types to be
# `size_t`, which is both large enough and unsigned, when dealing with memory
# sizes, allocations, indices, or offsets.In cases where type conversion is not
# possible or is superfluous, use base::strict_cast<> or base::checked_cast<>
# to convert to size_t as needed.
# See also: https://docs.google.com/document/d/1CTbQ-5cQjnjU8aCOtLiA7G6P0i5C6HpSDNlSNq6nl5E
#
# To enable in a GN target, use:
#   configs += [ "//build/config/compiler:prevent_unsafe_narrowing" ]

config("prevent_unsafe_narrowing") {
  if (is_clang) {
    cflags = [
      "-Wshorten-64-to-32",
      "-Wimplicit-int-conversion",
      "-Wsign-compare",
      "-Wsign-conversion",
    ]
    if (!is_nacl) {
      cflags += [
        # Avoid bugs of the form `if (size_t i = size; i >= 0; --i)` while
        # fixing types to be sign-correct.
        "-Wtautological-unsigned-zero-compare",
      ]
    }
  }
}

# chromium_code ---------------------------------------------------------------
#
# Toggles between higher and lower warnings for code that is (or isn't)
# part of Chromium.

config("chromium_code") {
  if (is_win) {
    if (is_clang) {
      cflags = [ "/W4" ]  # Warning level 4.

      # Opt in to additional [[nodiscard]] on standard library methods.
      defines = [ "_HAS_NODISCARD" ]
    }
  } else {
    cflags = [ "-Wall" ]
    if (is_clang) {
      # Enable extra warnings for chromium_code when we control the compiler.
      cflags += [ "-Wextra" ]
    }

    # In Chromium code, we define __STDC_foo_MACROS in order to get the
    # C99 macros on Mac and Linux.
    defines = [
      "__STDC_CONSTANT_MACROS",
      "__STDC_FORMAT_MACROS",
    ]

    if (!is_debug && !using_sanitizer && current_cpu != "s390x" &&
        current_cpu != "s390" && current_cpu != "ppc64" &&
        current_cpu != "mips" && current_cpu != "mips64" &&
        current_cpu != "riscv64" && current_cpu != "loong64") {
      # Non-chromium code is not guaranteed to compile cleanly with
      # _FORTIFY_SOURCE. Also, fortified build may fail when optimizations are
      # disabled, so only do that for Release build.
      fortify_level = "2"

      # ChromeOS's toolchain supports a high-quality _FORTIFY_SOURCE=3
      # implementation with a few custom glibc patches. Use that if it's
      # available.
      if (is_chromeos_device && !lacros_use_chromium_toolchain) {
        fortify_level = "3"
      }
      defines += [ "_FORTIFY_SOURCE=" + fortify_level ]
    }

    if (is_apple) {
      cflags_objc = [ "-Wimplicit-retain-self" ]
      cflags_objcc = [ "-Wimplicit-retain-self" ]
    }

    if (is_mac) {
      cflags_objc += [ "-Wobjc-missing-property-synthesis" ]
      cflags_objcc += [ "-Wobjc-missing-property-synthesis" ]
    }

    if (is_ios) {
      cflags_objc += [ "-Widiomatic-parentheses" ]
      cflags_objcc += [ "-Widiomatic-parentheses" ]
    }
  }

  if (is_clang) {
    cflags += [
      # Warn on missing break statements at the end of switch cases.
      # For intentional fallthrough, use [[fallthrough]].
      "-Wimplicit-fallthrough",

      # Warn on unnecessary extra semicolons outside of function definitions.
      "-Wextra-semi",

      # Warn on unreachable code, including unreachable breaks and returns.
      # See https://crbug.com/346399#c148 for suppression strategies.
      "-Wunreachable-code-aggressive",
    ]

    # Thread safety analysis is broken under nacl: https://crbug.com/982423.
    if (!is_nacl || is_nacl_saigo) {
      cflags += [
        # Thread safety analysis. See base/thread_annotations.h and
        # https://clang.llvm.org/docs/ThreadSafetyAnalysis.html
        "-Wthread-safety",

        # Warn on GNU extensions.
        "-Wgnu",

        # TODO(crbug.com/357081796): Try to enable these.
        "-Wno-gnu-anonymous-struct",
        "-Wno-gnu-conditional-omitted-operand",
        "-Wno-gnu-include-next",
        "-Wno-gnu-label-as-value",
        "-Wno-gnu-redeclared-enum",
        "-Wno-gnu-statement-expression",
        "-Wno-gnu-zero-variadic-macro-arguments",
        "-Wno-zero-length-array",
      ]

      if (is_chromeos) {
        cflags += [ "-Wno-gnu-offsetof-extensions" ]
      }
      if (is_ios) {
        cflags += [ "-Wno-gnu-case-range" ]
      }
    }
  }

  configs = [
    ":default_warnings",
    ":noshadowing",
  ]
  if (treat_warnings_as_errors) {
    configs += [ ":treat_warnings_as_errors" ]
  }
}

config("no_chromium_code") {
  cflags = []
  cflags_cc = []
  defines = []

  if (is_win) {
    if (is_clang) {
      cflags += [ "/W3" ]  # Warning level 3.
    }
    cflags += [
      "/wd4800",  # Disable warning when forcing value to bool.
      "/wd4267",  # TODO(jschuh): size_t to int.
    ]
  } else {
    if (is_clang && !is_nacl) {
      # TODO(thakis): Remove !is_nacl once
      # https://codereview.webrtc.org/1552863002/ made its way into chromium.
      cflags += [ "-Wall" ]
    }
  }

  if (is_clang) {
    cflags += [
      # Lots of third-party libraries have unused variables. Instead of
      # suppressing them individually, we just blanket suppress them here.
      "-Wno-unused-variable",

      # Similarly, we're not going to fix all the C++11 narrowing issues in
      # third-party libraries.
      "-Wno-c++11-narrowing",
    ]
    if (!is_nacl) {
      cflags += [
        # Disabled for similar reasons as -Wunused-variable.
        "-Wno-unused-but-set-variable",

        # TODO(crbug.com/40762742): Clean up and enable.
        "-Wno-misleading-indentation",
      ]
    }
  }

  configs = [ ":default_warnings" ]

  # GCC may emit unsuppressible warnings so only apply this config when
  # building with clang. crbug.com/589724
  if (treat_warnings_as_errors && is_clang) {
    configs += [ ":treat_warnings_as_errors" ]
  }
}

# noshadowing -----------------------------------------------------------------
#
# Allows turning -Wshadow on.

config("noshadowing") {
  # This flag has to be disabled for nacl because the nacl compiler is too
  # strict about shadowing.
  if (is_clang && (!is_nacl || is_nacl_saigo)) {
    cflags = [ "-Wshadow" ]
  }
}

# rtti ------------------------------------------------------------------------
#
# Allows turning Run-Time Type Identification on or off.

config("rtti") {
  if (is_win) {
    cflags_cc = [ "/GR" ]
  } else {
    cflags_cc = [ "-frtti" ]
  }
}

config("no_rtti") {
  # Some sanitizer configs may require RTTI to be left enabled globally
  if (!use_rtti) {
    if (is_win) {
      cflags_cc = [ "/GR-" ]
    } else {
      cflags_cc = [ "-fno-rtti" ]
      cflags_objcc = cflags_cc
    }
  }
}

# export_dynamic ---------------------------------------------------------------
#
# Ensures all exported symbols are added to the dynamic symbol table.  This is
# necessary to expose Chrome's custom operator new() and operator delete() (and
# other memory-related symbols) to libraries.  Otherwise, they might
# (de)allocate memory on a different heap, which would spell trouble if pointers
# to heap-allocated memory are passed over shared library boundaries.
config("export_dynamic") {
  # TODO(crbug.com/40118868): Revisit after target_os flip is completed.
  if (is_linux || is_chromeos_lacros || export_libcxxabi_from_executables) {
    ldflags = [ "-rdynamic" ]
  }
}

# thin_archive -----------------------------------------------------------------
#
# Enables thin archives on posix, and on windows when the lld linker is used.
# Regular archives directly include the object files used to generate it.
# Thin archives merely reference the object files.
# This makes building them faster since it requires less disk IO, but is
# inappropriate if you wish to redistribute your static library.
# This config is added to the global config, so thin archives should already be
# enabled.  If you want to make a distributable static library, you need to do 2
# things:
# 1. Set complete_static_lib so that all dependencies of the library make it
#    into the library. See `gn help complete_static_lib` for details.
# 2. Remove the thin_archive config, so that the .a file actually contains all
#    .o files, instead of just references to .o files in the build directoy
config("thin_archive") {
  if ((is_apple && use_lld) || (is_linux && !is_clang)) {
    # The macOS and iOS linker ld64.ldd doesn't support thin archive without
    # symbol table, gcc on linux also throws the error `archive has no index`.
    arflags = [
      "-T",
      "-s",
    ]
  } else if ((is_posix && !is_nacl && (!is_apple || use_lld)) || is_fuchsia) {
    # The macOS and iOS default linker ld64 does not support reading thin
    # archives.
    arflags = [
      "-T",
      "-S",
    ]
  } else if (is_win && use_lld) {
    arflags = [ "/llvmlibthin" ]
  }
}

# exceptions -------------------------------------------------------------------
#
# Allows turning Exceptions on or off.
# Note: exceptions are disallowed in Google code.

config("exceptions") {
  if (is_win) {
    # Enables exceptions in the STL.
    if (!use_custom_libcxx) {
      defines = [ "_HAS_EXCEPTIONS=1" ]
    }
    cflags_cc = [ "/EHsc" ]
  } else {
    cflags_cc = [ "-fexceptions" ]
    cflags_objcc = cflags_cc
  }
}

config("no_exceptions") {
  if (is_win) {
    # Disables exceptions in the STL.
    # libc++ uses the __has_feature macro to control whether to use exceptions,
    # so defining this macro is unnecessary. Defining _HAS_EXCEPTIONS to 0 also
    # breaks libc++ because it depends on MSVC headers that only provide certain
    # declarations if _HAS_EXCEPTIONS is 1. Those MSVC headers do not use
    # exceptions, despite being conditional on _HAS_EXCEPTIONS.
    if (!use_custom_libcxx) {
      defines = [ "_HAS_EXCEPTIONS=0" ]
    }
  } else {
    cflags_cc = [ "-fno-exceptions" ]
    cflags_objcc = cflags_cc
  }
}

# Warnings ---------------------------------------------------------------------

# Generate a warning for code that might emit a static initializer.
# See: //docs/static_initializers.md
# See: https://groups.google.com/a/chromium.org/d/topic/chromium-dev/B9Q5KTD7iCo/discussion
config("wglobal_constructors") {
  if (is_clang) {
    cflags = [ "-Wglobal-constructors" ]
  }
}

# This will generate warnings when using Clang if code generates exit-time
# destructors, which will slow down closing the program.
# TODO(thakis): Make this a blocklist instead, http://crbug.com/101600
config("wexit_time_destructors") {
  if (is_clang) {
    cflags = [ "-Wexit-time-destructors" ]
  }
}

# Some code presumes that pointers to structures/objects are compatible
# regardless of whether what they point to is already known to be valid.
# gcc 4.9 and earlier had no way of suppressing this warning without
# suppressing the rest of them.  Here we centralize the identification of
# the gcc 4.9 toolchains.
config("no_incompatible_pointer_warnings") {
  cflags = []
  if (is_clang) {
    cflags += [ "-Wno-incompatible-pointer-types" ]
  } else if (current_cpu == "mipsel" || current_cpu == "mips64el") {
    cflags += [ "-w" ]
  } else if (is_chromeos_ash && current_cpu == "arm") {
    cflags += [ "-w" ]
  }
}

# Optimization -----------------------------------------------------------------
#
# The BUILDCONFIG file sets the "default_optimization" config on targets by
# default. It will be equivalent to either "optimize" (release) or
# "no_optimize" (debug) optimization configs.
#
# You can override the optimization level on a per-target basis by removing the
# default config and then adding the named one you want:
#
#   configs -= [ "//build/config/compiler:default_optimization" ]
#   configs += [ "//build/config/compiler:optimize_max" ]

# Shared settings for both "optimize" and "optimize_max" configs.
# IMPORTANT: On Windows "/O1" and "/O2" must go before the common flags.
if (is_win) {
  common_optimize_on_cflags = [
    "/Oy-",  # Disable omitting frame pointers, must be after /O2.
    "/Zc:inline",  # Remove unreferenced COMDAT (faster links).
  ]
  if (!is_asan) {
    common_optimize_on_cflags += [
      # Put data in separate COMDATs. This allows the linker
      # to put bit-identical constants at the same address even if
      # they're unrelated constants, which saves binary size.
      # This optimization can't be used when ASan is enabled because
      # it is not compatible with the ASan ODR checker.
      "/Gw",
    ]
  }
  common_optimize_on_ldflags = []

  # /OPT:ICF is not desirable in Debug builds, since code-folding can result in
  # misleading symbols in stack traces.
  if (!is_debug && !is_component_build) {
    common_optimize_on_ldflags += [ "/OPT:ICF" ]  # Redundant COMDAT folding.
  }

  if (is_official_build) {
    common_optimize_on_ldflags += [ "/OPT:REF" ]  # Remove unreferenced data.
  }

  if (is_clang) {
    # See below.
    common_optimize_on_cflags += [ "/clang:-fno-math-errno" ]
  }
} else {
  common_optimize_on_cflags = []
  common_optimize_on_ldflags = []

  if (is_android) {
    # TODO(jdduke) Re-enable on mips after resolving linking
    # issues with libc++ (crbug.com/456380).
    if (current_cpu != "mipsel" && current_cpu != "mips64el") {
      common_optimize_on_ldflags += [
        # Warn in case of text relocations.
        "-Wl,--warn-shared-textrel",
      ]
    }
  }

  if (is_apple) {
    common_optimize_on_ldflags += [ "-Wl,-dead_strip" ]

    if (is_official_build) {
      common_optimize_on_ldflags += [
        "-Wl,-no_data_in_code_info",
        "-Wl,-no_function_starts",
      ]
    }
  } else if (current_os != "aix" && current_os != "zos") {
    # Non-Mac Posix flags.
    # Aix does not support these.

    common_optimize_on_cflags += [
      # Put data and code in their own sections, so that unused symbols
      # can be removed at link time with --gc-sections.
      "-fdata-sections",
      "-ffunction-sections",
    ]
    if ((!is_nacl || is_nacl_saigo) && is_clang) {
      # We don't care about unique section names, this makes object files a bit
      # smaller.
      common_optimize_on_cflags += [ "-fno-unique-section-names" ]
    }

    if (is_official_build) {
      common_optimize_on_ldflags += [
        # Specifically tell the linker to perform optimizations.
        # See http://lwn.net/Articles/192624/.
        # -O2 enables string tail merge optimization in lld.
        "-Wl,-O2",
      ]
    }

    common_optimize_on_ldflags += [ "-Wl,--gc-sections" ]
  }

  # We cannot rely on errno being set after math functions,
  # especially since glibc does not set it. Thus, use -fno-math-errno
  # so that the compiler knows it can inline math functions.
  # Note that this is different from -ffast-math (even though -ffast-math
  # implies -fno-math-errno), which also allows a number of unsafe
  # optimizations.
  common_optimize_on_cflags += [ "-fno-math-errno" ]
}

config("default_stack_frames") {
  if (!is_win) {
    if (enable_frame_pointers) {
      cflags = [ "-fno-omit-frame-pointer" ]

      # Omit frame pointers for leaf functions on x86, otherwise building libyuv
      # gives clang's register allocator issues, see llvm.org/PR15798 /
      # crbug.com/233709
      if (is_clang && current_cpu == "x86" && !is_apple) {
        cflags += [ "-momit-leaf-frame-pointer" ]
      }
    } else {
      cflags = [ "-fomit-frame-pointer" ]
    }
  }
  # On Windows, the flag to enable framepointers "/Oy-" must always come after
  # the optimization flag [e.g. "/O2"]. The optimization flag is set by one of
  # the "optimize" configs, see rest of this file. The ordering that cflags are
  # applied is well-defined by the GN spec, and there is no way to ensure that
  # cflags set by "default_stack_frames" is applied after those set by an
  # "optimize" config. Similarly, there is no way to propagate state from this
  # config into the "optimize" config. We always apply the "/Oy-" config in the
  # definition for common_optimize_on_cflags definition, even though this may
  # not be correct.
}

# Default "optimization on" config.
#
# High-end Android: As of April 2024, `-O2` appears to be a good default,
# particularly since a selection of "hot" targets are already using `-O3`.
# Enabling `-O3` for all targets does not change performance much (according
# to Speedometer), but regresses binary size. Using `-O3` as the default:
#   - Decreases Speedometer 2.1 score by 0.2% [0].
#   - Increases Speedometer 3.0 score by 0.1% [1].
#   - Increases binary size by 1.47MB [2] (or 0.8%: the arm64 native code size
#     in M124 is 178MB).
# ... over `-O2`.
#
# [0]: https://pinpoint-dot-chromeperf.appspot.com/job/147634a8be0000
# [1]: https://pinpoint-dot-chromeperf.appspot.com/job/132bc772be0000
# [2]: https://crrev.com/c/5447532
config("optimize") {
  if (is_win) {
    # clang-cl's /O2 corresponds to clang's -O3, and really want -O2 for
    # consistency with the other platforms.
    cflags = [
               "/O2",
               "/clang:-O2",
             ] + common_optimize_on_cflags

    # The `-O3` for clang turns on extra optimizations compared to the standard
    # `-O2`. But for rust, `-Copt-level=3` is the default and is thus reliable
    # to use.
    rustflags = [ "-Copt-level=3" ]
  } else if (optimize_for_size || is_chromeos) {
    # Favor size over speed.
    # -Os in clang is more of a size-conscious -O2 than "size at any cost"
    # (AKA -Oz).

    if (is_fuchsia) {
      cflags = [ "-Oz" ] + common_optimize_on_cflags
    } else {
      cflags = [ "-Os" ] + common_optimize_on_cflags
    }

    if (is_clang && use_ml_inliner && is_a_target_toolchain && !is_chromeos &&
        !is_high_end_android) {
      cflags += [
        "-mllvm",
        "-enable-ml-inliner=release",
        "-mllvm",
        "-ml-inliner-model-selector=arm32-size",
      ]
    }

    # Similar to clang, we optimize with `-Copt-level=s` to keep loop
    # vectorization while otherwise optimizing for size.
    rustflags = [ "-Copt-level=s" ]
  } else {
    cflags = [ "-O2" ] + common_optimize_on_cflags

    # The `-O3` for clang turns on extra optimizations compared to the standard
    # `-O2`. But for rust, `-Copt-level=3` is the default and is thus reliable
    # to use.
    rustflags = [ "-Copt-level=3" ]
  }
  ldflags = common_optimize_on_ldflags
}

# Turn off optimizations.
config("no_optimize") {
  if (is_win) {
    cflags = [
      "/Od",  # Disable optimization.
      "/Ob0",  # Disable all inlining (on by default).
      "/GF",  # Enable string pooling (off by default).
    ]

    if (target_cpu == "arm64") {
      # Disable omitting frame pointers for no_optimize build because stack
      # traces on Windows ARM64 rely on it.
      cflags += [ "/Oy-" ]
    }
  } else if (is_android && !android_full_debug) {
    # On Android we kind of optimize some things that don't affect debugging
    # much even when optimization is disabled to get the binary size down.
    if (is_clang) {
      cflags = [ "-Oz" ] + common_optimize_on_cflags
    } else {
      cflags = [ "-Os" ] + common_optimize_on_cflags
    }

    if (!is_component_build) {
      # Required for library partitions. Without this all symbols just end up
      # in the base partition.
      ldflags = [ "-Wl,--gc-sections" ]
    }
  } else if (is_fuchsia) {
    # On Fuchsia, we optimize for size here to reduce the size of debug build
    # packages so they can be run in a KVM. See crbug.com/910243 for details.
    cflags = [ "-Og" ]
  } else {
    cflags = [ "-O0" ]
    ldflags = []
  }
}

# Turns up the optimization level. Used to explicitly enable -O2 instead of
# -Os for select targets on platforms that use optimize_for_size. No-op
# elsewhere.
config("optimize_max") {
  if (is_nacl && is_nacl_irt) {
    # The NaCl IRT is a special case and always wants its own config.
    # Various components do:
    #   if (!is_debug) {
    #     configs -= [ "//build/config/compiler:default_optimization" ]
    #     configs += [ "//build/config/compiler:optimize_max" ]
    #   }
    # So this config has to have the selection logic just like
    # "default_optimization", below.
    configs = [ "//build/config/nacl:irt_optimize" ]
  } else {
    ldflags = common_optimize_on_ldflags
    if (is_win) {
      # Favor speed over size, /O2 must be before the common flags.
      # /O2 implies /Ot, /Oi, and /GF.
      cflags = [ "/O2" ] + common_optimize_on_cflags
    } else if (optimize_for_fuzzing) {
      cflags = [ "-O1" ] + common_optimize_on_cflags
    } else {
      cflags = [ "-O2" ] + common_optimize_on_cflags
    }
    rustflags = [ "-Copt-level=3" ]
  }
}

# This config can be used to override the default settings for per-component
# and whole-program optimization, optimizing the particular target for speed
# instead of code size. This config is exactly the same as "optimize_max"
# except that we use -O3 instead of -O2 on non-IRT platforms.
#
# TODO(crbug.com/41259697) - rework how all of these configs are related
# so that we don't need this disclaimer.
config("optimize_speed") {
  if (is_nacl && is_nacl_irt) {
    # The NaCl IRT is a special case and always wants its own config.
    # Various components do:
    #   if (!is_debug) {
    #     configs -= [ "//build/config/compiler:default_optimization" ]
    #     configs += [ "//build/config/compiler:optimize_max" ]
    #   }
    # So this config has to have the selection logic just like
    # "default_optimization", below.
    configs = [ "//build/config/nacl:irt_optimize" ]
  } else {
    ldflags = common_optimize_on_ldflags
    if (is_win) {
      # Favor speed over size, /O2 must be before the common flags.
      # /O2 implies /Ot, /Oi, and /GF.
      cflags = [ "/O2" ] + common_optimize_on_cflags
      if (is_clang) {
        cflags += [ "/clang:-O3" ]
      }
    } else if (optimize_for_fuzzing) {
      cflags = [ "-O1" ] + common_optimize_on_cflags
    } else {
      cflags = [ "-O3" ] + common_optimize_on_cflags
    }
    rustflags = [ "-Copt-level=3" ]
  }
}

config("optimize_fuzzing") {
  cflags = [ "-O1" ] + common_optimize_on_cflags
  rustflags = [ "-Copt-level=1" ]
  ldflags = common_optimize_on_ldflags
  visibility = [ ":default_optimization" ]
}

# The default optimization applied to all targets. This will be equivalent to
# either "optimize" or "no_optimize", depending on the build flags.
config("default_optimization") {
  if (is_nacl && is_nacl_irt) {
    # The NaCl IRT is a special case and always wants its own config.
    # It gets optimized the same way regardless of the type of build.
    configs = [ "//build/config/nacl:irt_optimize" ]
  } else if (is_debug) {
    configs = [ ":no_optimize" ]
  } else if (optimize_for_fuzzing) {
    assert(!is_win, "Fuzzing optimize level not supported on Windows")

    # Coverage build is quite slow. Using "optimize_for_fuzzing" makes it even
    # slower as it uses "-O1" instead of "-O3". Prevent that from happening.
    assert(!use_clang_coverage,
           "optimize_for_fuzzing=true should not be used with " +
               "use_clang_coverage=true.")
    configs = [ ":optimize_fuzzing" ]
  } else {
    configs = [ ":optimize" ]
  }
}

_clang_sample_profile = ""
if (is_clang && is_a_target_toolchain) {
  if (clang_sample_profile_path != "") {
    _clang_sample_profile = clang_sample_profile_path
  } else if (clang_use_default_sample_profile) {
    assert(build_with_chromium,
           "Our default profiles currently only apply to Chromium")
    assert(is_android || is_chromeos || is_castos,
           "The current platform has no default profile")
    if (is_android || is_castos) {
      _clang_sample_profile = "//chrome/android/profiles/afdo.prof"
    } else {
      assert(chromeos_afdo_platform == "atom" ||
                 chromeos_afdo_platform == "bigcore" ||
                 chromeos_afdo_platform == "arm",
             "Only 'atom', 'bigcore', and 'arm' are valid ChromeOS profiles.")
      _clang_sample_profile =
          "//chromeos/profiles/${chromeos_afdo_platform}.afdo.prof"
    }
  }
}

# Clang offers a way to assert that AFDO profiles are accurate, which causes it
# to optimize functions not represented in a profile more aggressively for size.
# This config can be toggled in cases where shaving off binary size hurts
# performance too much.
config("afdo_optimize_size") {
  if (_clang_sample_profile != "" && sample_profile_is_accurate) {
    cflags = [ "-fprofile-sample-accurate" ]
  }
}

# GCC and clang support a form of profile-guided optimization called AFDO.
# There are some targeted places that AFDO regresses, so we provide a separate
# config to allow AFDO to be disabled per-target.
config("afdo") {
  if (is_clang) {
    cflags = []
    if (clang_emit_debug_info_for_profiling) {
      # Add the following flags to generate debug info for profiling.
      cflags += [ "-gline-tables-only" ]
      if (!is_nacl) {
        cflags += [ "-fdebug-info-for-profiling" ]
      }
    }
    if (_clang_sample_profile != "") {
      assert(chrome_pgo_phase == 0, "AFDO can't be used in PGO builds")
      rebased_clang_sample_profile =
          rebase_path(_clang_sample_profile, root_build_dir)
      cflags += [ "-fprofile-sample-use=${rebased_clang_sample_profile}" ]
      if (use_profi) {
        cflags += [ "-fsample-profile-use-profi" ]
      }

      # crbug.com/1459429: ARM builds see failures due to -Wbackend-plugin.
      # These seem to be false positives - the complaints are about functions
      # marked with `__nodebug__` not having associated debuginfo. In the case
      # where this was observed, the `__nodebug__` function was also marked
      # `__always_inline__` and had no branches, so AFDO info is likely useless
      # there.
      cflags += [ "-Wno-backend-plugin" ]
      inputs = [ _clang_sample_profile ]
    }
  } else if (auto_profile_path != "" && is_a_target_toolchain) {
    cflags = [ "-fauto-profile=${auto_profile_path}" ]
    inputs = [ auto_profile_path ]
  }
}

# Symbols ----------------------------------------------------------------------

# The BUILDCONFIG file sets the "default_symbols" config on targets by
# default. It will be equivalent to one the three specific symbol levels.
#
# You can override the symbol level on a per-target basis by removing the
# default config and then adding the named one you want:
#
#   configs -= [ "//build/config/compiler:default_symbols" ]
#   configs += [ "//build/config/compiler:symbols" ]

# A helper config that all configs passing /DEBUG to the linker should
# include as sub-config.
config("win_pdbaltpath") {
  visibility = [
    ":minimal_symbols",
    ":symbols",
  ]

  # /DEBUG causes the linker to generate a pdb file, and to write the absolute
  # path to it in the executable file it generates.  This flag turns that
  # absolute path into just the basename of the pdb file, which helps with
  # build reproducibility. Debuggers look for pdb files next to executables,
  # so there's minimal downside to always using this. However, post-mortem
  # debugging of Chromium crash dumps and ETW tracing can be complicated by this
  # switch so an option to omit it is important.
  if (!use_full_pdb_paths) {
    ldflags = [ "/pdbaltpath:%_PDB%" ]
  }
}

# Full symbols.
config("symbols") {
  rustflags = []
  configs = []
  if (is_win) {
    if (is_clang) {
      cflags = [
        # Debug information in the .obj files.
        "/Z7",

        # Disable putting the compiler command line into the debug info to
        # prevent some types of non-determinism.
        "-gno-codeview-command-line",
      ]
    } else {
      cflags = [ "/Zi" ]  # Produce PDB file, no edit and continue.
    }

    if (is_clang && use_lld && use_ghash) {
      cflags += [ "-gcodeview-ghash" ]
      ldflags = [ "/DEBUG:GHASH" ]
    } else {
      ldflags = [ "/DEBUG" ]
    }

    # All configs using /DEBUG should include this:
    configs += [ ":win_pdbaltpath" ]
  } else {
    cflags = []
    if (is_mac && enable_dsyms) {
      # If generating dSYMs, specify -fno-standalone-debug. This was
      # originally specified for https://crbug.com/479841 because dsymutil
      # could not handle a 4GB dSYM file. But dsymutil from Xcodes prior to
      # version 7 also produces debug data that is incompatible with Breakpad
      # dump_syms, so this is still required (https://crbug.com/622406).
      cflags += [ "-fno-standalone-debug" ]
    }

    # On aix -gdwarf causes linker failures due to thread_local variables.
    # On zos -gdwarf causes INSUFFICIENT ABOVE THE LINE STORAGE WAS AVAILABLE.
    if (!is_nacl && current_os != "aix" && current_os != "zos") {
      if (use_dwarf5) {
        cflags += [ "-gdwarf-5" ]
        rustflags += [ "-Zdwarf-version=5" ]
      } else {
        # Recent clang versions default to DWARF5 on Linux, and Android is about
        # to switch. TODO: Adopt that in controlled way. For now, keep DWARF4.
        # Apple platforms still default to 4 in clang, so they don't need the
        # cflags.
        if (!is_apple) {
          cflags += [ "-gdwarf-4" ]
        }

        # On Apple, rustc defaults to DWARF2 so it needs to be told how to
        # match clang.
        rustflags += [ "-Zdwarf-version=4" ]
      }
    }

    # The gcc-based nacl compilers don't support -fdebug-compilation-dir (see
    # elsewhere in this file), so they can't have build-dir-independent output.
    # Moreover pnacl does not support newer flags such as -fdebug-prefix-map
    # Disable symbols for nacl object files to get deterministic,
    # build-directory-independent output.
    # Keeping -g2 for saigo as it's the only toolchain whose artifacts that are
    # part of chromium release (other nacl toolchains are used only for tests).
    if ((!is_nacl || is_nacl_saigo) && current_os != "zos") {
      cflags += [ "-g2" ]
    }

    if (!is_nacl && is_clang && !is_tsan && !is_asan) {
      # gcc generates dwarf-aranges by default on -g1 and -g2. On clang it has
      # to be manually enabled.
      #
      # It is skipped in tsan and asan because enabling it causes some
      # formatting changes in the output which would require fixing bunches
      # of expectation regexps.
      cflags += [ "-gdwarf-aranges" ]
    }

    if (is_apple) {
      swiftflags = [ "-g" ]
    }

    if (use_debug_fission) {
      cflags += [ "-gsplit-dwarf" ]
    }
    asmflags = cflags
    ldflags = []

    # Split debug info with all thinlto builds except nacl and apple.
    # thinlto requires -gsplit-dwarf in ldflags.
    if (use_debug_fission && use_thin_lto && !is_nacl && !is_apple) {
      ldflags += [ "-gsplit-dwarf" ]
    }

    # TODO(thakis): Figure out if there's a way to make this go for 32-bit,
    # currently we get "warning:
    # obj/native_client/src/trusted/service_runtime/sel_asm/nacl_switch_32.o:
    # DWARF info may be corrupt; offsets in a range list entry are in different
    # sections" there.  Maybe just a bug in nacl_switch_32.S.
    _enable_gdb_index =
        symbol_level == 2 && !is_apple && !is_nacl && current_cpu != "x86" &&
        current_os != "zos" && use_lld &&
        # Disable on non-fission 32-bit Android because it pushes
        # libcomponents_unittests over the 4gb size limit.
        !(is_android && !use_debug_fission && current_cpu != "x64" &&
          current_cpu != "arm64")
    if (_enable_gdb_index) {
      if (is_clang) {
        # This flag enables the GNU-format pubnames and pubtypes sections,
        # which lld needs in order to generate a correct GDB index.
        # TODO(pcc): Try to make lld understand non-GNU-format pubnames
        # sections (llvm.org/PR34820).
        cflags += [ "-ggnu-pubnames" ]
      }
      ldflags += [ "-Wl,--gdb-index" ]
    }
  }

  # Compress debug on 32-bit ARM to stay under 4GB file size limit.
  # https://b/243982712, https://crbug.com/1354616, https://crbug.com/334073642
  if (symbol_level == 2 && !use_debug_fission && !is_nacl && !is_win &&
      (current_cpu == "arm" || current_cpu == "x86")) {
    configs += [ "//build/config:compress_debug_sections" ]
  }

  if (is_clang && !is_nacl && is_win && !is_component_build) {
    # Remove unreferenced methods to reduce type info in symbols.
    # See: https://github.com/llvm/llvm-project/pull/87018.
    # The downside with this flag is precisely that: Unreferenced methods get
    # removed, so that methods only to be used from within a debugger become
    # unavailable. Therefore, only do this for Windows, which seems to be the
    # only platform that needs this, due to size limitations in PDF files.
    # Additionally, this limitation is only likely to be hit in non-component
    # builds, so only do it then.
    # See crbug.com/338094922
    cflags += [ "-gomit-unreferenced-methods" ]
  }

  if (is_clang && (!is_nacl || is_nacl_saigo)) {
    if (is_apple) {
      # TODO(crbug.com/40117949): Investigate missing debug info on mac.
      # Make sure we don't use constructor homing on mac.
      cflags += [
        "-Xclang",
        "-debug-info-kind=limited",
      ]
    } else {
      # Use constructor homing for debug info. This option reduces debug info
      # by emitting class type info only when constructors are emitted.
      cflags += [
        "-Xclang",
        "-fuse-ctor-homing",
      ]
    }
  }
  rustflags += [ "-g" ]
}

# Minimal symbols.
# This config guarantees to hold symbol for stack trace which are shown to user
# when crash happens in unittests running on buildbot.
config("minimal_symbols") {
  rustflags = []
  if (is_win) {
    # Functions, files, and line tables only.
    cflags = []

    if (is_clang) {
      cflags += [
        # Disable putting the compiler command line into the debug info to
        # prevent some types of non-determinism.
        "-gno-codeview-command-line",
      ]
    }
    if (is_clang && use_lld && use_ghash) {
      cflags += [ "-gcodeview-ghash" ]
      ldflags = [ "/DEBUG:GHASH" ]
    } else {
      ldflags = [ "/DEBUG" ]
    }

    # All configs using /DEBUG should include this:
    configs = [ ":win_pdbaltpath" ]

    # Enable line tables for clang. MSVC doesn't have an equivalent option.
    if (is_clang) {
      # -gline-tables-only is the same as -g1, but clang-cl only exposes the
      # former.
      cflags += [ "-gline-tables-only" ]
    }
  } else {
    cflags = []
    if (is_mac && !use_dwarf5) {
      # clang defaults to DWARF2 on macOS unless mac_deployment_target is
      # at least 10.11.
      # TODO(thakis): Remove this once mac_deployment_target is 10.11.
      cflags += [ "-gdwarf-4" ]
      rustflags += [ "-Zdwarf-version=4" ]
    } else if (!use_dwarf5 && !is_nacl && current_os != "aix") {
      # On aix -gdwarf causes linker failures due to thread_local variables.
      # Recent clang versions default to DWARF5 on Linux, and Android is about
      # to switch. TODO: Adopt that in controlled way.
      cflags += [ "-gdwarf-4" ]
      rustflags += [ "-Zdwarf-version=4" ]
    }

    if (use_dwarf5 && !is_nacl) {
      cflags += [ "-gdwarf-5" ]
      rustflags += [ "-Zdwarf-version=5" ]
    }

    # The gcc-based nacl compilers don't support -fdebug-compilation-dir (see
    # elsewhere in this file), so they can't have build-dir-independent output.
    # Moreover pnacl does not support newer flags such as -fdebug-prefix-map
    # Disable symbols for nacl object files to get deterministic,
    # build-directory-independent output.
    # Keeping -g1 for saigo as it's the only toolchain whose artifacts that are
    # part of chromium release (other nacl toolchains are used only for tests).
    if (!is_nacl || is_nacl_saigo) {
      cflags += [ "-g1" ]
    }

    if (!is_nacl && is_clang && !is_tsan && !is_asan && current_os != "zos") {
      # See comment for -gdwarf-aranges in config("symbols").
      cflags += [ "-gdwarf-aranges" ]
    }

    ldflags = []
    if (is_android && is_clang) {
      # Android defaults to symbol_level=1 builds, but clang, unlike gcc,
      # doesn't emit DW_AT_linkage_name in -g1 builds.
      # -fdebug-info-for-profiling enables that (and a bunch of other things we
      # don't need), so that we get qualified names in stacks.
      # TODO(thakis): Consider making clang emit DW_AT_linkage_name in -g1 mode;
      #               failing that consider doing this on non-Android too.
      cflags += [ "-fdebug-info-for-profiling" ]
    }

    asmflags = cflags
  }
  rustflags += [ "-Cdebuginfo=1" ]
}

# This configuration contains function names only. That is, the compiler is
# told to not generate debug information and the linker then just puts function
# names in the final debug information.
config("no_symbols") {
  if (is_win) {
    ldflags = [ "/DEBUG" ]

    # All configs using /DEBUG should include this:
    configs = [ ":win_pdbaltpath" ]
  } else {
    cflags = [ "-g0" ]
    asmflags = cflags
  }
}

# Default symbols.
config("default_symbols") {
  if (symbol_level == 0) {
    configs = [ ":no_symbols" ]
  } else if (symbol_level == 1) {
    configs = [ ":minimal_symbols" ]
  } else if (symbol_level == 2) {
    configs = [ ":symbols" ]
  } else {
    assert(false)
  }

  # This config is removed by base unittests apk.
  if (is_android && is_clang && strip_debug_info) {
    configs += [ ":strip_debug" ]
  }
}

config("strip_debug") {
  if (!defined(ldflags)) {
    ldflags = []
  }
  ldflags += [ "-Wl,--strip-debug" ]
}

if (is_apple) {
  # On macOS and iOS, this enables support for ARC (automatic reference
  # counting). See http://clang.llvm.org/docs/AutomaticReferenceCounting.html.
  #
  # -fobjc-arc enables ARC overall.
  #
  # ARC does not add exception handlers to pure Objective-C code, but does add
  # them to Objective-C++ code with the rationale that C++ pervasively adds them
  # in for exception safety. However, exceptions are banned in Chromium code for
  # C++ and exceptions in Objective-C code are intended to be fatal, so
  # -fno-objc-arc-exceptions is specified to disable these unwanted exception
  # handlers.
  config("enable_arc") {
    common_flags = [
      "-fobjc-arc",
      "-fno-objc-arc-exceptions",
    ]
    cflags_objc = common_flags
    cflags_objcc = common_flags
  }
}

if (is_android) {
  # Use orderfile for linking Chrome on Android.
  # This config enables using an orderfile for linking in LLD.
  config("chrome_orderfile_config") {
    # Don't try to use an orderfile with call graph sorting, except on Android,
    # where we care about memory used by code, so we still want to mandate
    # ordering.
    if (chrome_orderfile_path != "") {
      assert(use_lld)
      _rebased_orderfile = rebase_path(chrome_orderfile_path, root_build_dir)
      ldflags = [
        "-Wl,--symbol-ordering-file",
        "-Wl,$_rebased_orderfile",
        "-Wl,--no-warn-symbol-ordering",
      ]
      inputs = [ chrome_orderfile_path ]
    }
  }
}

# Initialize all variables on the stack if needed.
config("default_init_stack_vars") {
  cflags = []
  if (init_stack_vars && is_clang && !is_nacl && !using_sanitizer) {
    if (init_stack_vars_zero) {
      cflags += [ "-ftrivial-auto-var-init=zero" ]
    } else {
      cflags += [ "-ftrivial-auto-var-init=pattern" ]
    }
  }
}

buildflag_header("compiler_buildflags") {
  header = "compiler_buildflags.h"

  flags = [
    "CLANG_PGO=$chrome_pgo_phase",
    "SYMBOL_LEVEL=$symbol_level",
  ]
}

config("cet_shadow_stack") {
  if (enable_cet_shadow_stack && is_win) {
    assert(target_cpu == "x64")
    ldflags = [ "/CETCOMPAT" ]
  }
}
