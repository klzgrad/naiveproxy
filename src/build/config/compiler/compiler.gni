# Copyright 2015 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/c++/c++.gni")
import("//build/config/cast.gni")
import("//build/config/chrome_build.gni")
import("//build/config/chromeos/args.gni")
import("//build/config/chromeos/ui_mode.gni")
import("//build/config/compiler/pgo/pgo.gni")
import("//build/config/cronet/config.gni")
import("//build/config/sanitizers/sanitizers.gni")
import("//build/toolchain/cc_wrapper.gni")
import("//build/toolchain/toolchain.gni")
import("//build_overrides/build.gni")

if (is_android) {
  import("//build/config/android/abi.gni")
}
if (current_cpu == "arm" || current_cpu == "arm64") {
  import("//build/config/arm.gni")
}

if (is_apple) {
  import("//build/config/apple/symbols.gni")
}

if (is_ios) {
  import("//build/config/ios/config.gni")
}

declare_args() {
  # Set to true to use lld, the LLVM linker.
  # In late bring-up on macOS (see docs/mac_lld.md).
  # Tentatively used on iOS.
  # The default linker everywhere else.
  use_lld = is_clang && current_os != "zos"

  # If true, optimize for size.
  # Default to favoring speed over size for platforms not listed below.
  optimize_for_size =
      !is_high_end_android && (is_android || is_castos || is_fuchsia)
}

declare_args() {
  # Default to warnings as errors for default workflow, where we catch
  # warnings with known toolchains. Allow overriding this e.g. for Chromium
  # builds on Linux that could use a different version of the compiler.
  # With GCC, warnings in no-Chromium code are always not treated as errors.
  treat_warnings_as_errors = true

  # How many symbols to include in the build. This affects the performance of
  # the build since the symbols are large and dealing with them is slow.
  #   2 means regular build with symbols.
  #   1 means minimal symbols, usually enough for backtraces only. Symbols with
  # internal linkage (static functions or those in anonymous namespaces) may not
  # appear when using this level.
  #   0 means no symbols.
  #   -1 means auto-set according to debug/release and platform.
  symbol_level = -1

  # Android-only: Strip the debug info of libraries within lib.unstripped to
  # reduce size. As long as symbol_level > 0, this will still allow stacks to be
  # symbolized.
  strip_debug_info = false

  # Compile in such a way as to enable profiling of the generated code. For
  # example, don't omit the frame pointer and leave in symbols.
  enable_profiling = false

  # use_debug_fission: whether to use split DWARF debug info
  # files. This can reduce link time significantly, but is incompatible
  # with some utilities such as icecc and ccache. Requires gold and
  # gcc >= 4.8 or clang.
  # http://gcc.gnu.org/wiki/DebugFission
  use_debug_fission = !is_android && !is_fuchsia && !is_apple && !is_win &&
                      use_lld && cc_wrapper == ""

  # Enables support for ThinLTO, which links 3x-10x faster than full LTO. See
  # also http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html
  # Use it by default on official-optimized android and Chrome OS builds, but
  # not ARC or linux-chromeos since it's been seen to not play nicely with
  # Chrome's clang. crbug.com/1033839
  # Disabled in iOS cronet builds since build step cronet_static_complete
  # wants to build a .a file consumable by external clients, and they won't
  # have the same LLVM revisions as us, making bitcode useless to them.
  use_thin_lto =
      is_cfi || (is_clang && is_official_build && chrome_pgo_phase != 1 &&
                 (is_linux || is_win || is_mac ||
                  (is_ios && use_lld && !is_cronet_build) ||
                  (is_android && target_os != "chromeos") ||
                  (is_chromeos && is_chromeos_device)))

  # Whether we're using a sample profile collected on an architecture different
  # than the one we're compiling for.
  #
  # It's currently not possible to collect AFDO profiles on anything but
  # x86{,_64}.
  using_mismatched_sample_profile = current_cpu != "x64" && current_cpu != "x86"

  # Whether an error should be raised on attempts to make debug builds with
  # is_component_build=false. Very large debug symbols can have unwanted side
  # effects so this is enforced by default for chromium.
  forbid_non_component_debug_builds = build_with_chromium

  # Exclude unwind tables by default for official builds as unwinding can be
  # done from stack dumps produced by Crashpad at a later time "offline" in the
  # crash server. Since this increases binary size, we don't recommend including
  # them in shipping builds.
  # For unofficial (e.g. development) builds and non-Chrome branded (e.g. Cronet
  # which doesn't use Crashpad, crbug.com/479283) builds it's useful to be able
  # to unwind at runtime.
  # Include the unwind tables on Android even for official builds, as otherwise
  # the crash dumps generated by Android's debuggerd are largely useless, and
  # having this additional mechanism to understand issues is particularly helpful
  # to WebView.
  exclude_unwind_tables = is_official_build && !is_android

  # Where to redirect clang crash diagnoses
  clang_diagnostic_dir =
      rebase_path("//tools/clang/crashreports", root_build_dir)

  # Mark binaries as compatible with Shadow Stack of Control-flow Enforcement
  # Technology (CET). If Windows version and hardware supports the feature and
  # it's enabled by OS then additional validation of return address will be
  # performed as mitigation against Return-oriented programming (ROP).
  # https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#cet-shadow-stack
  enable_cet_shadow_stack = target_cpu == "x64"

  # Set to true to enable using the ML inliner in LLVM. This currently only
  # enables the ML inliner when targeting Android.
  # Currently the ML inliner is only supported on linux hosts
  use_ml_inliner = host_os == "linux" && is_android &&
                   !llvm_android_mainline  # https://crbug.com/1468680

  # Set to true to use the android unwinder V2 implementation.
  use_android_unwinder_v2 = true

  # Whether we should consider the profile we're using to be accurate. Accurate
  # profiles have the benefit of (potentially substantial) binary size
  # reductions, by instructing the compiler to optimize cold and uncovered
  # functions heavily for size. This often comes at the cost of performance.
  sample_profile_is_accurate = optimize_for_size

  # Use offsets rather than pointers in vtables in order to reduce the number of
  # relocations. This is safe to enable only when all C++ code is built with the
  # flag set to the same value.
  use_relative_vtables_abi = is_android && current_cpu == "arm64" &&
                             use_custom_libcxx && !is_component_build
}

# To try out this combination, delete this assert.
assert(
    !use_relative_vtables_abi || !is_cfi,
    "is_cfi=true is known to conflict with use_relative_vtables_abi=true.\n" +
        "See https://bugs.chromium.org/p/chromium/issues/detail?id=1375035#c53")

assert(!is_cfi || use_thin_lto, "CFI requires ThinLTO")
assert(!enable_profiling || !is_component_build,
       "Cannot profile component builds (crbug.com/1199271).")

if (use_thin_lto && is_debug) {
  print("WARNING: ThinLTO (use_thin_lto=true) doesn't work with debug" +
        " (is_debug=true) build.")
}

# Determine whether to enable or disable frame pointers, based on the platform
# and build arguments.
if (is_chromeos) {
  # ChromeOS generally prefers frame pointers, to support CWP.
  # However, Clang does not currently generate usable frame pointers in ARM
  # 32-bit builds (https://bugs.llvm.org/show_bug.cgi?id=18505) so disable them
  # there to avoid the unnecessary overhead.
  enable_frame_pointers = current_cpu != "arm"
} else if (is_apple || is_linux) {
  enable_frame_pointers = true
} else if (is_win) {
  # 64-bit Windows ABI doesn't support frame pointers.
  # NOTE: This setting is actually not used in the BUILD.gn for Windows,
  # but it still reflects correctly that we don't emit frame pointers on x64.
  if (current_cpu == "x64") {
    enable_frame_pointers = false
  } else {
    enable_frame_pointers = true
  }
} else if (is_android) {
  enable_frame_pointers =
      enable_profiling ||
      # Ensure that stacks from arm64 crash dumps are usable (crbug.com/391706).
      current_cpu == "arm64" ||
      # For x86 Android, unwind tables are huge without frame pointers
      # (crbug.com/762629). Enabling frame pointers grows the code size slightly
      # but overall shrinks binaries considerably by avoiding huge unwind
      # tables.
      (current_cpu == "x86" && !exclude_unwind_tables && optimize_for_size) ||
      using_sanitizer
} else if (is_fuchsia) {
  # Fuchsia on arm64 could use shadow call stack for unwinding.
  enable_frame_pointers = current_cpu != "arm64"
} else {
  # Explicitly ask for frame pointers, otherwise stacks may be missing for
  # sanitizer and profiling builds.
  enable_frame_pointers = using_sanitizer || enable_profiling || is_debug
}

# In general assume that if we have frame pointers then we can use them to
# unwind the stack. However, this requires that they are enabled by default for
# most translation units, that they are emitted correctly, and that the
# compiler or platform provides a way to access them.
can_unwind_with_frame_pointers = enable_frame_pointers
if (current_cpu == "arm" && arm_use_thumb) {
  # We cannot currently unwind ARM Thumb frame pointers correctly.
  # See https://bugs.llvm.org/show_bug.cgi?id=18505
  can_unwind_with_frame_pointers = false
} else if (is_win) {
  # Windows 32-bit does provide frame pointers, but the compiler does not
  # provide intrinsics to access them, so we don't use them.
  can_unwind_with_frame_pointers = false
}

assert(!can_unwind_with_frame_pointers || enable_frame_pointers)

# Unwinding with CFI table is only possible on static library builds and
# requried only when frame pointers are not enabled.
can_unwind_with_cfi_table = is_android && !is_component_build &&
                            !enable_frame_pointers && current_cpu == "arm"

# Whether or not cfi table should be enabled on arm.
# TODO(crbug.com/40133751): Replace can_unwind_with_cfi_table with this once
# sampling profiler is enabled on android.
enable_arm_cfi_table = is_android && !is_component_build && current_cpu == "arm"

# Use relative paths for debug info. This is important to make the build
# results independent of the checkout and build directory names, which
# in turn is important for reclient compile hit rate.
# Setting this to true may make it harder to debug binaries on Linux, see
# https://chromium.googlesource.com/chromium/src/+/main/docs/linux/debugging.md#Source-level-debug-with-fdebug_compilation_dir
# It's not clear if the crash server will correctly handle dSYMs with relative
# paths, so we disable this feature for official benefit. The main benefit is
# deterministic builds to reduce compile times, so this is less relevant for
# official builders.
strip_absolute_paths_from_debug_symbols_default =
    is_android || is_fuchsia || is_nacl || (is_win && use_lld) || is_linux ||
    is_chromeos || (is_apple && !enable_dsyms)

# If the platform uses stripped absolute paths by default, then we don't expose
# it as a configuration option. If this is causing problems, please file a bug.
if (strip_absolute_paths_from_debug_symbols_default) {
  strip_absolute_paths_from_debug_symbols = true
} else {
  declare_args() {
    strip_absolute_paths_from_debug_symbols = false
  }
}

# When absolute_paths in debug symbols, we need to use input root
# absolute path to execute remotely in RBE.
clang_need_input_root_absolute_path = !strip_absolute_paths_from_debug_symbols

if (clang_need_input_root_absolute_path) {
  compiler_logs = [ "clang_need_input_root_absolute_path=true" ]
} else {
  compiler_logs = [ "clang_need_input_root_absolute_path=false" ]
}

# TODO: https://issues.chromium.org/40120210 - remove this
# once we can use relative path in hmap.
clang_need_input_root_absolute_path_for_objc =
    clang_need_input_root_absolute_path
if (target_os == "ios") {
  # objc/objcxx uses hmap, which contains absolute path
  # see also b/256536089
  clang_need_input_root_absolute_path_for_objc = true
}
compiler_logs += [ "clang_need_input_root_absolute_path_for_objc=$clang_need_input_root_absolute_path_for_objc" ]

# If it wasn't manually set, set to an appropriate default.
assert(symbol_level >= -1 && symbol_level <= 2, "Invalid symbol_level")
if (symbol_level == -1) {
  if (is_android && !is_component_build && !use_debug_fission) {
    # Prefer faster & smaller release builds.
    symbol_level = 1
  } else if (is_chromeos_device) {
    # Use lower symbol level in Simple Chrome build for faster link time.
    # For Simple Chrome, this should take precedence over is_official_build,
    # turned on by --internal.
    if ((target_cpu == "x64" || target_cpu == "x86") && !is_debug) {
      # For release x86/x64 build, specify symbol_level=0 for faster link time.
      # x86/x64 shows backtraces with symbol_level=0 (arm requires
      # symbol_level=1).
      symbol_level = 0
    } else {
      symbol_level = 1
    }
  } else if (using_sanitizer) {
    # Sanitizers need line table info for stack traces. They don't need type
    # info or variable info, so we can leave that out to speed up the build.
    # Sanitizers also require symbols for filename suppressions to work.
    symbol_level = 1
  } else if ((!is_nacl && !is_linux && !is_chromeos && !is_fuchsia &&
              current_os != "aix") || is_debug || is_official_build ||
             is_castos || is_cast_android) {
    # Linux builds slower by having symbols as part of the target binary,
    # whereas Mac and Windows have them separate, so in Release Linux, default
    # them off, but keep them on for Official builds and Chromecast builds.
    symbol_level = 2
  } else {
    symbol_level = 0
  }
}

# Split dwarf works only for symbol_level == 2.
use_debug_fission = use_debug_fission && symbol_level == 2

# Non-component debug builds with symbol_level = 2 are an undesirable (very slow
# build times, almost two-minute link times) combination. This is only checked
# when current_toolchain == default_toolchain because the is_component_build
# flag is set to false in various components of the build (like nacl) and we
# don't want to assert on those.
# iOS does not support component builds so add an exception for this platform.
# Windows supports huge PDBs so this combination is allowed for those who don't
# mind long build times.
if (forbid_non_component_debug_builds) {
  assert(
      symbol_level != 2 || current_toolchain != default_toolchain ||
          is_component_build || is_fuchsia || is_apple || use_debug_fission ||
          is_android || is_chromeos || host_os == "win",
      "Can't do non-component builds at symbol_level=2 without use_debug_fission=true")
}

# TODO(crbug.com/40230692) For Windows, to assemble lzma_sdk's assembly files,
# ml64.exe needs to be utilized as llvm-ml cannot yet assemble it. Once llvm-ml
# is able to assemble lzma_sdk assembly files, remove this.
# LzmaDecOpt.asm only works on x64 and not x86.
# https://sourceforge.net/p/sevenzip/discussion/45797/thread/768932e9dd/?limit=25#0d6c
disable_llvm_ml = host_os == "win" && target_cpu == "x64" && !is_msan
