# Copyright 2025 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/apple/apple_sdk.gni")
import("//build/config/clang/clang.gni")

declare_args() {
  # Set to true when being run by build/modules/modularize.py
  running_modularize = false

  # It's a nontrivial switch, with differing APIs, so it's somewhat difficult
  # to migrate over one platform at a time.
  # In general, this should be true unless we have specifically supported
  # a platform with manual modules and are in the process of migrating.
  # Eg. linux arm64 and windows were never supported with manual clang modules,
  # so they should use_autogenerated_modules = true despite not having
  # autogenerated modules because they're guarded by use_clang_modules.
  use_autogenerated_modules = !(is_apple && use_system_xcode)
}

module_platform = "${current_os}-${current_cpu}"
if (is_chromeos) {
  # ChromeOS uses the linux sysroot.
  module_platform = "linux"
} else if (is_fuchsia || is_mac || is_linux) {
  # Currently, these generate the same sysroot for all architectures. This is
  # not inherently the case. If we start getting errors on one architecture
  # but not the other, we will revert back to one modulemap per cpu.
  module_platform = current_os
}

if (is_apple && use_autogenerated_modules) {
  # This must maintain sorted order
  # xcode versions are bucketed by compatibility groups.
  # eg. if our xcode 2600 config stops working while trying to roll xcode 3000,
  # we would update it from [2600] to [2600, 3000] and rerun modularize to
  # This would create the buckets:
  # [0, 2600) => unsupported
  # [2600, 3000) => 2600
  # [3000, ...) => 3000
  xcode_version_buckets = [ 2600 ]
  foreach(version, xcode_version_buckets) {
    if (xcode_version_int >= version) {
      bucket = version
    }
  }
  assert(defined(bucket),
         "xcode version ${xcode_version_int} was below the minimum supported " +
             "version ${xcode_version_buckets[0]}")
  module_platform += "_xcode${bucket}"
}

# This is read by the modularize.py script to determine which directory to write
# to.
if (current_toolchain == default_toolchain) {
  write_file("${root_gen_dir}/module_platform.txt", module_platform)
}

if (clang_modules_platform_supported && use_autogenerated_modules) {
  chrome_build_file_bug = "https://g-issues.chromium.org/issues/new?cc=chrome-build-team@google.com&component=1456832&type=BUG&priority=P2&severity=S2&template=1959503"

  path = "//build/modules/${module_platform}/BUILD.gn"
  assert(
      path_exists(path),
      "${path} does not exist. Please file a bug at ${chrome_build_file_bug} " +
          "containing your args.gn, and mention that it failed on " +
          "${current_os}-${current_cpu}")
}

if (!use_autogenerated_modules && use_clang_modules) {
  sysroot_modulemaps = [
    "$sdk_path/usr/include/DarwinBasic.modulemap",
    "$sdk_path/usr/include/DarwinFoundation1.modulemap",
    "$sdk_path/usr/include/DarwinFoundation2.modulemap",
    "$sdk_path/usr/include/DarwinFoundation3.modulemap",
  ]

  # Textual modules do not need to be precompiled.
  # However, like regular modules, they do need to include things.
  template("textual_module") {
    source_set(target_name) {
      forward_variables_from(invoker, [ "public_deps" ])
      use_libcxx_modules = false
    }
  }
}
