# Copyright 2023 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/android/rules.gni")
import("//build/partitioned_shared_library.gni")

# This is a wrapper around an underlying native target which inserts JNI
# registration.
#
# The registration is based on the closure of the native target's generate_jni
# transitive dependencies. Additionally, we use provided java_targets to assert
# that our native and Java sides line up.
#
# In order to depend on the JNI registration, use
# <native-target-name>__jni_registration.
template("_native_with_jni") {
  forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
  _jni_registration_name = "${target_name}__jni_registration"

  # DFMs only ever need to be defined in the default toolchain, since we never
  # do cross-toolchain deps with DFMs.
  _use_all_toolchains = !defined(invoker.module_name)

  if (_use_all_toolchains || current_toolchain == default_toolchain) {
    generate_jni_registration(_jni_registration_name) {
      native_deps = invoker.deps

      if (allow_jni_multiplexing) {
        enable_jni_multiplexing = true
      }
      if (defined(invoker.testonly) && invoker.testonly) {
        enable_native_mocks = true
        add_stubs_for_missing_jni = true
        remove_uncalled_jni = true
      }
      forward_variables_from(invoker,
                             [
                               "add_stubs_for_missing_jni",
                               "java_targets",
                               "manual_jni_registration",
                               "module_name",
                               "namespace",
                               "remove_uncalled_jni",
                             ])
    }
  } else {
    not_needed(invoker,
               [
                 "add_stubs_for_missing_jni",
                 "java_targets",
                 "manual_jni_registration",
                 "module_name",
                 "namespace",
                 "remove_uncalled_jni",
               ])
  }

  target(invoker.target_type, target_name) {
    deps = invoker.deps
    _need_native_dep =
        (defined(invoker.manual_jni_registration) &&
         invoker.manual_jni_registration) || allow_jni_multiplexing
    if (_need_native_dep) {
      _jni_registration_dep = ":$_jni_registration_name"
      if (!_use_all_toolchains) {
        _jni_registration_dep += "($default_toolchain)"
      }
      deps += [ _jni_registration_dep ]
    }
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY + [ "deps" ])
  }
}

# native_with_jni for shared libraries - see _native_with_jni for details.
template("shared_library_with_jni") {
  _native_with_jni(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    target_type = "shared_library"
  }
}
set_defaults("shared_library_with_jni") {
  configs = default_shared_library_configs
}

# native_with_jni for partitioned shared libraries - see _native_with_jni for
# details.
template("partitioned_shared_library_with_jni") {
  _native_with_jni(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    target_type = "partitioned_shared_library"
  }
}
set_defaults("partitioned_shared_library_with_jni") {
  configs = default_shared_library_configs
}

# native_with_jni for components - see _native_with_jni for details.
template("component_with_jni") {
  _native_with_jni(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    target_type = "component"
  }
}
set_defaults("component_with_jni") {
  configs = default_component_configs
}
