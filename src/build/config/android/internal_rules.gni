# Copyright 2014 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Do not add any imports to non-//build directories here.
# Some projects (e.g. V8) do not have non-build directories DEPS'ed in.
import("//build/config/android/channel.gni")
import("//build/config/android/config.gni")
import("//build/config/compiler/compiler.gni")
import("//build/config/compute_inputs_for_analyze.gni")
import("//build/config/coverage/coverage.gni")
import("//build/config/python.gni")
import("//build/config/sanitizers/sanitizers.gni")
import("//build/toolchain/kythe.gni")
import("//build/util/generate_wrapper.gni")
import("//build_overrides/build.gni")
if (current_toolchain == default_toolchain) {
  import("//build/toolchain/concurrent_links.gni")
}
assert(is_android)

default_android_sdk_dep = "//third_party/android_sdk:android_sdk_java"
_kotlin_stdlib_dep = "//third_party/kotlin_stdlib:kotlin_stdlib_java"
_jacoco_dep = "//third_party/jacoco:jacocoagent_java"
_jacoco_host_jar =
    "$root_build_dir/lib.java/third_party/jacoco/jacocoagent_java.jar"
_robolectric_libs_dir =
    rebase_path(
        get_label_info("//:foo($robolectric_toolchain)", "root_out_dir"),
        root_build_dir)
_nullaway_jar = "//third_party/android_build_tools/nullaway/cipd/nullaway.jar"
_rebased_nullaway_jar = rebase_path(_nullaway_jar, root_build_dir)

# The following _java_*_types variables capture all the existing target types.
# If a new type is introduced, please add it to one of these categories,
# preferring the more specific resource/library types.
_java_resource_types = [
  "android_assets",
  "android_resources",
]

_java_library_types = [
  "java_library",
  "system_java_library",
  "android_app_bundle_module",
]

# These are leaf java target types. They cannot be passed as deps to other
# targets. Thus their naming schemes are not enforced.
_java_leaf_types = [
  "android_apk",
  "android_app_bundle",
  "dist_aar",
  "dist_jar",
  "java_annotation_processor",
  "java_binary",
  "robolectric_binary",
]

# All _java_resource_types targets must conform to these patterns.
java_resource_patterns = [
  "*_assets",
  "*_grd",
  "*_java_strings",
  "*locale_paks",
  "*_resources",
  "*strings_java",
  "*android*:assets",
  "*:*_apk_*resources",
  "*android*:resources",
]

# All _java_library_types targets must conform to these patterns. This includes
# all non-leaf targets that use java_library_impl.
java_library_patterns = [
  "*_java",
  "*_javalib",
  "*javatests",
  "*_bundle_module",
  "*:*_java_*",  # E.g. chrome_java_test_support
  "*:java",
  "*/java",  # to allow filtering without expanding labels //a/java ->
             # //a/java:java
  "*:junit",
  "*/junit",
  "*:junit_*",
  "*:*_junit_*",

  # TODO(agrieve): Rename to glue_java
  "//android_webview/glue",
  "//android_webview/glue:glue",
]

# These identify all non-leaf targets that have .build_config.json files. This is the
# set of patterns that other targets can use to filter out java targets.
java_target_patterns = java_library_patterns + java_resource_patterns

_r8_path = "//third_party/r8/cipd/lib/r8.jar"
_custom_r8_path = "//third_party/r8/custom_r8.jar"

# This duplication is intentional, so we avoid updating the r8.jar used by
# dexing unless necessary, since each update invalidates all incremental dexing
# and unnecessarily slows down all bots.
_d8_path = "//third_party/r8/d8/cipd/lib/r8.jar"
_custom_d8_path = "//third_party/r8/custom_d8.jar"
_default_lint_jar_path = "//third_party/android_build_tools/lint/cipd/lint.jar"
_custom_lint_jar_path = "//third_party/android_build_tools/lint/custom_lint.jar"
_manifest_merger_jar_path =
    "//third_party/android_build_tools/manifest_merger/cipd/manifest-merger.jar"

# Put the bug number in the target name so that false-positives have a hint in
# the error message about why non-existent dependencies are there.
build_config_target_suffix = "__build_config_crbug_908819"

# Write the target's .build_config.json file. This is a json file that contains a
# dictionary of information about how to build this target (things that
# require knowledge about this target's dependencies and cannot be calculated
# at gn-time). There is a special syntax to add a value in that dictionary to
# an action/action_foreachs args:
#   --python-arg=@FileArg($rebased_build_config_path:key0:key1)
# At runtime, such an arg will be replaced by the value in the build_config.
# See build/android/gyp/write_build_config.py and
# build/android/gyp/util/build_utils.py:ExpandFileArgs
template("write_build_config") {
  action_with_pydeps(target_name) {
    forward_variables_from(invoker, [ "testonly" ])
    _type = invoker.type
    _parent_invoker = invoker.invoker
    _target_label =
        get_label_info(":${_parent_invoker.target_name}", "label_no_toolchain")

    # Ensure targets match naming patterns so that __assetres, __header, __host,
    # and __validate targets work properly.
    if (filter_exclude([ _type ], _java_resource_types) == []) {
      if (filter_exclude([ _target_label ], java_resource_patterns) != []) {
        assert(false, "Invalid java resource target name: $_target_label")
      }
    } else if (filter_exclude([ _type ], _java_library_types) == []) {
      if (filter_exclude([ _target_label ], java_library_patterns) != [] ||
          filter_exclude([ _target_label ], java_resource_patterns) == []) {
        assert(false, "Invalid java library target name: $_target_label")
      }
    } else if (_type == "group") {
      if (filter_exclude([ _target_label ], java_target_patterns) != []) {
        assert(false, "Invalid java target name: $_target_label")
      }
    } else if (filter_exclude([ _type ], _java_leaf_types) != []) {
      assert(false, "This java type needs a category: $_type")
    }

    if (defined(invoker.public_target_label)) {
      _target_label = invoker.public_target_label
    }

    deps = []
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.android_manifest_dep)) {
      deps += [ invoker.android_manifest_dep ]
    }

    script = "//build/android/gyp/write_build_config.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = []
    outputs = [ invoker.build_config ]

    _deps_configs = []
    if (defined(invoker.possible_config_deps)) {
      foreach(_possible_dep, invoker.possible_config_deps) {
        _dep_label = get_label_info(_possible_dep, "label_no_toolchain")
        if (filter_exclude([ _dep_label ], java_target_patterns) == []) {
          deps += [ "$_dep_label$build_config_target_suffix" ]
          _dep_gen_dir = get_label_info(_possible_dep, "target_gen_dir")
          _dep_name = get_label_info(_possible_dep, "name")
          _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"

          _deps_configs += [ _dep_config ]
        }
      }
    }
    _public_deps_configs = []
    if (defined(invoker.possible_config_public_deps)) {
      foreach(_possible_dep, invoker.possible_config_public_deps) {
        _dep_label = get_label_info(_possible_dep, "label_no_toolchain")

        # E.g. Adding an action that generates a .java file that is then
        # consumed by a subsequent java_library() target would not work
        # because the libraries depend only on the nested targets of one
        # another. It is simplest to just ban non-java public_deps.
        assert(filter_exclude([ _dep_label ], java_target_patterns) == [],
               "Only java_library targets can be used as public_deps. " +
                   "Found:\n${_dep_label}\non Target:\n" +
                   get_label_info(":$target_name", "label_no_toolchain"))

        # Put the bug number in the target name so that false-positives
        # have a hint in the error message about non-existent dependencies.
        deps += [ "$_dep_label$build_config_target_suffix" ]
        _dep_gen_dir = get_label_info(_possible_dep, "target_gen_dir")
        _dep_name = get_label_info(_possible_dep, "name")
        _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"

        _public_deps_configs += [ _dep_config ]
      }
    }
    inputs += _deps_configs
    inputs += _public_deps_configs
    _rebased_deps_configs = rebase_path(_deps_configs, root_build_dir)
    _rebased_public_deps_configs =
        rebase_path(_public_deps_configs, root_build_dir)

    args = [
      "--type=$_type",
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--deps-configs=$_rebased_deps_configs",
      "--public-deps-configs=$_rebased_public_deps_configs",
      "--build-config",
      rebase_path(invoker.build_config, root_build_dir),
      "--gn-target",
      _target_label,
    ]

    if (defined(invoker.preferred_dep) && invoker.preferred_dep) {
      args += [ "--preferred-dep" ]
    }

    if (defined(invoker.aar_path)) {
      args += [
        "--aar-path",
        rebase_path(invoker.aar_path, root_build_dir),
      ]
    }

    if (defined(invoker.chromium_code) && !invoker.chromium_code) {
      # Default to chromium code if invoker did not pass anything.
      args += [ "--non-chromium-code" ]
    }

    if (defined(invoker.device_jar_path)) {
      args += [
        "--device-jar-path",
        rebase_path(invoker.device_jar_path, root_build_dir),
      ]
    }
    if (defined(invoker.host_jar_path)) {
      args += [
        "--host-jar-path",
        rebase_path(invoker.host_jar_path, root_build_dir),
      ]
    }
    if (defined(invoker.unprocessed_jar_path)) {
      args += [
        "--unprocessed-jar-path",
        rebase_path(invoker.unprocessed_jar_path, root_build_dir),
      ]
    }
    if (defined(invoker.ijar_path)) {
      args += [
        "--interface-jar-path",
        rebase_path(invoker.ijar_path, root_build_dir),
      ]
    }
    if (defined(invoker.kotlinc_jar_path)) {
      args += [
        "--kotlinc-jar-path",
        rebase_path(invoker.kotlinc_jar_path, root_build_dir),
      ]
    }
    if (defined(invoker.java_resources_jar)) {
      args += [
        "--java-resources-jar-path",
        rebase_path(invoker.java_resources_jar, root_build_dir),
      ]
    }
    if (defined(invoker.annotation_processor_deps) &&
        invoker.annotation_processor_deps != []) {
      _processor_configs = []
      foreach(_dep_label, invoker.annotation_processor_deps) {
        deps += [ "$_dep_label$build_config_target_suffix" ]
        _dep_gen_dir = get_label_info(_dep_label, "target_gen_dir")
        _dep_name = get_label_info(_dep_label, "name")
        _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"
        _processor_configs += [ _dep_config ]
      }
      _rebased_processor_configs =
          rebase_path(_processor_configs, root_build_dir)
      inputs += _processor_configs
      args += [ "--annotation-processor-configs=$_rebased_processor_configs" ]
    }

    # Dex path for library targets, or the the intermediate library for apks.
    if (defined(invoker.dex_path)) {
      args += [
        "--dex-path",
        rebase_path(invoker.dex_path, root_build_dir),
      ]
    }

    # Dex path for the final apk.
    if (defined(invoker.final_dex_path)) {
      args += [
        "--final-dex-path",
        rebase_path(invoker.final_dex_path, root_build_dir),
      ]
    }
    if (defined(invoker.supports_android) && invoker.supports_android) {
      args += [ "--supports-android" ]
    }
    if (defined(invoker.requires_android) && invoker.requires_android) {
      args += [ "--requires-android" ]
    }
    if (defined(invoker.is_prebuilt) && invoker.is_prebuilt) {
      args += [ "--is-prebuilt" ]
    }
    if (defined(invoker.bypass_platform_checks) &&
        invoker.bypass_platform_checks) {
      args += [ "--bypass-platform-checks" ]
    }
    if (defined(invoker.is_robolectric) && invoker.is_robolectric) {
      args += [ "--is-robolectric" ]
    }

    if (defined(invoker.apk_under_test)) {
      _dep_label = invoker.apk_under_test
      _dep_gen_dir = get_label_info(_dep_label, "target_gen_dir")
      _dep_name = get_label_info(_dep_label, "name")
      _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"
      inputs += [ _dep_config ]
      deps += [ "$_dep_label$build_config_target_suffix" ]
      args += [
        "--tested-apk-config",
        rebase_path(_dep_config, root_build_dir),
      ]
    }

    if (defined(invoker.asset_sources)) {
      _rebased_asset_sources =
          rebase_path(invoker.asset_sources, root_build_dir)
      args += [ "--asset-sources=$_rebased_asset_sources" ]
    }
    if (defined(invoker.asset_renaming_sources)) {
      _rebased_asset_renaming_sources =
          rebase_path(invoker.asset_renaming_sources, root_build_dir)
      args += [ "--asset-renaming-sources=$_rebased_asset_renaming_sources" ]

      # These are zip paths, so no need to rebase.
      args += [
        "--asset-renaming-destinations=${invoker.asset_renaming_destinations}",
      ]
    }
    if (defined(invoker.disable_compression) && invoker.disable_compression) {
      args += [ "--disable-asset-compression" ]
    }
    if (defined(invoker.treat_as_locale_paks) && invoker.treat_as_locale_paks) {
      args += [ "--treat-as-locale-paks" ]
    }
    if (defined(invoker.suffix_apk_assets_used_by)) {
      _dep_label = invoker.suffix_apk_assets_used_by
      _dep_gen_dir = get_label_info(_dep_label, "target_gen_dir")
      _dep_name = get_label_info(_dep_label, "name")
      _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"
      if (_dep_config != invoker.build_config) {
        inputs += [ _dep_config ]
        deps += [ "$_dep_label$build_config_target_suffix" ]
      }
      args += [
        "--suffix-apk-assets-used-by",
        rebase_path(_dep_config, root_build_dir),
      ]
    }

    if (defined(invoker.merged_android_manifest)) {
      args += [
        "--merged-android-manifest",
        rebase_path(invoker.merged_android_manifest, root_build_dir),
      ]
    }
    if (defined(invoker.android_manifest)) {
      inputs += [ invoker.android_manifest ]
      args += [
        "--android-manifest",
        rebase_path(invoker.android_manifest, root_build_dir),
      ]
    }
    if (defined(invoker.resources_zip)) {
      args += [
        "--resources-zip",
        rebase_path(invoker.resources_zip, root_build_dir),
      ]
    }

    if (defined(invoker.resource_overlay) && invoker.resource_overlay) {
      args += [ "--resource-overlay" ]
    }

    if (defined(invoker.custom_package)) {
      args += [
        "--package-name",
        invoker.custom_package,
      ]
    }
    if (defined(invoker.r_text)) {
      args += [
        "--r-text-path",
        rebase_path(invoker.r_text, root_build_dir),
      ]
    }
    if (defined(invoker.res_size_info_path)) {
      args += [
        "--res-size-info",
        rebase_path(invoker.res_size_info_path, root_build_dir),
      ]
    }
    if (defined(invoker.res_sources_path)) {
      _res_sources_path = rebase_path(invoker.res_sources_path, root_build_dir)
      args += [ "--res-sources-path=$_res_sources_path" ]
    }
    if (defined(invoker.proto_resources_path)) {
      _rebased_proto_resources =
          rebase_path(invoker.proto_resources_path, root_build_dir)
      args += [ "--apk-proto-resources=$_rebased_proto_resources" ]
    }
    if (defined(invoker.r_text_path)) {
      _rebased_rtxt_path = rebase_path(invoker.r_text_path, root_build_dir)
      args += [ "--r-text-path=$_rebased_rtxt_path" ]
    }
    if (defined(invoker.module_pathmap_path)) {
      _rebased_pathmap_path =
          rebase_path(invoker.module_pathmap_path, root_build_dir)
      args += [ "--module-pathmap-path=$_rebased_pathmap_path" ]
    }

    if (defined(invoker.shared_libraries_runtime_deps_file)) {
      # Don't list shared_libraries_runtime_deps_file as an input in order to
      # avoid having to depend on the runtime_deps target. See comment in
      # rules.gni for why we do this.
      args += [
        "--shared-libraries-runtime-deps",
        rebase_path(invoker.shared_libraries_runtime_deps_file, root_build_dir),
      ]
    }

    if (defined(invoker.base_allowlist_rtxt_path)) {
      args += [
        "--base-allowlist-rtxt-path",
        rebase_path(invoker.base_allowlist_rtxt_path, root_build_dir),
      ]
    }

    if (defined(invoker.loadable_modules)) {
      _rebased_loadable_modules =
          rebase_path(invoker.loadable_modules, root_build_dir)
      args += [ "--loadable-modules=$_rebased_loadable_modules" ]
    }

    if (defined(invoker.secondary_abi_shared_libraries_runtime_deps_file)) {
      # Don't list secondary_abi_shared_libraries_runtime_deps_file as an
      # input in order to avoid having to depend on the runtime_deps target.
      # See comment in rules.gni for why we do this.
      args += [
        "--secondary-abi-shared-libraries-runtime-deps",
        rebase_path(invoker.secondary_abi_shared_libraries_runtime_deps_file,
                    root_build_dir),
      ]
    }

    if (defined(invoker.secondary_abi_loadable_modules) &&
        invoker.secondary_abi_loadable_modules != []) {
      _rebased_secondary_abi_loadable_modules =
          rebase_path(invoker.secondary_abi_loadable_modules, root_build_dir)
      args += [ "--secondary-abi-loadable-modules=$_rebased_secondary_abi_loadable_modules" ]
    }

    if (defined(invoker.native_lib_placeholders) &&
        invoker.native_lib_placeholders != []) {
      args += [ "--native-lib-placeholders=${invoker.native_lib_placeholders}" ]
    }

    if (defined(invoker.secondary_native_lib_placeholders) &&
        invoker.secondary_native_lib_placeholders != []) {
      args += [ "--secondary-native-lib-placeholders=${invoker.secondary_native_lib_placeholders}" ]
    }

    if (defined(invoker.library_always_compress)) {
      args += [ "--library-always-compress=${invoker.library_always_compress}" ]
    }

    if (defined(invoker.apk_path)) {
      # TODO(tiborg): Remove APK path from build config and use
      # install_artifacts from metadata instead.
      _rebased_apk_path = rebase_path(invoker.apk_path, root_build_dir)
      args += [ "--apk-path=$_rebased_apk_path" ]
      if (defined(invoker.incremental_apk_path)) {
        _rebased_incremental_apk_path =
            rebase_path(invoker.incremental_apk_path, root_build_dir)
        _rebased_incremental_install_json_path =
            rebase_path(invoker.incremental_install_json_path, root_build_dir)
        args += [
          "--incremental-install-json-path=$_rebased_incremental_install_json_path",
          "--incremental-apk-path=$_rebased_incremental_apk_path",
        ]
      }
    }

    if (defined(invoker.target_sources_file)) {
      args += [
        "--target-sources-file",
        rebase_path(invoker.target_sources_file, root_build_dir),
      ]
    }
    if (defined(invoker.srcjar)) {
      args += [
        "--srcjar",
        rebase_path(invoker.srcjar, root_build_dir),
      ]
    }
    if (defined(invoker.bundled_srcjars)) {
      _rebased_bundled_srcjars =
          rebase_path(invoker.bundled_srcjars, root_build_dir)
      args += [ "--bundled-srcjars=$_rebased_bundled_srcjars" ]
    }
    if (defined(invoker.proguard_enabled) && invoker.proguard_enabled) {
      args += [ "--proguard-enabled" ]
    }
    if (defined(invoker.proguard_mapping_path)) {
      _rebased_proguard_mapping_path =
          rebase_path(invoker.proguard_mapping_path, root_build_dir)
      args += [ "--proguard-mapping-path=$_rebased_proguard_mapping_path" ]
    }
    if (defined(invoker.input_jars_paths)) {
      _rebased_input_jars_paths =
          rebase_path(invoker.input_jars_paths, root_build_dir)
      args += [ "--extra-classpath-jars=$_rebased_input_jars_paths" ]
    }
    if (defined(invoker.low_classpath_priority) &&
        invoker.low_classpath_priority) {
      args += [ "--low-classpath-priority" ]
    }
    if (defined(invoker.mergeable_android_manifests)) {
      _rebased_mergeable_android_manifests =
          rebase_path(invoker.mergeable_android_manifests, root_build_dir)
      args += [
        "--mergeable-android-manifests=$_rebased_mergeable_android_manifests",
      ]
    }
    if (defined(invoker.proguard_configs)) {
      _rebased_proguard_configs =
          rebase_path(invoker.proguard_configs, root_build_dir)
      args += [ "--proguard-configs=$_rebased_proguard_configs" ]
    }
    if (defined(invoker.gradle_treat_as_prebuilt) &&
        invoker.gradle_treat_as_prebuilt) {
      args += [ "--gradle-treat-as-prebuilt" ]
    }
    if (defined(invoker.main_class)) {
      args += [
        "--main-class",
        invoker.main_class,
      ]
    }
    if (defined(invoker.direct_deps_only) && invoker.direct_deps_only) {
      args += [ "--direct-deps-only" ]
    }
    if (defined(invoker.use_interface_jars) && invoker.use_interface_jars) {
      args += [ "--use-interface-jars" ]
    }
    if (defined(invoker.base_module_target)) {
      _dep_label = invoker.base_module_target
      _dep_gen_dir = get_label_info(_dep_label, "target_gen_dir")
      _dep_name = get_label_info(_dep_label, "name")
      _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"
      deps += [ "$_dep_label$build_config_target_suffix" ]
      inputs += [ _dep_config ]
      args += [
        "--base-module-build-config",
        rebase_path(_dep_config, root_build_dir),
      ]
    }
    if (defined(invoker.parent_module_target)) {
      _dep_label = invoker.parent_module_target
      _dep_gen_dir = get_label_info(_dep_label, "target_gen_dir")
      _dep_name = get_label_info(_dep_label, "name")
      _dep_config = "$_dep_gen_dir/$_dep_name.build_config.json"
      deps += [ "$_dep_label$build_config_target_suffix" ]
      inputs += [ _dep_config ]
      args += [
        "--parent-module-build-config",
        rebase_path(_dep_config, root_build_dir),
      ]
    }
    if (defined(invoker.module_name)) {
      args += [
        "--module-name",
        invoker.module_name,
      ]
    }
    if (defined(invoker.modules)) {
      foreach(_module, invoker.modules) {
        if (defined(_module.uses_split)) {
          args += [ "--uses-split=${_module.name}:${_module.uses_split}" ]
        }
      }
    }
    if (defined(invoker.module_build_configs)) {
      inputs += invoker.module_build_configs
      _rebased_configs =
          rebase_path(invoker.module_build_configs, root_build_dir)
      args += [ "--module-build-configs=$_rebased_configs" ]
    }
    if (defined(invoker.add_view_trace_events) &&
        invoker.add_view_trace_events) {
      # Adding trace events involves rewriting bytecode and generating a new set
      # of jar files. In order to avoid conflicts between bundles we save the
      # new jars in a bundle specific gen/ directory. The build config for the
      # bundle, and each one of its modules need a path to a bundle specific
      # gen/ directory in order to generate a list of rewritten jar paths.
      # We use the base module's target_gen_dir because non-base modules and the
      # app bundle targets have a reference to it (base_module_target).
      if (_type == "android_app_bundle") {
        _trace_events_target_name =
            get_label_info(_parent_invoker.base_module_target, "name")
      } else if (defined(invoker.base_module_target)) {
        _trace_events_target_name =
            get_label_info(invoker.base_module_target, "name")
      } else {
        _grandparent_invoker = _parent_invoker.invoker
        _trace_events_target_name = _grandparent_invoker.target_name
      }

      # FIXME: This should likely be using the base module's target_out_dir
      #     rather than the current target's.
      args += [
        "--trace-events-jar-dir",
        rebase_path("$target_out_dir/$_trace_events_target_name",
                    root_build_dir),
      ]
    }
    if (defined(invoker.version_name)) {
      args += [
        "--version-name",
        invoker.version_name,
      ]
    }
    if (defined(invoker.version_code)) {
      args += [
        "--version-code",
        invoker.version_code,
      ]
    }
    if (defined(invoker.recursive_resource_deps) &&
        invoker.recursive_resource_deps) {
      args += [ "--recursive-resource-deps" ]
    }
    if (current_toolchain != default_toolchain) {
      # This has to be a built-time error rather than a GN assert because many
      # packages have a mix of java and non-java targets. For example, the
      # following would fail even though nothing depends on :bar(//baz):
      #
      # shared_library("foo") {
      # }
      #
      # android_library("bar") {
      #   deps = [ ":foo(//baz)" ]
      #   assert(current_toolchain == default_toolchain)
      # }
      _msg = [
        "Tried to build an Android target in a non-default toolchain.",
        "target: $_target_label",
        "current_toolchain: $current_toolchain",
        "default_toolchain: $default_toolchain",
      ]
      args += [ "--fail=$_msg" ]
    }
  }
}

template("generate_android_wrapper") {
  generate_wrapper(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    generator_script = "//build/android/gyp/generate_android_wrapper.py"
    sources = [
      "//build/android/gyp/util/build_utils.py",
      "//build/gn_helpers.py",
      "//build/util/generate_wrapper.py",
    ]
  }
}

template("generate_r_java") {
  action_with_pydeps(target_name) {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY + [ "deps" ])
    depfile = "$target_gen_dir/${invoker.target_name}.d"
    inputs = [ invoker.build_config ]
    outputs = [ invoker.srcjar_path ]
    _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
    script = "//build/android/gyp/create_r_java.py"
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--srcjar-out",
      rebase_path(invoker.srcjar_path, root_build_dir),
      "--deps-rtxts=@FileArg($_rebased_build_config:deps_info:dependency_r_txt_files)",
      "--r-package=${invoker.package}",
    ]
  }
}

# Generates a script in the build bin directory which runs the test
# target using the test runner script in build/android/test_runner.py.
template("test_runner_script") {
  testonly = true
  _test_name = invoker.test_name
  _test_type = invoker.test_type
  _is_unit_test = defined(invoker.is_unit_test) && invoker.is_unit_test
  _incremental_apk = defined(invoker.incremental_apk) && invoker.incremental_apk

  _runtime_deps =
      !defined(invoker.ignore_all_data_deps) || !invoker.ignore_all_data_deps

  if (_runtime_deps) {
    # This runtime_deps file is used at runtime and thus cannot go in
    # target_gen_dir.
    _target_dir_name = get_label_info(":$target_name", "dir")
    _runtime_deps_file =
        "$root_out_dir/gen.runtime/$_target_dir_name/$target_name.runtime_deps"
    _runtime_deps_target = "${target_name}__write_deps"
    group(_runtime_deps_target) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "deps",
                               "public_deps",
                             ])
      data_deps = []
      if (defined(invoker.apk_target)) {
        data_deps += [ invoker.apk_target ]
      }
      if (defined(invoker.data_deps)) {
        data_deps += invoker.data_deps
      }
      if (defined(invoker.apk_under_test)) {
        data_deps += [ invoker.apk_under_test ]
      }
      if (defined(invoker.additional_apks)) {
        data_deps += invoker.additional_apks
      }
      if (defined(invoker.data_deps)) {
        data_deps += invoker.data_deps
      }
      write_runtime_deps = _runtime_deps_file
    }
  }

  if (defined(invoker.apk_under_test)) {
    _install_artifacts_json =
        "${target_gen_dir}/${target_name}.install_artifacts"
    _install_artifacts_target_name = "${target_name}__install_artifacts"
    generated_file(_install_artifacts_target_name) {
      deps = [ invoker.apk_under_test ]
      output_conversion = "json"
      outputs = [ _install_artifacts_json ]
      data_keys = [ "install_artifacts" ]
      walk_keys = [ "install_artifacts_barrier" ]
      rebase = root_build_dir
    }
  }

  generate_android_wrapper(target_name) {
    forward_variables_from(invoker,
                           [
                             "assert_no_deps",
                             "metadata",
                             "public_deps",
                             "visibility",
                           ])
    wrapper_script = "$root_build_dir/bin/run_${_test_name}"

    executable = "//testing/test_env.py"

    if (defined(invoker.android_test_runner_script)) {
      _runner_script = invoker.android_test_runner_script
    } else {
      _runner_script = "//build/android/test_runner.py"
    }

    deps = []
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    data_deps = [
      "//build/android:test_runner_core_py",
      "//testing:test_scripts_shared",
    ]
    if (_test_type != "junit") {
      data_deps += [ "//build/android:test_runner_device_support" ]
    }
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
    data = []
    if (defined(invoker.data)) {
      data += invoker.data
    }

    executable_args = [
      "@WrappedPath(" + rebase_path(_runner_script, root_build_dir) + ")",
      _test_type,
      "--output-directory",
      "@WrappedPath(.)",
      "--wrapper-script-args",
    ]

    if (_is_unit_test) {
      executable_args += [ "--is-unit-test" ]
    }

    if (_runtime_deps) {
      deps += [ ":$_runtime_deps_target" ]
      data += [ _runtime_deps_file ]
      _rebased_runtime_deps_file =
          rebase_path(_runtime_deps_file, root_build_dir)
      executable_args += [
        "--runtime-deps-path",
        "@WrappedPath(${_rebased_runtime_deps_file})",
      ]
    }

    # apk_target is not used for native executable tests
    # (e.g. breakpad_unittests).
    if (defined(invoker.apk_target)) {
      assert(!defined(invoker.executable_dist_dir))
      deps += [ "${invoker.apk_target}$build_config_target_suffix" ]
      _apk_build_config =
          get_label_info(invoker.apk_target, "target_gen_dir") + "/" +
          get_label_info(invoker.apk_target, "name") + ".build_config.json"
      _rebased_apk_build_config = rebase_path(_apk_build_config, root_build_dir)
      not_needed([ "_rebased_apk_build_config" ])
    } else if (_test_type == "gtest") {
      assert(
          defined(invoker.executable_dist_dir),
          "Must define either apk_target or executable_dist_dir for test_runner_script()")
      _rebased_executable_dist_dir =
          rebase_path(invoker.executable_dist_dir, root_build_dir)
      executable_args += [
        "--executable-dist-dir",
        "@WrappedPath(${_rebased_executable_dist_dir})",
      ]
    }

    if (use_jacoco_coverage) {
      # Keep in sync with recipe constant for recipe to find coverage data
      # files from local java tests: https://bit.ly/3Zul6do
      _jacoco_coverage_dir_name = "java_coverage"
    }

    _device_test = true
    if (_test_type == "gtest") {
      assert(defined(invoker.test_suite))
      executable_args += [
        "--suite",
        invoker.test_suite,
      ]
      if (use_clang_coverage) {
        # Set a default coverage output directory (can be overridden by user
        # passing the same flag).
        _rebased_coverage_dir =
            rebase_path("$root_out_dir/coverage", root_build_dir)
        executable_args += [
          "--coverage-dir",
          "@WrappedPath(${_rebased_coverage_dir})",
        ]
      }
    } else if (_test_type == "instrumentation") {
      _test_apk = "@WrappedPath(@FileArg($_rebased_apk_build_config:deps_info:apk_path))"
      if (_incremental_apk) {
        _test_apk = "@WrappedPath(@FileArg($_rebased_apk_build_config:deps_info:incremental_apk_path))"
      }
      executable_args += [
        "--test-apk",
        _test_apk,
      ]
      if (defined(invoker.apk_under_test)) {
        if (_incremental_apk) {
          deps += [ "${invoker.apk_under_test}$build_config_target_suffix" ]
          _apk_under_test_build_config =
              get_label_info(invoker.apk_under_test, "target_gen_dir") + "/" +
              get_label_info(invoker.apk_under_test, "name") +
              ".build_config.json"
          _rebased_apk_under_test_build_config =
              rebase_path(_apk_under_test_build_config, root_build_dir)
          _apk_under_test = "@WrappedPath(@FileArg($_rebased_apk_under_test_build_config:deps_info:incremental_apk_path))"
        } else {
          deps += [ ":${_install_artifacts_target_name}" ]
          _rebased_install_artifacts_json =
              rebase_path(_install_artifacts_json, root_build_dir)
          _apk_under_test =
              "@WrappedPath(@FileArg($_rebased_install_artifacts_json[]))"
        }
        executable_args += [
          "--apk-under-test",
          _apk_under_test,
        ]
      }
      if (defined(invoker.use_webview_provider)) {
        deps += [ "${invoker.use_webview_provider}$build_config_target_suffix" ]
        _build_config =
            get_label_info(invoker.use_webview_provider, "target_gen_dir") +
            "/" + get_label_info(invoker.use_webview_provider, "name") +
            ".build_config.json"
        _rebased_build_config = rebase_path(_build_config, root_build_dir)
        executable_args += [
          "--use-webview-provider",
          "@WrappedPath(@FileArg($_rebased_build_config:deps_info:apk_path))",
        ]
      }
      if (defined(invoker.proguard_mapping_path)) {
        if (_incremental_apk) {
          not_needed(invoker, [ "proguard_mapping_path" ])
        } else {
          data += [ invoker.proguard_mapping_path ]
          _rebased_mapping_path =
              rebase_path(invoker.proguard_mapping_path, root_build_dir)
          executable_args += [
            "--proguard-mapping-path",
            "@WrappedPath($_rebased_mapping_path)",
          ]
        }
      }
      if (use_jacoco_coverage) {
        # Set a default coverage output directory (can be overridden by user
        # passing the same flag).
        _rebased_coverage_dir =
            rebase_path("$root_out_dir/$_jacoco_coverage_dir_name",
                        root_build_dir)
        executable_args += [
          "--coverage-dir",
          "@WrappedPath(${_rebased_coverage_dir})",
        ]
      }
    } else if (_test_type == "junit") {
      assert(defined(invoker.test_suite))
      _device_test = false
      executable_args += [
        "--test-suite",
        invoker.test_suite,
        "--native-libs-dir",
        "@WrappedPath($_robolectric_libs_dir)",
      ]

      # Test runner uses this generated wrapper script.
      data += [ "$root_build_dir/bin/helper/${invoker.test_suite}" ]

      deps += [ ":${invoker.test_suite}$build_config_target_suffix" ]

      _rebased_robolectric_runtime_deps_dir =
          rebase_path("//third_party/robolectric/cipd/lib", root_build_dir)
      _rebased_resource_apk = rebase_path(invoker.resource_apk, root_build_dir)
      executable_args += [
        "--resource-apk",
        "@WrappedPath(${_rebased_resource_apk})",
        "--robolectric-runtime-deps-dir",
        "@WrappedPath(${_rebased_robolectric_runtime_deps_dir})",
      ]
      if (build_with_chromium) {
        _allowlist = "//testing/android/junit/shadows-allowlist.txt"
        data += [ _allowlist ]
        _rebased_allowlist = rebase_path(_allowlist, root_build_dir)
        executable_args += [
          "--shadows-allowlist",
          "@WrappedPath($_rebased_allowlist)",
        ]
      }
      if (use_jacoco_coverage) {
        # Set a default coverage output directory (can be overridden by user
        # passing the same flag).
        _rebased_coverage_dir =
            rebase_path("$root_out_dir/$_jacoco_coverage_dir_name",
                        root_build_dir)
        executable_args += [
          "--coverage-dir",
          "@WrappedPath(${_rebased_coverage_dir})",
        ]
      }
    } else if (_test_type == "linker") {
      executable_args += [
        "--test-apk",
        "@WrappedPath(@FileArg($_rebased_apk_build_config:deps_info:apk_path))",
      ]
    } else {
      assert(false, "Invalid test type: $_test_type.")
    }

    # Devil does not reliably work with component builds of its tools.
    # There's no benefit to them, so fall back to prebuilts for component builds.
    # https://crbug.com/1404180
    if (_test_type != "junit" && !is_component_build) {
      executable_args += [ "--use-local-devil-tools" ]
    }

    if (defined(invoker.additional_apks)) {
      foreach(additional_apk, invoker.additional_apks) {
        deps += [ "$additional_apk$build_config_target_suffix" ]
        _build_config =
            get_label_info(additional_apk, "target_gen_dir") + "/" +
            get_label_info(additional_apk, "name") + ".build_config.json"
        _rebased_build_config = rebase_path(_build_config, root_build_dir)
        executable_args += [
          "--additional-apk",
          "@WrappedPath(@FileArg($_rebased_build_config:deps_info:apk_path))",
        ]
      }
    }
    if (defined(invoker.shard_timeout)) {
      executable_args += [ "--shard-timeout=${invoker.shard_timeout}" ]
    }
    if (_incremental_apk) {
      executable_args += [
        "--test-apk-incremental-install-json",
        "@WrappedPath(@FileArg($_rebased_apk_build_config:deps_info:incremental_install_json_path))",
      ]
      if (defined(invoker.apk_under_test)) {
        executable_args += [
          "--apk-under-test-incremental-install-json",
          "@WrappedPath(@FileArg($_rebased_apk_under_test_build_config:deps_info:incremental_install_json_path))",
        ]
      }
      executable_args += [ "--fast-local-dev" ]
    }
    if (_device_test && is_asan) {
      executable_args += [ "--timeout-scale=4" ]
    }

    if (defined(invoker.modules)) {
      foreach(module, invoker.modules) {
        executable_args += [
          "--module",
          module,
        ]
      }
    }

    if (defined(invoker.fake_modules)) {
      foreach(fake_module, invoker.fake_modules) {
        executable_args += [
          "--fake-module",
          fake_module,
        ]
      }
    }

    if (defined(invoker.additional_locales)) {
      foreach(locale, invoker.additional_locales) {
        executable_args += [
          "--additional-locale",
          locale,
        ]
      }
    }

    if (defined(invoker.extra_args)) {
      executable_args += invoker.extra_args
    }
  }
}

if (enable_java_templates) {
  template("android_lint") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

      # https://crbug.com/1098752 Fix for bot OOM (https://crbug.com/1098333).
      if (defined(java_cmd_pool_size)) {
        pool = "//build/config/android:java_cmd_pool($default_toolchain)"
      } else {
        pool = "//build/toolchain:link_pool($default_toolchain)"
      }

      # Lint requires generated sources and generated resources from the build.
      # Turbine __header targets depend on all generated sources, and the
      # __assetres targets depend on all generated resources.
      deps = []
      if (defined(invoker.deps)) {
        _lib_deps =
            filter_exclude(filter_include(invoker.deps, java_library_patterns),
                           java_resource_patterns)
        foreach(_lib_dep, _lib_deps) {
          # Expand //foo/java -> //foo/java:java
          _lib_dep = get_label_info(_lib_dep, "label_no_toolchain")
          deps += [
            "${_lib_dep}__assetres",
            "${_lib_dep}__header",
          ]
        }

        # Keep non-java deps as they may generate files used only by lint.
        # e.g. generated suppressions.xml files.
        deps += filter_exclude(invoker.deps, _lib_deps)
      }

      if (defined(invoker.min_sdk_version)) {
        _min_sdk_version = invoker.min_sdk_version
      } else {
        _min_sdk_version = default_min_sdk_version
      }

      if (defined(invoker.lint_jar_path)) {
        _lint_jar_path = invoker.lint_jar_path
      } else {
        _lint_jar_path = _default_lint_jar_path
      }

      # It is not safe to run two lint versions concurrently since they will
      # wipe the cache on version mismatch. When using a non-default lint
      # version, make each target use their own cache directory.
      _use_custom_cache_dir = _lint_jar_path != _default_lint_jar_path

      # Save generated xml files in a consistent location for debugging.
      if (defined(invoker.lint_gen_dir)) {
        _lint_gen_dir = invoker.lint_gen_dir
      } else {
        _lint_gen_dir = "$target_gen_dir/$target_name"
      }
      _backported_methods = "//third_party/r8/backported_methods.txt"

      script = "//build/android/gyp/lint.py"
      depfile = "$target_gen_dir/$target_name.d"
      inputs = java_paths_for_inputs + [
                 _lint_jar_path,
                 _custom_lint_jar_path,
                 _backported_methods,
               ]

      args = [
        "--target-name",
        get_label_info(":${target_name}", "label_no_toolchain"),
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--lint-jar-path",
        rebase_path(_lint_jar_path, root_build_dir),
        "--custom-lint-jar-path",
        rebase_path(_custom_lint_jar_path, root_build_dir),
        "--lint-gen-dir",
        rebase_path(_lint_gen_dir, root_build_dir),
        "--android-sdk-version=${lint_android_sdk_version}",
        "--min-sdk-version=$_min_sdk_version",
        "--android-sdk-root",
        rebase_path(lint_android_sdk_root, root_build_dir),
        "--backported-methods",
        rebase_path(_backported_methods, root_build_dir),
      ]

      if (!_use_custom_cache_dir) {
        _cache_dir = "$root_build_dir/android_lint_cache"
        _create_cache_stamp_path = "$_cache_dir/build.lint.stamp"

        # By default, lint.py will use "$_lint_gen_dir/cache".
        args += [
          "--cache-dir",
          rebase_path(_cache_dir, root_build_dir),
        ]
      }

      if (defined(invoker.skip_build_server) && invoker.skip_build_server) {
        # Nocompile tests need lint to fail through ninja.
        args += [ "--skip-build-server" ]
      } else if (android_static_analysis == "build_server") {
        args += [ "--use-build-server" ]
      }

      if (defined(invoker.lint_suppressions_file)) {
        inputs += [ invoker.lint_suppressions_file ]

        args += [
          "--config-path",
          rebase_path(invoker.lint_suppressions_file, root_build_dir),
        ]
      }

      if (defined(invoker.manifest_package)) {
        args += [ "--manifest-package=${invoker.manifest_package}" ]
      }

      if (treat_warnings_as_errors) {
        args += [ "--warnings-as-errors" ]
      }

      if (defined(invoker.lint_baseline_file)) {
        if (compute_inputs_for_analyze) {
          # The baseline file is included in lint.py as a depfile dep. Since
          # removing it regenerates the file, it is useful to not have this as
          # a gn input during local development. Add it only for bots' analyze.
          inputs += [ invoker.lint_baseline_file ]
        }
        args += [
          # Baseline allows us to turn on lint warnings without fixing all the
          # pre-existing issues. This stops the flood of new issues while the
          # existing ones are being fixed.
          "--baseline",
          rebase_path(invoker.lint_baseline_file, root_build_dir),
        ]
      }

      if (defined(invoker.create_cache) && invoker.create_cache) {
        # Putting the stamp file in the cache dir allows us to depend on ninja
        # to create the cache dir for us.
        args += [ "--create-cache" ]
        _stamp_path = _create_cache_stamp_path
      } else {
        _stamp_path = "$target_out_dir/$target_name/build.lint.stamp"
        deps += [ invoker.build_config_dep ]
        if (!_use_custom_cache_dir) {
          deps += [ "//build/android:prepare_android_lint_cache" ]
          inputs += [ _create_cache_stamp_path ]
        }
        inputs += [ invoker.build_config ]
        _rebased_build_config =
            rebase_path(invoker.build_config, root_build_dir)

        args += [
          "--manifest-path=@FileArg($_rebased_build_config:deps_info:lint_android_manifest)",
          "--extra-manifest-paths=@FileArg($_rebased_build_config:deps_info:lint_extra_android_manifests)",

          # Lint requires all source and all resource files to be passed in the
          # same invocation for checks like UnusedResources.
          "--sources=@FileArg($_rebased_build_config:deps_info:lint_sources)",
          "--aars=@FileArg($_rebased_build_config:deps_info:lint_aars)",
          "--srcjars=@FileArg($_rebased_build_config:deps_info:lint_srcjars)",
          "--resource-sources=@FileArg($_rebased_build_config:deps_info:lint_resource_sources)",
          "--resource-zips=@FileArg($_rebased_build_config:deps_info:lint_resource_zips)",

          # The full classpath is required for annotation checks like @IntDef.
          "--classpath=@FileArg($_rebased_build_config:deps_info:javac_full_interface_classpath)",
        ]
      }

      outputs = [ _stamp_path ]
      args += [
        "--stamp",
        rebase_path(_stamp_path, root_build_dir),
      ]
    }
  }

  template("trace_references") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [ "public_deps" ])
      script = "//build/android/gyp/tracereferences.py"
      inputs = java_paths_for_inputs + [
                 _r8_path,
                 invoker.tracerefs_json,
               ]
      depfile = "$target_gen_dir/$target_name.d"
      outputs = [ "$target_out_dir/$target_name.tracereferences.stamp" ]
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--tracerefs-json",
        rebase_path(invoker.tracerefs_json, root_build_dir),
        "--stamp",
        rebase_path(outputs[0], root_build_dir),
      ]
      if (android_static_analysis == "build_server") {
        args += [ "--use-build-server" ]
      }
      if (treat_warnings_as_errors) {
        args += [ "--warnings-as-errors" ]
      }
    }
  }

  template("proguard") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    _script = "//build/android/gyp/proguard.py"
    _deps = invoker.deps

    _inputs = java_paths_for_inputs + [
                invoker.build_config,
                _r8_path,
                _custom_r8_path,
              ]
    if (defined(invoker.inputs)) {
      _inputs += invoker.inputs
    }
    if (defined(invoker.proguard_mapping_path)) {
      _mapping_path = invoker.proguard_mapping_path
    } else {
      _mapping_path = "${invoker.output_path}.mapping"
    }

    _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)

    # This is generally the apk name, and serves to identify the mapping
    # file that would be required to deobfuscate a stacktrace.
    _mapping_basename = get_path_info(_mapping_path, "name")
    _version_code = "@FileArg($_rebased_build_config:deps_info:version_code)"
    _package_name = "@FileArg($_rebased_build_config:deps_info:package_name)"
    if (defined(invoker.package_name)) {
      _package_name = invoker.package_name
    }
    if (defined(invoker.version_code)) {
      _version_code = invoker.version_code
    }

    # The Mapping ID is parsed to when uploading mapping files.
    # See: https://crbug.com/1417308
    _source_file_template =
        "chromium-$_mapping_basename-$android_channel-$_version_code"

    _args = [
      "--min-api=${invoker.min_sdk_version}",
      "--mapping-output",
      rebase_path(_mapping_path, root_build_dir),
      "--sdk-jars",
      "@FileArg($_rebased_build_config:android:sdk_jars)",
      "--sdk-extension-jars",
      "@FileArg($_rebased_build_config:deps_info:proguard_classpath_jars)",
      "--r8-path",
      rebase_path(_r8_path, root_build_dir),
      "--custom-r8-path",
      rebase_path(_custom_r8_path, root_build_dir),
      "--package-name=$_package_name",
      "--source-file",
      _source_file_template,
      "--proguard-configs=@FileArg($_rebased_build_config:deps_info:proguard_all_configs)",
    ]
    if (treat_warnings_as_errors) {
      _args += [ "--warnings-as-errors" ]
    }

    if ((!defined(invoker.proguard_enable_obfuscation) ||
         invoker.proguard_enable_obfuscation) && enable_proguard_obfuscation) {
      _args += [ "--enable-obfuscation" ]
    }
    if (defined(invoker.repackage_classes)) {
      _args += [ "--repackage-classes=" + invoker.repackage_classes ]
    }
    if (defined(invoker.apply_mapping)) {
      _inputs += [ invoker.apply_mapping ]
      _rebased_apply_mapping_path =
          rebase_path(invoker.apply_mapping, root_build_dir)
      args += [ "--apply-mapping=$_rebased_apply_mapping_path" ]
    }

    if (defined(invoker.proguard_configs)) {
      _inputs += invoker.proguard_configs
      _rebased_proguard_configs =
          rebase_path(invoker.proguard_configs, root_build_dir)
      _args += [ "--proguard-configs=$_rebased_proguard_configs" ]
    }

    if (defined(invoker.modules)) {
      foreach(_feature_module, invoker.modules) {
        _rebased_module_build_config =
            rebase_path(_feature_module.build_config, root_build_dir)
        _args += [
          "--feature-name=${_feature_module.name}",
          "--dex-dest=@FileArg($_rebased_module_build_config:final_dex:path)",
        ]

        # The bundle's build config has the correct classpaths - the individual
        # modules' build configs may double-use some jars.
        if (defined(invoker.add_view_trace_events) &&
            invoker.add_view_trace_events) {
          _args += [ "--feature-jars=@FileArg($_rebased_build_config:modules:${_feature_module.name}:trace_event_rewritten_device_classpath)" ]
        } else {
          _args += [ "--feature-jars=@FileArg($_rebased_build_config:modules:${_feature_module.name}:device_classpath)" ]
        }

        if (defined(_feature_module.uses_split)) {
          _args += [ "--uses-split=${_feature_module.name}:${_feature_module.uses_split}" ]
        }
        _deps += [ _feature_module.build_config_target ]
      }
      _stamp = "${target_gen_dir}/${target_name}.r8.stamp"
      _outputs = [ _stamp ]
      _output_arg = [
        "--stamp",
        rebase_path(_stamp, root_build_dir),
      ]
    } else {
      # We don't directly set the output arg on the _args variable since it is
      # shared with the expectation target that uses its own stamp file and
      # does not take an --output-path.
      _output_arg = [
        "--output-path",
        rebase_path(invoker.output_path, root_build_dir),
      ]
      _outputs = [ invoker.output_path ]
    }
    _outputs += [ _mapping_path ]

    _enable_checks = !defined(invoker.enable_proguard_checks) ||
                     invoker.enable_proguard_checks
    if (!_enable_checks) {
      _args += [ "--disable-checks" ]
    }

    _ignore_desugar_missing_deps =
        defined(invoker.ignore_desugar_missing_deps) &&
        invoker.ignore_desugar_missing_deps
    if (!_ignore_desugar_missing_deps) {
      _args += [ "--show-desugar-default-interface-warnings" ]
    }

    if (defined(invoker.custom_assertion_handler)) {
      _args += [
        "--assertion-handler",
        invoker.custom_assertion_handler,
      ]
    } else if (enable_java_asserts) {
      # The default for generating dex file format is
      # --force-disable-assertions.
      _args += [ "--force-enable-assertions" ]
    }

    if (defined(invoker.args)) {
      _args += invoker.args
    }

    if (defined(invoker.expected_proguard_config)) {
      _expectations_target =
          "${invoker.top_target_name}_validate_proguard_config"
      action_with_pydeps(_expectations_target) {
        script = _script

        # Need to depend on all deps so that proguard.txt within .aar files get
        # extracted.
        deps = _deps
        depfile = "${target_gen_dir}/${target_name}.d"
        inputs = [
          invoker.build_config,
          invoker.expected_proguard_config,
        ]
        _actual_file = "$target_gen_dir/$target_name.proguard_configs"
        _failure_file =
            "$expectations_failure_dir/" +
            string_replace(invoker.expected_proguard_config, "/", "_")
        outputs = [
          _actual_file,
          _failure_file,
        ]
        args = _args + [
                 "--depfile",
                 rebase_path(depfile, root_build_dir),
                 "--failure-file",
                 rebase_path(_failure_file, root_build_dir),
                 "--expected-file",
                 rebase_path(invoker.expected_proguard_config, root_build_dir),
                 "--actual-file",
                 rebase_path(_actual_file, root_build_dir),
                 "--only-verify-expectations",
               ]
        if (defined(invoker.expected_proguard_config_base)) {
          inputs += [ invoker.expected_proguard_config_base ]
          args += [
            "--expected-file-base",
            rebase_path(invoker.expected_proguard_config_base, root_build_dir),
          ]
        }
        if (fail_on_android_expectations) {
          args += [ "--fail-on-expectations" ]
        }
      }
      _deps += [ ":$_expectations_target" ]
    }

    if (_enable_checks) {
      _tracerefs_json = "$target_gen_dir/$target_name.tracerefs.json"
      _proguard_target_name = "${target_name}__r8"
    } else {
      _proguard_target_name = target_name
    }
    action_with_pydeps(_proguard_target_name) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "data_deps",
                               "public_deps",
                             ])
      script = _script
      deps = _deps
      inputs = _inputs
      outputs = _outputs
      depfile = "${target_gen_dir}/${target_name}.d"
      args = _args + _output_arg + [
               "--depfile",
               rebase_path(depfile, root_build_dir),
             ]
      if (_enable_checks) {
        outputs += [ _tracerefs_json ]
        args += [
          "--tracerefs-json",
          rebase_path(_tracerefs_json, root_build_dir),
        ]
      }

      # http://crbug.com/725224. Fix for bots running out of memory.
      if (defined(java_cmd_pool_size)) {
        pool = "//build/config/android:java_cmd_pool($default_toolchain)"
      } else {
        pool = "//build/toolchain:link_pool($default_toolchain)"
      }
    }

    if (_enable_checks) {
      trace_references(target_name) {
        tracerefs_json = _tracerefs_json
        public_deps = [ ":$_proguard_target_name" ]
      }
    }
  }

  # Generates a script in the build bin directory to run a java binary.
  #
  # Variables
  #   main_class: The class containing the program entry point.
  #   build_config: Path to .build_config.json for the jar (contains classpath).
  #   script_name: Name of the script to generate.
  #   wrapper_script_args: List of extra arguments to pass to the executable.
  #   tiered_stop_at_level_one: Whether to pass --tiered-stop-at-level-one
  #
  template("java_binary_script") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

      _main_class = invoker.main_class
      _build_config = invoker.build_config
      _script_name = invoker.script_name
      if (defined(invoker.max_heap_size)) {
        _max_heap_size = invoker.max_heap_size
      } else {
        _max_heap_size = "1G"
      }

      script = "//build/android/gyp/create_java_binary_script.py"
      inputs = [ _build_config ]
      _java_script = "$root_build_dir/bin/$_script_name"
      outputs = [ _java_script ]
      _rebased_build_config = rebase_path(_build_config, root_build_dir)
      args = [
        "--output",
        rebase_path(_java_script, root_build_dir),
        "--main-class",
        _main_class,
        "--classpath=@FileArg($_rebased_build_config:deps_info:host_classpath)",
        "--max-heap-size=$_max_heap_size",
      ]
      data = []
      deps = [ "//third_party/jdk:java_data" ]
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }

      if (enable_java_asserts) {
        args += [ "--enable-asserts" ]
      }
      if (use_jacoco_coverage) {
        args += [
          "--classpath",
          rebase_path(_jacoco_host_jar, root_build_dir),
        ]
        data += [ _jacoco_host_jar ]
      }
      if (defined(invoker.tiered_stop_at_level_one) &&
          invoker.tiered_stop_at_level_one) {
        args += [ "--tiered-stop-at-level-one" ]
      }
      if (defined(invoker.extra_classpath_jars)) {
        _rebased_extra_classpath_jars =
            rebase_path(invoker.extra_classpath_jars, root_build_dir)
        args += [ "--classpath=${_rebased_extra_classpath_jars}" ]
        data += invoker.extra_classpath_jars
      }
      if (defined(invoker.wrapper_script_args)) {
        args += [ "--" ] + invoker.wrapper_script_args
      }
    }
  }

  # Variables
  #   apply_mapping: The path to the ProGuard mapping file to apply.
  #   disable_incremental: Disable incremental dexing.
  template("dex") {
    _min_sdk_version = default_min_sdk_version
    if (defined(invoker.min_sdk_version)) {
      _min_sdk_version = invoker.min_sdk_version
    }
    assert(
        _min_sdk_version >= min_supported_sdk_version,
        get_label_info(":$target_name", "label_no_toolchain") + " has an unsupported min_sdk_version of $_min_sdk_version (min is $min_supported_sdk_version)")

    _proguard_enabled =
        defined(invoker.proguard_enabled) && invoker.proguard_enabled
    _is_dex_merging = defined(invoker.input_dex_filearg)
    _enable_desugar = !defined(invoker.enable_desugar) || invoker.enable_desugar
    _desugar_needs_classpath = _enable_desugar

    # It's not safe to dex merge with libraries dex'ed at higher api versions.
    assert(!_is_dex_merging || _min_sdk_version >= default_min_sdk_version)

    # For D8's backported method desugaring to work properly, the dex merge step
    # must not be set to a higher minSdkVersion than it was for the libraries.
    if (_enable_desugar && _is_dex_merging) {
      _min_sdk_version = default_min_sdk_version
    }

    assert(defined(invoker.output) ||
           (_proguard_enabled && defined(invoker.modules)))
    assert(!_proguard_enabled || !(defined(invoker.input_dex_filearg) ||
                                       defined(invoker.input_classes_filearg) ||
                                       defined(invoker.input_class_jars)),
           "Cannot explicitly set inputs when proguarding a dex.")

    # Dex merging should not also be dexing.
    assert(!(_is_dex_merging && defined(invoker.input_classes_filearg)))
    assert(!(_is_dex_merging && defined(invoker.input_class_jars)))

    assert(!(defined(invoker.apply_mapping) && !_proguard_enabled),
           "apply_mapping can only be specified if proguard is enabled.")
    if (defined(invoker.custom_assertion_handler)) {
      assert(_proguard_enabled,
             "Proguard is required to support the custom assertion handler.")
    }

    if (_desugar_needs_classpath || _proguard_enabled) {
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
    }

    if (_proguard_enabled) {
      _proguard_target_name = target_name

      proguard(_proguard_target_name) {
        forward_variables_from(invoker,
                               TESTONLY_AND_VISIBILITY + [
                                     "add_view_trace_events",
                                     "apply_mapping",
                                     "build_config",
                                     "custom_assertion_handler",
                                     "data",
                                     "data_deps",
                                     "deps",
                                     "enable_proguard_checks",
                                     "expected_proguard_config",
                                     "expected_proguard_config_base",
                                     "ignore_desugar_missing_deps",
                                     "inputs",
                                     "modules",
                                     "package_name",
                                     "proguard_configs",
                                     "proguard_enable_obfuscation",
                                     "proguard_mapping_path",
                                     "proguard_sourcefile_suffix",
                                     "repackage_classes",
                                     "top_target_name",
                                     "version_code",
                                   ])
        min_sdk_version = _min_sdk_version

        args = []
        if (defined(invoker.has_apk_under_test) && invoker.has_apk_under_test) {
          args += [ "--input-paths=@FileArg($_rebased_build_config:deps_info:device_classpath_extended)" ]
        } else if (defined(invoker.add_view_trace_events) &&
                   invoker.add_view_trace_events && defined(invoker.modules)) {
          args += [ "--input-paths=@FileArg($_rebased_build_config:deps_info:trace_event_rewritten_device_classpath)" ]
        } else {
          args += [ "--input-paths=@FileArg($_rebased_build_config:deps_info:device_classpath)" ]
        }
        if (defined(invoker.proguard_args)) {
          args += invoker.proguard_args
        }

        if (defined(invoker.output)) {
          output_path = invoker.output
        } else if (!defined(proguard_mapping_path)) {
          proguard_mapping_path = "$target_out_dir/$target_name.mapping"
        }
      }
    } else {  # !_proguard_enabled
      _is_library = defined(invoker.is_library) && invoker.is_library
      assert(!(defined(invoker.input_classes_filearg) && _is_library))
      assert(_is_library == defined(invoker.unprocessed_jar_path))
      _input_class_jars = []
      if (defined(invoker.input_class_jars)) {
        _input_class_jars = invoker.input_class_jars
      }
      _deps = invoker.deps

      if (_input_class_jars != []) {
        _rebased_input_class_jars =
            rebase_path(_input_class_jars, root_build_dir)
      }

      action_with_pydeps(target_name) {
        forward_variables_from(invoker,
                               TESTONLY_AND_VISIBILITY + [
                                     "data",
                                     "data_deps",
                                   ])
        script = "//build/android/gyp/dex.py"
        deps = _deps
        depfile = "$target_gen_dir/$target_name.d"
        outputs = [ invoker.output ]
        inputs = [
                   "$android_sdk/optional/android.test.base.jar",
                   "$android_sdk/optional/org.apache.http.legacy.jar",
                   "//third_party/jdk/current/bin/java",
                   _custom_d8_path,
                   _d8_path,
                   android_sdk_jar,
                   invoker.build_config,
                 ] + java_paths_for_inputs
        if (defined(invoker.inputs)) {
          inputs += invoker.inputs
        }

        if (!_is_library) {
          # http://crbug.com/725224. Fix for bots running out of memory.
          if (defined(java_cmd_pool_size)) {
            pool = "//build/config/android:java_cmd_pool($default_toolchain)"
          } else {
            pool = "//build/toolchain:link_pool($default_toolchain)"
          }
        }

        args = [
          "--depfile",
          rebase_path(depfile, root_build_dir),
          "--output",
          rebase_path(invoker.output, root_build_dir),
          "--min-api=$_min_sdk_version",
          "--r8-jar-path",
          rebase_path(_d8_path, root_build_dir),
          "--custom-d8-jar-path",
          rebase_path(_custom_d8_path, root_build_dir),

          # Uncomment when rebuilding custom_d8.jar.
          #"--skip-custom-d8",
        ]
        if (treat_warnings_as_errors) {
          args += [ "--warnings-as-errors" ]
        }

        if (enable_incremental_d8 && !(defined(invoker.disable_incremental) &&
                                       invoker.disable_incremental)) {
          # Don't use incremental dexing for ProGuarded inputs as a precaution.
          args += [
            "--incremental-dir",
            rebase_path("$target_out_dir/$target_name", root_build_dir),
          ]
        }
        if (_is_library) {
          args += [ "--library" ]
        }
        if (defined(invoker.input_dex_filearg)) {
          args += [ "--dex-inputs-filearg=${invoker.input_dex_filearg}" ]
        }
        if (defined(invoker.input_classes_filearg)) {
          args += [ "--class-inputs-filearg=${invoker.input_classes_filearg}" ]

          # Required for the same reason as unprocessed_jar_path is added to
          # classpath (see note below).
          args += [ "--classpath=${invoker.input_classes_filearg}" ]
        }
        if (_input_class_jars != []) {
          inputs += _input_class_jars
          args += [ "--class-inputs=${_rebased_input_class_jars}" ]
        }

        # Never compile intemediates with --release in order to:
        # 1) not require recompiles when toggling is_java_debug,
        # 2) allow incremental_install=1 to still have local variable
        #    information even when is_java_debug=false.
        if (!is_java_debug && !_is_library) {
          args += [ "--release" ]
        }

        if (_enable_desugar) {
          args += [ "--desugar" ]

          _ignore_desugar_missing_deps =
              defined(invoker.ignore_desugar_missing_deps) &&
              invoker.ignore_desugar_missing_deps
          if (!_ignore_desugar_missing_deps) {
            args += [ "--show-desugar-default-interface-warnings" ]
          }
        }
        if (_desugar_needs_classpath) {
          # Cannot use header jar for the active jar, because it does not
          # contain anonymous classes. https://crbug.com/1342018#c5
          # Cannot use processed .jar here because it might have classes
          # filtered out via jar_excluded_patterns.
          # Must come first in classpath in order to take precedence over
          # deps that defined the same classes (via jar_excluded_patterns).
          if (defined(invoker.unprocessed_jar_path)) {
            args += [
              "--classpath",
              rebase_path(invoker.unprocessed_jar_path, root_build_dir),

              # Pass the full classpath to find new dependencies that are not in
              # the .desugardeps file.
              "--classpath=@FileArg($_rebased_build_config:deps_info:javac_full_interface_classpath)",
            ]
            inputs += [ invoker.unprocessed_jar_path ]
          }
          _desugar_dependencies_path =
              "$target_gen_dir/$target_name.desugardeps"
          args += [
            "--desugar-dependencies",
            rebase_path(_desugar_dependencies_path, root_build_dir),
            "--bootclasspath=@FileArg($_rebased_build_config:android:sdk_jars)",
          ]
        }

        if (defined(invoker.custom_assertion_handler)) {
          args += [
            "--assertion-handler",
            invoker.custom_assertion_handler,
          ]
        } else if (enable_java_asserts) {
          # The default for generating dex file format is
          # --force-disable-assertions.
          args += [ "--force-enable-assertions" ]
        }
      }
    }
  }

  template("jacoco_instr") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "deps",
                                   "public_deps",
                                 ])

      # The name needs to match the SOURCES_JSON_FILES_SUFFIX in
      # generate_coverage_metadata_for_java.py.
      _sources_json_file = "$target_out_dir/${target_name}__jacoco_sources.json"
      _jacococli_jar = "//third_party/jacoco/cipd/lib/jacococli.jar"

      script = "//build/android/gyp/jacoco_instr.py"
      inputs = invoker.source_files + java_paths_for_inputs + [
                 _jacococli_jar,
                 invoker.input_jar_path,
               ]
      outputs = [
        _sources_json_file,
        invoker.output_jar_path,
      ]
      args = [
        "--root-build-dir",
        root_build_dir,
        "--input-path",
        rebase_path(invoker.input_jar_path, root_build_dir),
        "--output-path",
        rebase_path(invoker.output_jar_path, root_build_dir),
        "--sources-json-file",
        rebase_path(_sources_json_file, root_build_dir),
        "--target-sources-file",
        rebase_path(invoker.target_sources_file, root_build_dir),
        "--jacococli-jar",
        rebase_path(_jacococli_jar, root_build_dir),
      ]
      if (coverage_instrumentation_input_file != "") {
        args += [
          "--files-to-instrument",
          rebase_path(coverage_instrumentation_input_file, root_build_dir),
        ]
      }
    }
  }

  template("filter_jar") {
    action_with_pydeps(target_name) {
      script = "//build/android/gyp/filter_zip.py"
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "deps",
                                   "data",
                                   "data_deps",
                                 ])
      inputs = [ invoker.input_jar ]
      if (defined(invoker.inputs)) {
        inputs += invoker.inputs
      }
      outputs = [ invoker.output_jar ]

      _jar_excluded_patterns = []
      if (defined(invoker.jar_excluded_patterns)) {
        _jar_excluded_patterns = invoker.jar_excluded_patterns
      }
      _jar_included_patterns = []
      if (defined(invoker.jar_included_patterns)) {
        _jar_included_patterns = invoker.jar_included_patterns
      }
      args = [
        "--input",
        rebase_path(invoker.input_jar, root_build_dir),
        "--output",
        rebase_path(invoker.output_jar, root_build_dir),
        "--exclude-globs=${_jar_excluded_patterns}",
        "--include-globs=${_jar_included_patterns}",
      ]
    }
  }

  template("process_java_library") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

    _previous_output_jar = invoker.input_jar_path

    if (invoker.jacoco_instrument) {
      _filter_jar_target_name = "${target_name}__filter_jar"
      _filter_jar_output_jar = "$target_out_dir/$target_name.filter.jar"
    } else {
      _filter_jar_target_name = target_name
      _filter_jar_output_jar = invoker.output_jar_path
    }

    filter_jar(_filter_jar_target_name) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "data_deps",
                               "jar_excluded_patterns",
                               "jar_included_patterns",
                             ])
      deps = invoker.deps
      input_jar = _previous_output_jar
      output_jar = _filter_jar_output_jar
    }

    if (invoker.jacoco_instrument) {
      # Jacoco must run after desugar (or else desugar sometimes fails).
      # It must run after filtering to avoid the same (filtered) class mapping
      # to multiple .jar files.
      # We run offline code coverage processing here rather than with a
      # javaagent as the desired coverage data was not being generated.
      # See crbug.com/1097815.
      jacoco_instr(target_name) {
        deps = [ ":$_filter_jar_target_name" ] + invoker.deps
        forward_variables_from(invoker,
                               [
                                 "source_files",
                                 "target_sources_file",
                               ])

        input_jar_path = _filter_jar_output_jar
        output_jar_path = invoker.output_jar_path
      }
    }
  }

  template("check_for_missing_direct_deps") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "data_deps",
                                   "deps",
                                 ])
      script = "//build/android/gyp/check_for_missing_direct_deps.py"
      inputs = java_paths_for_inputs + [
                 invoker.build_config,
                 invoker.input_jar,
               ]
      depfile = "$target_gen_dir/$target_name.d"
      outputs = [ "$target_out_dir/$target_name.bytecode.stamp" ]
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--target-name",
        get_label_info(":${target_name}", "label_no_toolchain"),
        "--gn-target=${invoker.target_label}",
        "--input-jar",
        rebase_path(invoker.input_jar, root_build_dir),
        "--stamp",
        rebase_path(outputs[0], root_build_dir),
        "--chromium-output-dir",
        rebase_path(root_build_dir, root_build_dir),
        "--direct-classpath-jars=@FileArg($_rebased_build_config:javac:classpath)",
        "--full-classpath-jars=@FileArg($_rebased_build_config:deps_info:javac_full_classpath)",
        "--full-classpath-gn-targets=@FileArg($_rebased_build_config:deps_info:javac_full_classpath_targets)",
      ]
      if (auto_add_missing_java_deps) {
        args += [ "--auto-add-deps" ]
      }
      if (android_static_analysis == "build_server") {
        args += [ "--use-build-server" ]
      }
      if (invoker.include_android_sdk) {
        args += [ "--sdk-classpath-jars=@FileArg($_rebased_build_config:android:sdk_jars)" ]
      }
      if (treat_warnings_as_errors) {
        args += [ "--warnings-as-errors" ]
      }
    }
  }

  template("merge_manifests") {
    action_with_pydeps(target_name) {
      assert(
          invoker.min_sdk_version >= min_supported_sdk_version,
          get_label_info(":$target_name", "label_no_toolchain") + " has an unsupported min_sdk_version of ${invoker.min_sdk_version} (min is $min_supported_sdk_version)")
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY + [ "deps" ])
      script = "//build/android/gyp/merge_manifest.py"
      depfile = "$target_gen_dir/$target_name.d"

      inputs = java_paths_for_inputs + [
                 invoker.build_config,
                 invoker.input_manifest,
                 _manifest_merger_jar_path,
               ]

      outputs = [ invoker.output_manifest ]
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--manifest-merger-jar",
        rebase_path(_manifest_merger_jar_path, root_build_dir),
        "--root-manifest",
        rebase_path(invoker.input_manifest, root_build_dir),
        "--output",
        rebase_path(invoker.output_manifest, root_build_dir),
        "--extras",
        "@FileArg($_rebased_build_config:deps_info:extra_android_manifests)",
        "--min-sdk-version=${invoker.min_sdk_version}",
        "--target-sdk-version=${invoker.target_sdk_version}",
      ]

      if (defined(invoker.manifest_package)) {
        args += [ "--manifest-package=${invoker.manifest_package}" ]
      }

      if (defined(invoker.max_sdk_version)) {
        args += [ "--max-sdk-version=${invoker.max_sdk_version}" ]
      }

      if (treat_warnings_as_errors) {
        args += [ "--warnings-as-errors" ]
      }
    }
  }

  # This template is used to parse a set of resource directories and
  # create the R.txt, .srcjar and .resources.zip for it.
  #
  # Input variables:
  #   deps: Specifies the input dependencies for this target.
  #
  #   build_config: Path to the .build_config.json file corresponding to the target.
  #
  #   sources:
  #     List of input resource files.
  #
  #   custom_package: (optional)
  #     Package name for the generated R.java source file. Optional if
  #     android_manifest is not provided.
  #
  #   android_manifest: (optional)
  #     If custom_package is not provided, path to an AndroidManifest.xml file
  #     that is only used to extract a package name out of it.
  #
  #   r_text_in_path: (optional)
  #     Path to an input R.txt file to use to generate the R.java file.
  #     The default is to use 'aapt' to generate the file from the content
  #     of the resource directories.
  #
  # Output variables:
  #   resources_zip:
  #     Path to a .resources.zip that will simply contain all the
  #     input resources, collected in a single archive.
  #
  #   r_text_out_path: Path for the generated R.txt file.
  #
  template("prepare_resources") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "deps",
                                   "public_deps",
                                   "sources",
                                 ])
      script = "//build/android/gyp/prepare_resources.py"

      depfile = "$target_gen_dir/${invoker.target_name}.d"
      outputs = [
        invoker.resources_zip,
        invoker.resources_zip + ".info",
        invoker.r_text_out_path,
      ]

      inputs = [ invoker.res_sources_path ]

      _rebased_res_sources_path =
          rebase_path(invoker.res_sources_path, root_build_dir)

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--res-sources-path=$_rebased_res_sources_path",
        "--resource-zip-out",
        rebase_path(invoker.resources_zip, root_build_dir),
        "--r-text-out",
        rebase_path(invoker.r_text_out_path, root_build_dir),
      ]

      if (defined(invoker.r_text_in_path)) {
        _r_text_in_path = invoker.r_text_in_path
        inputs += [ _r_text_in_path ]
        args += [
          "--r-text-in",
          rebase_path(_r_text_in_path, root_build_dir),
        ]
      }

      if (defined(invoker.strip_drawables) && invoker.strip_drawables) {
        args += [ "--strip-drawables" ]
      }
      if (defined(invoker.allow_missing_resources) &&
          invoker.allow_missing_resources) {
        args += [ "--allow-missing-resources" ]
      }
    }
  }

  # A template that is used to compile all resources needed by a binary
  # (e.g. an android_apk or a robolectric_binary) into an intermediate .ar_
  # archive. It can also generate an associated .srcjar that contains the
  # final R.java sources for all resource packages the binary depends on.
  #
  # Input variables:
  #   android_sdk_dep: The sdk dep that these resources should compile against.
  #
  #   deps: Specifies the input dependencies for this target.
  #
  #   build_config: Path to the .build_config.json file corresponding to the target.
  #
  #   build_config_dep: Dep target to generate the .build_config.json file.
  #
  #   android_manifest: Path to root manifest for the binary.
  #
  #   version_code: (optional)
  #
  #   version_name: (optional)
  #
  #   shared_resources: (optional)
  #     If true, make all variables in each generated R.java file non-final,
  #     and provide an onResourcesLoaded() method that can be used to reset
  #     their package index at load time. Useful when the APK corresponds to
  #     a library that is loaded at runtime, like system_webview_apk or
  #     monochrome_apk.
  #
  #   app_as_shared_lib: (optional)
  #     If true, same effect as shared_resources, but also ensures that the
  #     resources can be used by the APK when it is loaded as a regular
  #     application as well. Useful for the monochrome_public_apk target
  #     which is both an application and a shared runtime library that
  #     implements the system webview feature.
  #
  #   shared_resources_allowlist: (optional)
  #     Path to an R.txt file. If provided, acts similar to shared_resources
  #     except that it restricts the list of non-final resource variables
  #     to the list from the input R.txt file. Overrides shared_resources
  #     when both are specified.
  #
  #   shared_resources_allowlist_locales: (optional)
  #     If shared_resources_allowlist is used, provide an optional list of
  #     Chromium locale names to determine which localized shared string
  #     resources to put in the final output, even if aapt_locale_allowlist
  #     is defined to a smaller subset.
  #
  #   aapt_locale_allowlist: (optional)
  #     Restrict compiled locale-dependent resources to a specific allowlist.
  #     NOTE: This is a list of Chromium locale names, not Android ones.
  #
  #   r_java_root_package_name: (optional)
  #     Short package name for this target's root R java file (ex. input of
  #     "base" would become "gen.base_module" for the root R java package name).
  #     Optional as defaults to "base".
  #
  #   resource_exclusion_regex: (optional)
  #
  #   resource_exclusion_exceptions: (optional)
  #
  #   resource_values_filter_rules: (optional)
  #
  #   png_to_webp: (optional)
  #     If true, convert all PNG resources (except 9-patch files) to WebP.
  #
  #   post_process_script: (optional)
  #
  #   package_name: (optional)
  #     Name of the package for the purpose of creating R class.
  #
  #   package_id: (optional)
  #     Use a custom package ID in resource IDs.
  #
  #   arsc_package_name: (optional)
  #     Use this package name in the arsc file rather than the package name
  #     found in the AndroidManifest.xml. Does not affect the package name
  #     used in AndroidManifest.xml.
  #
  #   resource_ids_provider_dep: (optional)
  #     Use resource IDs provided by another APK target when compiling resources
  #     (via. "aapt2 link --stable-ids")
  #
  #   override_target_sdk: (optional)
  #     Update the manifest to target this SDK
  #
  # Output variables:
  #   arsc_output: Path to output .ap_ file (optional).
  #
  #   proto_output: Path to output .proto.ap_ file (optional).
  #
  #   r_text_out_path: (optional):
  #       Path for the corresponding generated R.txt file.
  #
  #   proguard_file: (optional)
  #       Path to proguard configuration file for this apk target.
  #
  template("compile_resources") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

    _deps = invoker.deps + [ invoker.build_config_dep ]
    if (defined(invoker.android_manifest_dep)) {
      _deps += [ invoker.android_manifest_dep ]
    }

    if (defined(invoker.arsc_output)) {
      _arsc_output = invoker.arsc_output
    }
    _final_srcjar_path = "${target_gen_dir}/${target_name}.srcjar"

    _script = "//build/android/gyp/compile_resources.py"

    _target_sdk_version = invoker.target_sdk_version
    if (defined(invoker.override_target_sdk)) {
      _target_sdk_version = invoker.override_target_sdk
    }

    _common_inputs = [
      invoker.build_config,
      android_sdk_tools_bundle_aapt2,
      android_sdk_jar,

      # TODO(b/315080809#comment4): remove these files after fixing
      # build/print_python_deps.py.
      "//third_party/protobuf/python/google/__init__.py",
      "//third_party/protobuf/python/google/protobuf/__init__.py",
      "//third_party/protobuf/python/google/protobuf/compiler/__init__.py",
      "//third_party/protobuf/python/google/protobuf/compiler/plugin_pb2.py",
      "//third_party/protobuf/python/google/protobuf/descriptor.py",
      "//third_party/protobuf/python/google/protobuf/descriptor_database.py",
      "//third_party/protobuf/python/google/protobuf/descriptor_pb2.py",
      "//third_party/protobuf/python/google/protobuf/descriptor_pool.py",
      "//third_party/protobuf/python/google/protobuf/internal/__init__.py",
      "//third_party/protobuf/python/google/protobuf/internal/_parameterized.py",
      "//third_party/protobuf/python/google/protobuf/internal/api_implementation.py",
      "//third_party/protobuf/python/google/protobuf/internal/builder.py",
      "//third_party/protobuf/python/google/protobuf/internal/containers.py",
      "//third_party/protobuf/python/google/protobuf/internal/decoder.py",
      "//third_party/protobuf/python/google/protobuf/internal/descriptor_database_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/descriptor_pool_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/descriptor_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/encoder.py",
      "//third_party/protobuf/python/google/protobuf/internal/enum_type_wrapper.py",
      "//third_party/protobuf/python/google/protobuf/internal/extension_dict.py",
      "//third_party/protobuf/python/google/protobuf/internal/field_mask.py",
      "//third_party/protobuf/python/google/protobuf/internal/generator_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/import_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/import_test_package/__init__.py",
      "//third_party/protobuf/python/google/protobuf/internal/json_format_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/keywords_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/message_factory_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/message_listener.py",
      "//third_party/protobuf/python/google/protobuf/internal/message_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/proto_builder_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/python_edition_defaults.py",
      "//third_party/protobuf/python/google/protobuf/internal/python_message.py",
      "//third_party/protobuf/python/google/protobuf/internal/reflection_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/service_reflection_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/symbol_database_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/test_util.py",
      "//third_party/protobuf/python/google/protobuf/internal/testing_refleaks.py",
      "//third_party/protobuf/python/google/protobuf/internal/text_encoding_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/text_format_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/type_checkers.py",
      "//third_party/protobuf/python/google/protobuf/internal/unknown_fields_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/well_known_types.py",
      "//third_party/protobuf/python/google/protobuf/internal/well_known_types_test.py",
      "//third_party/protobuf/python/google/protobuf/internal/wire_format.py",
      "//third_party/protobuf/python/google/protobuf/internal/wire_format_test.py",
      "//third_party/protobuf/python/google/protobuf/json_format.py",
      "//third_party/protobuf/python/google/protobuf/message.py",
      "//third_party/protobuf/python/google/protobuf/message_factory.py",
      "//third_party/protobuf/python/google/protobuf/proto_builder.py",
      "//third_party/protobuf/python/google/protobuf/pyext/__init__.py",
      "//third_party/protobuf/python/google/protobuf/pyext/cpp_message.py",
      "//third_party/protobuf/python/google/protobuf/reflection.py",
      "//third_party/protobuf/python/google/protobuf/runtime_version.py",
      "//third_party/protobuf/python/google/protobuf/service.py",
      "//third_party/protobuf/python/google/protobuf/service_reflection.py",
      "//third_party/protobuf/python/google/protobuf/symbol_database.py",
      "//third_party/protobuf/python/google/protobuf/text_encoding.py",
      "//third_party/protobuf/python/google/protobuf/text_format.py",
      "//third_party/protobuf/python/google/protobuf/unknown_fields.py",
      "//third_party/protobuf/python/google/protobuf/util/__init__.py",
    ]

    _inputs = _common_inputs

    _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)

    _rebased_android_sdk_jar = rebase_path(android_sdk_jar, root_build_dir)
    _args = [
      "--include-resources=$_rebased_android_sdk_jar",
      "--aapt2-path",
      rebase_path(android_sdk_tools_bundle_aapt2, root_build_dir),
      "--dependencies-res-zips=@FileArg($_rebased_build_config:deps_info:dependency_zips)",
      "--extra-res-packages=@FileArg($_rebased_build_config:deps_info:extra_package_names)",
      "--min-sdk-version=${invoker.min_sdk_version}",
      "--target-sdk-version=${_target_sdk_version}",
      "--webp-cache-dir=obj/android-webp-cache",
    ]

    _inputs += [ invoker.android_manifest ]
    _outputs = [ _final_srcjar_path ]
    _args += [
      "--android-manifest",
      rebase_path(invoker.android_manifest, root_build_dir),
      "--srcjar-out",
      rebase_path(_final_srcjar_path, root_build_dir),
    ]
    if (defined(invoker.version_code)) {
      _args += [
        "--version-code",
        invoker.version_code,
      ]
    }
    if (defined(invoker.version_name)) {
      _args += [
        "--version-name",
        invoker.version_name,
      ]
    }
    if (defined(_arsc_output)) {
      _outputs += [ _arsc_output ]
      _args += [
        "--arsc-path",
        rebase_path(_arsc_output, root_build_dir),
      ]
    }
    if (defined(invoker.proto_output)) {
      _outputs += [ invoker.proto_output ]
      _args += [
        "--proto-path",
        rebase_path(invoker.proto_output, root_build_dir),
      ]
    }
    if (defined(invoker.size_info_path)) {
      _outputs += [ invoker.size_info_path ]
      _args += [
        "--info-path",
        rebase_path(invoker.size_info_path, root_build_dir),
      ]
    }

    if (defined(invoker.r_java_root_package_name)) {
      _args += [
        "--r-java-root-package-name",
        invoker.r_java_root_package_name,
      ]
    }

    # Useful to have android:debuggable in the manifest even for Release
    # builds. Just omit it for officai
    if (debuggable_apks) {
      _args += [ "--debuggable" ]
    }

    if (defined(invoker.r_text_out_path)) {
      _outputs += [ invoker.r_text_out_path ]
      _args += [
        "--r-text-out",
        rebase_path(invoker.r_text_out_path, root_build_dir),
      ]
    }

    if (defined(invoker.rename_manifest_package)) {
      _args += [
        "--rename-manifest-package",
        invoker.rename_manifest_package,
      ]
    }

    # Define the flags related to shared resources.
    #
    # Note the small sanity check to ensure that the package ID of the
    # generated resources table is correct. It should be 0x02 for runtime
    # shared libraries, and 0x7f otherwise.

    if (defined(invoker.shared_resources) && invoker.shared_resources) {
      _args += [ "--shared-resources" ]
    }
    if (defined(invoker.app_as_shared_lib) && invoker.app_as_shared_lib) {
      _args += [ "--app-as-shared-lib" ]
    }
    if (defined(invoker.package_id)) {
      _args += [ "--package-id=${invoker.package_id}" ]
    }
    if (defined(invoker.package_name)) {
      _args += [
        "--package-name",
        invoker.package_name,
      ]
    }
    if (defined(invoker.arsc_package_name)) {
      _args += [
        "--arsc-package-name",
        invoker.arsc_package_name,
      ]
    }

    if (defined(invoker.shared_resources_allowlist)) {
      _inputs += [ invoker.shared_resources_allowlist ]
      _args += [
        "--shared-resources-allowlist",
        rebase_path(invoker.shared_resources_allowlist, root_build_dir),
      ]
    }
    if (defined(invoker.shared_resources_allowlist_locales)) {
      _args += [ "--shared-resources-allowlist-locales=" +
                 "${invoker.shared_resources_allowlist_locales}" ]
    }

    if (!defined(testonly) || !testonly ||
        (defined(invoker.enforce_resource_overlays_in_tests) &&
         invoker.enforce_resource_overlays_in_tests)) {
      _args += [ "--dependencies-res-zip-overlays=@FileArg($_rebased_build_config:deps_info:dependency_zip_overlays)" ]
    } else {
      _args += [ "--dependencies-res-zip-overlays=@FileArg($_rebased_build_config:deps_info:dependency_zips)" ]
    }

    if (defined(invoker.proguard_file)) {
      _outputs += [ invoker.proguard_file ]
      _args += [
        "--proguard-file",
        rebase_path(invoker.proguard_file, root_build_dir),
      ]
    }

    if (defined(invoker.aapt_locale_allowlist)) {
      _args += [ "--locale-allowlist=${invoker.aapt_locale_allowlist}" ]
    }
    if (defined(invoker.png_to_webp) && invoker.png_to_webp) {
      _webp_target = "//third_party/libwebp:cwebp($host_toolchain)"
      _webp_binary = get_label_info(_webp_target, "root_out_dir") + "/cwebp"
      _deps += [ _webp_target ]
      _inputs += [ _webp_binary ]
      _args += [
        "--png-to-webp",
        "--webp-binary",
        rebase_path(_webp_binary, root_build_dir),
      ]
    }
    if (defined(invoker.resource_exclusion_regex)) {
      _args +=
          [ "--resource-exclusion-regex=${invoker.resource_exclusion_regex}" ]
      if (defined(invoker.resource_exclusion_exceptions)) {
        _args += [ "--resource-exclusion-exceptions=${invoker.resource_exclusion_exceptions}" ]
      }
    }
    if (defined(invoker.resource_values_filter_rules)) {
      _args +=
          [ "--values-filter-rules=${invoker.resource_values_filter_rules}" ]
    }

    if (defined(invoker.include_resource)) {
      _inputs += [ invoker.include_resource ]
      _rebased_include_resources =
          rebase_path(invoker.include_resource, root_build_dir)
      _args += [ "--include-resources=$_rebased_include_resources" ]
    }

    if (defined(invoker._args)) {
      _args += invoker._args
    }

    if (defined(invoker.emit_ids_out_path)) {
      _outputs += [ invoker.emit_ids_out_path ]
      _rebased_emit_ids_path =
          rebase_path(invoker.emit_ids_out_path, root_out_dir)
      _args += [ "--emit-ids-out=$_rebased_emit_ids_path" ]
    }

    if (defined(invoker.resource_ids_provider_dep)) {
      _compile_res_dep =
          "${invoker.resource_ids_provider_dep}__compile_resources"
      _gen_dir = get_label_info(_compile_res_dep, "target_gen_dir")
      _name = get_label_info(_compile_res_dep, "name")
      _resource_ids_path = "$_gen_dir/$_name.resource_ids"
      _inputs += [ _resource_ids_path ]
      _rebased_ids_path = rebase_path(_resource_ids_path, root_out_dir)
      _args += [ "--use-resource-ids-path=$_rebased_ids_path" ]
      _deps += [ _compile_res_dep ]
    }

    if (defined(invoker.max_sdk_version)) {
      _max_sdk_version = invoker.max_sdk_version
      _args += [ "--max-sdk-version=$_max_sdk_version" ]
    }

    if (defined(invoker.manifest_package)) {
      _args += [ "--manifest-package=${invoker.manifest_package}" ]
    }

    if (defined(invoker.is_bundle_module) && invoker.is_bundle_module) {
      _args += [ "--is-bundle-module" ]
    }

    if (defined(invoker.uses_split)) {
      assert(invoker.is_bundle_module)
      _args += [ "--uses-split=${invoker.uses_split}" ]
    }

    if (defined(invoker.expected_android_manifest)) {
      _expectations_target =
          "${invoker.top_target_name}_validate_android_manifest"
      action_with_pydeps(_expectations_target) {
        _actual_file = "${invoker.android_manifest}.normalized"
        _failure_file =
            "$expectations_failure_dir/" +
            string_replace(invoker.expected_android_manifest, "/", "_")
        inputs = [
                   invoker.android_manifest,
                   invoker.expected_android_manifest,
                 ] + _common_inputs
        outputs = [
          _actual_file,
          _failure_file,
        ]
        deps = [
          invoker.android_manifest_dep,
          invoker.build_config_dep,
        ]
        script = _script
        args = _args + [
                 "--expected-file",
                 rebase_path(invoker.expected_android_manifest, root_build_dir),
                 "--actual-file",
                 rebase_path(_actual_file, root_build_dir),
                 "--failure-file",
                 rebase_path(_failure_file, root_build_dir),
                 "--only-verify-expectations",
               ]
        if (defined(invoker.expected_android_manifest_base)) {
          args += [
            "--expected-file-base",
            rebase_path(invoker.expected_android_manifest_base, root_build_dir),
          ]
          inputs += [ invoker.expected_android_manifest_base ]
        }
        if (defined(invoker.expected_android_manifest_version_code_offset)) {
          args += [
            "--verification-version-code-offset",
            invoker.expected_android_manifest_version_code_offset,
          ]
        }
        if (defined(invoker.expected_android_manifest_library_version_offset)) {
          args += [
            "--verification-library-version-offset",
            invoker.expected_android_manifest_library_version_offset,
          ]
        }
        if (fail_on_android_expectations) {
          args += [ "--fail-on-expectations" ]
        }
      }
      _deps += [ ":$_expectations_target" ]
    }

    action_with_pydeps(target_name) {
      script = _script
      depfile = "$target_gen_dir/${target_name}.d"
      inputs = _inputs
      outputs = _outputs
      deps = _deps
      args = _args + [
               "--depfile",
               rebase_path(depfile, root_build_dir),
             ]
    }
  }

  # A template that is used to optimize compiled resources using aapt2 optimize.
  #
  #   proto_input_path:
  #     Path to input compiled .proto.ap_ file.
  #
  #   short_resource_paths: (optional)
  #     Rename the paths within a the apk to be randomly generated short
  #     strings to reduce binary size.
  #
  #   strip_resource_names: (optional)
  #     Strip resource names from the resources table of the apk.
  #
  #   resources_configs_paths: (optional)
  #     List of resource configs to use for optimization.
  #
  #   optimized_proto_output:
  #     Path to output optimized .proto.ap_ file.
  #
  #   resources_path_map_out_path: (optional):
  #       Path for the generated map between original resource paths and
  #       shortened resource paths.
  template("optimize_resources") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    action_with_pydeps(target_name) {
      forward_variables_from(invoker, [ "deps" ])
      script = "//build/android/gyp/optimize_resources.py"
      inputs = [
        android_sdk_tools_bundle_aapt2,
        invoker.r_text_path,
      ]
      outputs = []
      args = [
        "--aapt2-path",
        rebase_path(android_sdk_tools_bundle_aapt2, root_build_dir),
        "--r-text-in",
        rebase_path(invoker.r_text_path, root_build_dir),
      ]
      if (defined(invoker.optimized_proto_output)) {
        inputs += [ invoker.proto_input_path ]
        outputs += [ invoker.optimized_proto_output ]
        args += [
          "--input-path",
          rebase_path(invoker.proto_input_path, root_build_dir),
          "--optimized-output-path",
          rebase_path(invoker.optimized_proto_output, root_build_dir),
        ]
      } else {
        inputs += [ invoker.arsc_input_path ]
        outputs += [ invoker.optimized_arsc_output ]
        args += [
          "--input-path",
          rebase_path(invoker.arsc_input_path, root_build_dir),
          "--optimized-output-path",
          rebase_path(invoker.optimized_arsc_output, root_build_dir),
        ]
      }

      if (defined(invoker.resources_config_paths)) {
        inputs += invoker.resources_config_paths
        _rebased_resource_configs =
            rebase_path(invoker.resources_config_paths, root_build_dir)
        args += [ "--resources-config-paths=${_rebased_resource_configs}" ]
      }

      if (defined(invoker.short_resource_paths) &&
          invoker.short_resource_paths) {
        args += [ "--short-resource-paths" ]
        if (defined(invoker.resources_path_map_out_path)) {
          outputs += [ invoker.resources_path_map_out_path ]
          args += [
            "--resources-path-map-out-path",
            rebase_path(invoker.resources_path_map_out_path, root_build_dir),
          ]
        }
      }

      if (defined(invoker.strip_resource_names) &&
          invoker.strip_resource_names) {
        args += [ "--strip-resource-names" ]
      }
    }
  }

  # A template that is used to find unused resources.
  template("unused_resources") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY + [ "deps" ])
      script = "//build/android/gyp/unused_resources.py"
      depfile = "$target_gen_dir/${target_name}.d"
      _unused_resources_script = "$root_build_dir/bin/helper/unused_resources"
      inputs = [ _unused_resources_script ] + java_paths_for_inputs
      outputs = [ invoker.output_config ]
      if (!defined(deps)) {
        deps = []
      }
      deps += [ "//build/android/unused_resources:unused_resources" ]
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
      args = [
        "--script",
        rebase_path(_unused_resources_script, root_build_dir),
        "--output-config",
        rebase_path(invoker.output_config, root_build_dir),
        "--r-text-in=@FileArg($_rebased_build_config:deps_info:r_text_path)",
        "--dependencies-res-zips=@FileArg($_rebased_build_config:deps_info:dependency_zips)",
        "--depfile",
        rebase_path(depfile, root_build_dir),
      ]

      if (defined(invoker.proguard_mapping_path)) {
        inputs += [ invoker.proguard_mapping_path ]
        args += [
          "--proguard-mapping",
          rebase_path(invoker.proguard_mapping_path, root_build_dir),
        ]
      }

      if (defined(invoker.output_r_txt)) {
        outputs += [ invoker.output_r_txt ]
        args += [
          "--r-text-out",
          rebase_path(invoker.output_r_txt, root_build_dir),
        ]
      }

      if (defined(invoker.all_module_build_configs)) {
        foreach(_build_config, invoker.all_module_build_configs) {
          inputs += [ _build_config ]
          _rebased_module_build_config =
              rebase_path(_build_config, root_build_dir)
          args += [
            "--dexes=@FileArg($_rebased_module_build_config:final_dex:path)",
            "--android-manifests=@FileArg($_rebased_module_build_config:deps_info:merged_android_manifest)",
          ]
        }
      } else {
        args += [
          "--dexes=@FileArg($_rebased_build_config:final_dex:path)",
          "--android-manifests=@FileArg($_rebased_build_config:deps_info:merged_android_manifest)",
        ]
      }
    }
  }

  # Create an .jar.info file by merging several .jar.info files into one.
  #
  # Variables:
  #   build_config: Path to APK's build config file. Used to extract the
  #       list of input .jar files from its dependencies.
  #   name: Name of the apk or app bundle (e.g. "Foo.apk").
  #   res_size_info_path: Path to input .ap_.info file (for apks).
  #
  template("create_size_info_files") {
    action_with_pydeps(target_name) {
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY + [ "deps" ])
      script = "//build/android/gyp/create_size_info_files.py"
      _jar_info_path = "$root_build_dir/size-info/${invoker.name}.jar.info"
      _pak_info_path = "$root_build_dir/size-info/${invoker.name}.pak.info"
      _res_info_path = "$root_build_dir/size-info/${invoker.name}.res.info"
      outputs = [
        _jar_info_path,
        _pak_info_path,
        _res_info_path,
      ]
      depfile = "$target_gen_dir/$target_name.d"
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--jar-info-path",
        rebase_path(_jar_info_path, root_build_dir),
        "--pak-info-path",
        rebase_path(_pak_info_path, root_build_dir),
        "--res-info-path",
        rebase_path(_res_info_path, root_build_dir),
      ]
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
      inputs = [ invoker.build_config ]
      _is_bundle = defined(invoker.modules)
      if (_is_bundle) {
        foreach(_module, invoker.modules) {
          inputs += [ _module.build_config ]
          _rebased_module_build_config =
              rebase_path(_module.build_config, root_build_dir)
          args += [
            "--jar-files=@FileArg($_rebased_module_build_config:deps_info:unprocessed_jar_path)",
            "--jar-files=@FileArg($_rebased_module_build_config:deps_info:javac_full_classpath)",
            "--in-res-info-path=@FileArg($_rebased_module_build_config:deps_info:res_size_info)",
            "--uncompressed-assets=@FileArg($_rebased_module_build_config:deps_info:uncompressed_assets)",
            "--assets=@FileArg($_rebased_build_config:modules:${_module.name}:assets)",
          ]
        }
      } else {
        inputs += [ invoker.res_size_info_path ]
        args += [
          "--jar-files=@FileArg($_rebased_build_config:deps_info:unprocessed_jar_path)",
          "--jar-files=@FileArg($_rebased_build_config:deps_info:javac_full_classpath)",
          "--in-res-info-path",
          rebase_path(invoker.res_size_info_path, root_build_dir),
          "--assets=@FileArg($_rebased_build_config:deps_info:assets)",
          "--uncompressed-assets=@FileArg($_rebased_build_config:deps_info:uncompressed_assets)",
        ]
      }
    }
  }

  # Creates a signed and aligned .apk.
  #
  # Variables
  #   apk_name: (optional) APK name (without .apk suffix). If provided, will
  #       be used to generate .info files later used by the supersize tool.
  #   assets_build_config: Path to android_apk .build_config.json containing merged
  #       asset information.
  #   deps: Specifies the dependencies of this target.
  #   dex_path: Path to classes.dex file to include (optional).
  #   expected_libs_and_assets: Verify the list of included native libraries
  #     and assets is consistent with the given expectation file.
  #   expected_libs_and_assets_base: Treat expected_libs_and_assets as a diff
  #     with this file as the base.
  #   packaged_resources_path: Path to .ap_ to use.
  #   output_apk_path: Output path for the generated .apk.
  #   min_sdk_version: The minimum Android SDK version this target supports.
  #   native_lib_placeholders: List of placeholder filenames to add to the apk
  #     (optional).
  #   secondary_native_lib_placeholders: List of placeholder filenames to add to
  #     the apk for the secondary ABI (optional).
  #   loadable_modules: List of native libraries.
  #   native_libs_filearg: @FileArg() of additionally native libraries.
  #   secondary_abi_loadable_modules: (optional) List of native libraries for
  #     secondary ABI.
  #   secondary_abi_native_libs_filearg: (optional). @FileArg() of additional
  #     secondary ABI native libs.
  #   keystore_path: Path to keystore to use for signing.
  #   keystore_name: Key alias to use.
  #   keystore_password: Keystore password.
  template("package_apk") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY + [ "public_deps" ])
    _is_robolectric_apk =
        defined(invoker.is_robolectric_apk) && invoker.is_robolectric_apk
    _deps = invoker.deps
    _native_lib_placeholders = []
    if (defined(invoker.native_lib_placeholders)) {
      _native_lib_placeholders = invoker.native_lib_placeholders
    }
    _secondary_native_lib_placeholders = []
    if (defined(invoker.secondary_native_lib_placeholders)) {
      _secondary_native_lib_placeholders =
          invoker.secondary_native_lib_placeholders
    }

    _script = "//build/android/gyp/apkbuilder.py"

    _inputs = [ invoker.packaged_resources_path ]

    _outputs = [ invoker.output_apk_path ]
    _data = [ invoker.output_apk_path ]

    _rebased_compiled_resources_path =
        rebase_path(invoker.packaged_resources_path, root_build_dir)
    _rebased_packaged_apk_path =
        rebase_path(invoker.output_apk_path, root_build_dir)
    _args = [
      "--resource-apk=$_rebased_compiled_resources_path",
      "--output-apk=$_rebased_packaged_apk_path",
      "--min-sdk-version=${invoker.min_sdk_version}",
    ]

    # system_image_stub_apk does not use a build_config.json.
    if (defined(invoker.build_config)) {
      _inputs += [ invoker.build_config ]
      _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
      _args += [
        "--assets=@FileArg($_rebased_build_config:deps_info:assets)",
        "--uncompressed-assets=@FileArg($_rebased_build_config:deps_info:uncompressed_assets)",
      ]
      if (!_is_robolectric_apk) {
        _args += [ "--java-resources=@FileArg($_rebased_build_config:java_resources_jars)" ]
      }
    }
    if (defined(invoker.extra_assets)) {
      _args += [ "--assets=${invoker.extra_assets}" ]
    }
    if (!_is_robolectric_apk) {
      _apksigner = "$android_sdk_build_tools/lib/apksigner.jar"
      _zipalign = "$android_sdk_build_tools/zipalign"
      _keystore_path = android_keystore_path
      _keystore_name = android_keystore_name
      _keystore_password = android_keystore_password

      if (defined(invoker.keystore_path)) {
        _keystore_path = invoker.keystore_path
        _keystore_name = invoker.keystore_name
        _keystore_password = invoker.keystore_password
      }

      _inputs += [
        _apksigner,
        _zipalign,
        _keystore_path,
      ]
      _args += [
        "--apksigner-jar",
        rebase_path(_apksigner, root_build_dir),
        "--zipalign-path",
        rebase_path(_zipalign, root_build_dir),
        "--key-path",
        rebase_path(_keystore_path, root_build_dir),
        "--key-name",
        _keystore_name,
        "--key-passwd",
        _keystore_password,
      ]
      if (is_official_build) {
        _args += [ "--best-compression" ]
      }
    }
    if (defined(invoker.uncompress_dex)) {
      _uncompress_dex = invoker.uncompress_dex
    } else {
      # Uncompressed dex support started on Android P.
      _uncompress_dex = invoker.min_sdk_version >= 28
    }

    if (_uncompress_dex) {
      _args += [ "--uncompress-dex" ]
    }
    if (defined(invoker.library_always_compress)) {
      _args +=
          [ "--library-always-compress=${invoker.library_always_compress}" ]
    }
    if (defined(invoker.dex_path)) {
      _inputs += [ invoker.dex_path ]
      _args += [
        "--dex-file",
        rebase_path(invoker.dex_path, root_build_dir),
      ]
    }
    if ((defined(invoker.loadable_modules) && invoker.loadable_modules != []) ||
        defined(invoker.native_libs_filearg) ||
        _native_lib_placeholders != []) {
      _args += [ "--android-abi=$android_app_abi" ]
    }
    if (defined(android_app_secondary_abi)) {
      _args += [ "--secondary-android-abi=$android_app_secondary_abi" ]
    }
    if (defined(invoker.loadable_modules) && invoker.loadable_modules != []) {
      _inputs += invoker.loadable_modules
      _rebased_loadable_modules =
          rebase_path(invoker.loadable_modules, root_build_dir)
      _args += [ "--native-libs=$_rebased_loadable_modules" ]
    }
    if (defined(invoker.native_libs_filearg)) {
      _args += [ "--native-libs=${invoker.native_libs_filearg}" ]
    }
    if (_native_lib_placeholders != []) {
      _args += [ "--native-lib-placeholders=$_native_lib_placeholders" ]
    }

    if (defined(invoker.secondary_abi_native_libs_filearg)) {
      _args += [
        "--secondary-native-libs=${invoker.secondary_abi_native_libs_filearg}",
      ]
    }
    if (defined(invoker.secondary_abi_loadable_modules)) {
      _inputs += invoker.secondary_abi_loadable_modules
      _rebased_secondary_abi_loadable_modules =
          rebase_path(invoker.secondary_abi_loadable_modules, root_build_dir)
      _args +=
          [ "--secondary-native-libs=$_rebased_secondary_abi_loadable_modules" ]
    }
    if (_secondary_native_lib_placeholders != []) {
      _args += [ "--secondary-native-lib-placeholders=$_secondary_native_lib_placeholders" ]
    }
    if (treat_warnings_as_errors) {
      _args += [ "--warnings-as-errors" ]
    }

    if (defined(invoker.expected_libs_and_assets)) {
      _expectations_target =
          "${invoker.top_target_name}_validate_libs_and_assets"
      action_with_pydeps(_expectations_target) {
        _actual_file = "$target_gen_dir/$target_name.libs_and_assets"
        _failure_file =
            "$expectations_failure_dir/" +
            string_replace(invoker.expected_libs_and_assets, "/", "_")
        inputs = [ invoker.expected_libs_and_assets ]
        if (defined(invoker.build_config)) {
          inputs += [ invoker.build_config ]
        }
        deps = [ invoker.build_config_dep ]
        outputs = [
          _actual_file,
          _failure_file,
        ]
        script = _script
        args = _args + [
                 "--expected-file",
                 rebase_path(invoker.expected_libs_and_assets, root_build_dir),
                 "--actual-file",
                 rebase_path(_actual_file, root_build_dir),
                 "--failure-file",
                 rebase_path(_failure_file, root_build_dir),
                 "--only-verify-expectations",
               ]
        if (defined(invoker.expected_libs_and_assets_base)) {
          inputs += [ invoker.expected_libs_and_assets_base ]
          args += [
            "--expected-file-base",
            rebase_path(invoker.expected_libs_and_assets_base, root_build_dir),
          ]
        }
        if (fail_on_android_expectations) {
          args += [ "--fail-on-expectations" ]
        }
      }
      _deps += [ ":$_expectations_target" ]
    }
    action_with_pydeps(target_name) {
      depfile = "$target_gen_dir/$target_name.d"
      inputs = _inputs
      deps = _deps
      data = _data
      outputs = _outputs
      script = _script
      args = _args + [
               "--depfile",
               rebase_path(depfile, root_build_dir),
             ]
    }
  }

  # Compile Java source files into a .jar file, potentially using an
  # annotation processor, and/or the errorprone compiler. Also includes Kotlin
  # source files in the resulting info file.
  #
  # Note that the only way to specify custom annotation processors is
  # by using build_config to point to a file that corresponds to a java-related
  # target that includes javac:processor_classes entries (i.e. there is no
  # variable here that can be used for this purpose).
  #
  # Note also the peculiar use of source_files / target_sources_file. The content
  # of the source_files list and the source files in target_sources_file file must
  # match exactly.
  #
  # Variables:
  #  main_target_name: Used when extracting srcjars for codesearch.
  #  source_files: Optional list of Java and Kotlin source file paths.
  #  srcjar_deps: Optional list of .srcjar dependencies (not file paths).
  #    The corresponding source files they contain will be compiled too.
  #  target_sources_file: Optional path to file containing list of source file
  #    paths. This must always be provided if java_files is not empty and the
  #    .java files in it must match the list of java_files exactly.
  #  build_config: Path to the .build_config.json file of the corresponding
  #    java_library_impl() target. The following entries will be used by this
  #    template: javac:srcjars, deps_info:javac_full_classpath,
  #    deps_info:javac_full_interface_classpath, javac:processor_classpath,
  #    javac:processor_classes
  #  javac_jar_path: Path to the final output .jar file.
  #  javac_args: Optional list of extra arguments to pass to javac.
  #  chromium_code: Whether this corresponds to Chromium-specific sources.
  #  requires_android: True if these sources can only run on Android.
  #  additional_jar_files: Optional list of files to copy into the resulting
  #    .jar file (by default, only .class files are put there). Each entry
  #    has the 'srcPath:dstPath' format.
  #  enable_errorprone: If True, use the errorprone compiler to check for
  #    error-prone constructs in the language. If not provided, whether this is
  #    enabled depends on chromium_code and the global
  #    use_errorprone_java_compiler variable.
  #  use_turbine: If True, compile headers using turbine.py.
  #  apk_name: Optional APK name. If provided, will tell compile_java.py to also
  #    generate an .apk.jar.info file under size-info/${apk_name}.apk.jar.info
  #  processor_args_javac: List of annotation processor arguments, each one
  #    will be passed to javac as -A<entry>.
  #  deps: Dependencies for the corresponding target.
  #  testonly: Usual meaning (should be True for test-only targets)
  #
  # [1] https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html
  #
  template("compile_java") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

    _build_config = invoker.build_config
    _chromium_code = invoker.chromium_code

    _processor_args = []
    if (defined(invoker.processor_args_javac)) {
      _processor_args = invoker.processor_args_javac
    }

    _additional_jar_files = []
    if (defined(invoker.additional_jar_files)) {
      _additional_jar_files = invoker.additional_jar_files
    }

    _srcjar_deps = []
    if (defined(invoker.srcjar_deps)) {
      _srcjar_deps = invoker.srcjar_deps
    }

    if (!invoker.enable_errorprone) {
      _java_srcjars = []
      foreach(dep, _srcjar_deps) {
        _dep_gen_dir = get_label_info(dep, "target_gen_dir")
        _dep_name = get_label_info(dep, "name")
        _java_srcjars += [ "$_dep_gen_dir/$_dep_name.srcjar" ]
      }
      if (defined(invoker.srcjars)) {
        _java_srcjars += invoker.srcjars
      }

      # generated_jar_path is an output when use_turbine and an input otherwise.
      if (!invoker.use_turbine && defined(invoker.generated_jar_path)) {
        _java_srcjars += [ invoker.generated_jar_path ]
      }
    }

    _javac_args = []
    if (defined(invoker.javac_args)) {
      _javac_args = invoker.javac_args
    }

    action_with_pydeps(target_name) {
      if (invoker.use_turbine) {
        script = "//build/android/gyp/turbine.py"
        inputs = [
          "//third_party/jdk/current/bin/java",
          android_sdk_jar,
        ]
      } else if (invoker.enable_errorprone) {
        script = "//build/android/gyp/errorprone.py"
        inputs = javac_paths_for_inputs
      } else {
        script = "//build/android/gyp/compile_java.py"
        inputs = javac_paths_for_inputs
      }

      if (target_name == "chrome_java__header") {
        # Regression test for: https://crbug.com/1154302
        # Ensures that header jars never depend on non-header jars.
        assert_no_deps = [ "//base:base_java__compile_java" ]
      }

      depfile = "$target_gen_dir/$target_name.d"
      deps = _srcjar_deps
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }

      args = []
      if (invoker.enable_errorprone) {
        _stamp_file = "$target_out_dir/$target_name.stamp"
        outputs = [ _stamp_file ]
        _rebased_stamp_file = rebase_path(_stamp_file, root_build_dir)
        args += [ "--stamp=$_rebased_stamp_file" ]
      } else {
        outputs = [ invoker.output_jar_path ]
        if (!invoker.use_turbine) {
          outputs += [ invoker.output_jar_path + ".info" ]
        }
        _rebased_output_jar_path =
            rebase_path(invoker.output_jar_path, root_build_dir)

        # Error Prone does not run on srcjar, and they are not needed as inputs thanks to Turbine.
        _rebased_java_srcjars = rebase_path(_java_srcjars, root_build_dir)
        _rebased_generated_dir = rebase_path(
                "$target_gen_dir/${invoker.main_target_name}/generated_java",
                root_build_dir)
        args += [
          "--jar-path=$_rebased_output_jar_path",
          "--java-srcjars=$_rebased_java_srcjars",
          "--generated-dir=$_rebased_generated_dir",
        ]
        inputs += _java_srcjars
      }
      inputs += invoker.source_files + [
                  "$android_sdk/optional/android.test.base.jar",
                  "$android_sdk/optional/org.apache.http.legacy.jar",
                  _build_config,
                ] + java_paths_for_inputs

      if (invoker.source_files != []) {
        inputs += [ invoker.target_sources_file ]
      }

      _rebased_build_config = rebase_path(_build_config, root_build_dir)
      _rebased_depfile = rebase_path(depfile, root_build_dir)
      args += [
        "--depfile=$_rebased_depfile",
        "--target-name",
        get_label_info(":${target_name}", "label_no_toolchain"),
      ]

      # SDK jar must be first on classpath.
      if (invoker.include_android_sdk) {
        args += [ "--classpath=@FileArg($_rebased_build_config:android:sdk_interface_jars)" ]
      }

      if (defined(invoker.header_jar_path)) {
        inputs += [ invoker.header_jar_path ]
        args += [
          "--header-jar",
          rebase_path(invoker.header_jar_path, root_build_dir),
        ]
        _header_jar_classpath =
            [ rebase_path(invoker.header_jar_path, root_build_dir) ]
        args += [ "--classpath=$_header_jar_classpath" ]
      }

      if (defined(invoker.kotlin_jar_path)) {
        inputs += [ invoker.kotlin_jar_path ]
        _rebased_kotlin_jar_path =
            rebase_path(invoker.kotlin_jar_path, root_build_dir)
        args += [
          "--kotlin-jar-path=$_rebased_kotlin_jar_path",
          "--classpath=$_rebased_kotlin_jar_path",
        ]
      }

      if (invoker.use_turbine) {
        # Prefer direct deps for turbine as much as possible.
        args += [ "--classpath=@FileArg($_rebased_build_config:javac:interface_classpath)" ]
      } else {
        args += [ "--classpath=@FileArg($_rebased_build_config:deps_info:javac_full_interface_classpath)" ]
      }

      if (invoker.use_turbine) {
        args += [
          "--processorpath=@FileArg($_rebased_build_config:javac:processor_classpath)",
          "--processors=@FileArg($_rebased_build_config:javac:processor_classes)",
        ]
      }

      if (invoker.use_turbine) {
        _turbine_jar_path = "//third_party/turbine/cipd/turbine.jar"
        inputs += [ _turbine_jar_path ]
        outputs += [ invoker.generated_jar_path ]
        args += [
          "--turbine-jar-path",
          rebase_path(_turbine_jar_path, root_build_dir),
          "--generated-jar-path",
          rebase_path(invoker.generated_jar_path, root_build_dir),
        ]
      }

      # Flag enable_kythe_annotations requires
      # checkout_android_prebuilts_build_tools=True in .gclient.
      if (enable_kythe_annotations && !invoker.enable_errorprone) {
        args += [ "--enable-kythe-annotations" ]
      }
      if (_chromium_code) {
        args += [ "--chromium-code" ]
        if (treat_warnings_as_errors) {
          args += [ "--warnings-as-errors" ]
        }
      }
      if (defined(invoker.jar_excluded_patterns)) {
        args += [ "--jar-info-exclude-globs=${invoker.jar_excluded_patterns}" ]
      }

      if (invoker.enable_errorprone) {
        # Our custom plugin pulls in the main errorprone dep transitively.
        _errorprone_dep = "//tools/android/errorprone_plugin:errorprone_plugin"
        deps += [ _errorprone_dep ]
        _dep_gen_dir = get_label_info(_errorprone_dep, "target_gen_dir")
        _dep_name = get_label_info(_errorprone_dep, "name")
        _rebased_errorprone_buildconfig =
            rebase_path("$_dep_gen_dir/$_dep_name.build_config.json",
                        root_build_dir)
        args += [ "--processorpath=@FileArg($_rebased_errorprone_buildconfig:deps_info:host_classpath)" ]
        inputs += [
          # errorprone requires the plugin directory to detect src dir.
          # https://source.chromium.org/chromium/chromium/src/+/main:tools/android/errorprone_plugin/src/org/chromium/tools/errorprone/plugin/UseNetworkAnnotations.java;l=84;drc=dfd88085261b662a5c0a1abea1a3b120b08e8e48
          "//tools/android/errorprone_plugin/OWNERS",
        ]
        if (defined(testonly) && testonly) {
          args += [ "--testonly" ]
        } else {
          inputs += [ _nullaway_jar ]
          args += [
            "--processorpath=$_rebased_nullaway_jar",
            "--enable-nullaway",
          ]
        }
        if (defined(invoker.skip_build_server) && invoker.skip_build_server) {
          # Nocompile tests need lint to fail through ninja.
          args += [ "--skip-build-server" ]
        } else if (android_static_analysis == "build_server") {
          args += [ "--use-build-server" ]
        }
      }

      foreach(e, _processor_args) {
        args += [ "--processor-arg=" + e ]
      }

      foreach(file_tuple, _additional_jar_files) {
        # Each element is of length two, [ path_to_file, path_to_put_in_jar ]
        inputs += [ file_tuple[0] ]
        args +=
            [ "--additional-jar-file=" +
              rebase_path(file_tuple[0], root_build_dir) + ":" + file_tuple[1] ]
      }
      if (invoker.source_files != []) {
        args +=
            [ "@" + rebase_path(invoker.target_sources_file, root_build_dir) ]
      }
      foreach(e, _javac_args) {
        args += [ "--javac-arg=" + e ]
      }
    }
  }

  # Compile Kotlin source files into .class files and store them in a .jar.
  # This explicitly does not run annotation processing on the Kotlin files.
  # Java files and srcjars are also passed to kotlinc for reference, although
  # no .class files will be generated for any Java files. A subsequent call to
  # javac will be required to actually compile Java files into .class files.
  #
  # This action also creates a "header" .jar file for the Kotlin source files.
  # It is similar to using turbine to create headers for Java files, but since
  # turbine does not support Kotlin files, this is done via a plugin for
  # kotlinc instead, at the same time as compilation (whereas turbine is run as
  # a separate action before javac compilation).
  template("compile_kt") {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)

    _build_config = invoker.build_config
    _chromium_code = invoker.chromium_code

    _srcjar_deps = []
    if (defined(invoker.srcjar_deps)) {
      _srcjar_deps = invoker.srcjar_deps
    }

    _java_srcjars = []
    foreach(dep, _srcjar_deps) {
      _dep_gen_dir = get_label_info(dep, "target_gen_dir")
      _dep_name = get_label_info(dep, "name")
      _java_srcjars += [ "$_dep_gen_dir/$_dep_name.srcjar" ]
    }

    if (defined(invoker.srcjars)) {
      _java_srcjars += invoker.srcjars
    }

    action_with_pydeps(target_name) {
      script = "//build/android/gyp/compile_kt.py"
      depfile = "$target_gen_dir/$target_name.d"
      deps = _srcjar_deps
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }

      outputs = [
        invoker.output_jar_path,
        invoker.output_interface_jar_path,
      ]
      inputs = kotlinc_paths_for_inputs + java_paths_for_inputs +
               invoker.source_files + _java_srcjars +
               [
                 _build_config,
                 invoker.target_sources_file,
               ]

      _rebased_build_config = rebase_path(_build_config, root_build_dir)
      _rebased_output_jar_path =
          rebase_path(invoker.output_jar_path, root_build_dir)
      _rebased_output_interface_jar_path =
          rebase_path(invoker.output_interface_jar_path, root_build_dir)
      _rebased_java_srcjars = rebase_path(_java_srcjars, root_build_dir)
      _rebased_depfile = rebase_path(depfile, root_build_dir)
      _rebased_generated_dir = rebase_path(
              "$target_gen_dir/${invoker.main_target_name}/generated_java",
              root_build_dir)
      args = [
        "--depfile=$_rebased_depfile",
        "--generated-dir=$_rebased_generated_dir",
        "--jar-path=$_rebased_output_jar_path",
        "--interface-jar-path=$_rebased_output_interface_jar_path",
        "--java-srcjars=$_rebased_java_srcjars",
      ]

      # SDK jar must be first on classpath.
      if (invoker.include_android_sdk) {
        args += [ "--classpath=@FileArg($_rebased_build_config:android:sdk_interface_jars)" ]
      }

      args += [ "--classpath=@FileArg($_rebased_build_config:deps_info:javac_full_interface_classpath)" ]

      if (_chromium_code) {
        args += [ "--chromium-code" ]
        if (treat_warnings_as_errors) {
          args += [ "--warnings-as-errors" ]
        }
      }

      args += [ "@" + rebase_path(invoker.target_sources_file, root_build_dir) ]
    }
  }

  # Create an interface jar from a normal jar.
  #
  # Variables
  #   input_jar: Path to input .jar.
  #   output_jar: Path to output .ijar.
  #
  template("generate_interface_jar") {
    action_with_pydeps(target_name) {
      _ijar_target = "//third_party/ijar:ijar($host_toolchain)"
      _ijar_executable = get_label_info(_ijar_target, "root_out_dir") + "/ijar"
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "data",
                                   "data_deps",
                                   "public_deps",
                                 ])
      script = "//build/android/gyp/ijar.py"
      deps = [ _ijar_target ]
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
      inputs = [
        invoker.input_jar,
        _ijar_executable,
      ]
      if (defined(invoker.inputs)) {
        inputs += invoker.inputs
      }
      outputs = [ invoker.output_jar ]
      args = [
        rebase_path(_ijar_executable, root_build_dir),
        rebase_path(invoker.input_jar, root_build_dir),
        rebase_path(invoker.output_jar, root_build_dir),
      ]
    }
  }

  # A rule that will handle multiple Java-related targets.
  #
  # The caller can provide a list of source files with 'java_files'
  # and 'srcjar_deps', or a prebuilt .jar file through 'jar_path'.
  #
  # In the case of a 'java_binary' target type, it can even provide none of
  # that (and the rule will just generate its wrapper script).
  #
  # The template will process the input .jar file (either the prebuilt one,
  # or the result of compiling the sources), for example to apply Proguard,
  # but also other ranges of bytecode-level rewriting schemes.
  #
  # Variables:
  #  type: type of Java target, valid values: 'java_library', 'java_binary',
  #    'robolectric_binary', 'java_annotation_processor', and 'android_apk'
  #  main_target_name: optional. If provided, overrides target_name when
  #    creating sub-targets (e.g. "${main_target_name}__dex") and
  #    some output files (e.g. "${main_target_name}.sources"). Only used
  #    for 'android_apk' types at the moment, where main_target_name will
  #    be the name of the main APK target.
  #  supports_android: Optional. True if target can run on Android.
  #  requires_android: Optional. True if target can only run on Android.
  #  source_files: Optional list of Java source file paths for this target.
  #  javac_args: Optional list of extra arguments to pass to javac.
  #  errorprone_args: Optional list of extra arguments to pass to.
  #  srcjar_deps: Optional list of .srcjar targets (not file paths). The Java
  #    source files they contain will also be compiled for this target.
  #  target_sources_file: Optional path to a file which will be written with
  #    the content of source_files. If not provided, the file will be written
  #    under $target_gen_dir/$main_target_name.sources. Ignored if
  #    sources_files is empty. If not
  #  jar_path: Optional path to a prebuilt .jar file for this target.
  #    Mutually exclusive with java_files and srcjar_deps.
  #  output_name: Optional output name for the final jar path. Used to
  #    determine the name of the final jar. Default is to use the same
  #    name as jar_path, if provided, or main_target_name.
  #  main_class: Main Java class name for 'java_binary', 'robolectric_binary' and
  #    'java_annotation_processor' target types. Should not be set for other
  #    ones.
  #  deps: Dependencies for this target.
  #  public_deps: Dependencies that this target exposes as part of its public API.
  #    public_deps do not need to be listed in both the 'deps' and 'public_deps' lists.
  #  testonly: True iff target should only be used for tests.
  #  chromium_code: Optional. Whether this is Chromium-specific code. If not
  #    provided, this is determined automatically, based on the location of
  #    the source files (i.e. anything under third_party/ is not
  #    Chromium-specific unless it is in a 'chromium' sub-directory).
  #  jacoco_never_instrument: Optional. If provided, whether to forbid
  #    instrumentation with the Jacoco coverage processor. If not provided,
  #    this is controlled by the global use_jacoco_coverage build arg variable
  #    and only used for non-test Chromium code.
  #  include_android_sdk: Optional. Whether or not the android SDK dep
  #    should be added to deps. Defaults to true for non-system libraries
  #    that support android.
  #  alternative_android_sdk_dep: Optional. Alternative Android system
  #    android java target to use.
  #  annotation_processor_deps: Optional list of dependencies corresponding
  #    to annotation processors used to compile these sources.
  #  input_jars_paths: Optional list of additional .jar file paths, which will
  #    be added to the compile-time classpath when building this target (but
  #    not to the runtime classpath).
  #  gradle_treat_as_prebuilt: Cause generate_gradle.py to reference this
  #    library via its built .jar rather than including its .java sources.
  #  proguard_enabled: Optional. True to enable ProGuard obfuscation.
  #  proguard_configs: Optional list of additional proguard config file paths.
  #  is_robolectric: Optional. If True, this is a host side android test binary
  #    which is allowed to depend on other android targets.
  #  include_java_resources: Optional. If True, include Java (not Android)
  #    resources into final .jar file.
  #  jar_excluded_patterns: Optional list of .class file patterns to exclude
  #    from the final .jar file.
  #  jar_included_patterns: Optional list of .class file patterns to include
  #    in the final .jar file. jar_excluded_patterns take precedence over this.
  #  low_classpath_priority: Indicates that the library should be placed at the
  #    end of the classpath. The default classpath order has libraries ordered
  #    before the libraries that they depend on. 'low_classpath_priority' is
  #    useful when one java_library() overrides another via
  #    'jar_excluded_patterns' and the overriding library does not depend on the
  #    overridee.
  #
  # For 'android_apk' and 'android_app_bundle_module' targets only:
  #
  #  apk_path: Path to the final APK file.
  #  android_manifest: Path to AndroidManifest.xml file for the APK.
  #  android_manifest_dep: Optional. Dependency target that generates
  #    android_manifest.
  #  apk_under_test: For 'android_apk' targets used to test other APKs,
  #    this is the target name of APK being tested.
  #  incremental_apk_path: Path to the incremental APK.
  #  incremental_install_json_path: Path to the incremental install json.
  #  native_lib_placeholders: Optional. List of placeholder filenames to add to
  #    the APK.
  #  proguard_mapping_path: Path to .mapping file produced from ProGuard step.
  #  shared_libraries_runtime_deps_file: Optional. Path to a file listing the
  #    native shared libraries required at runtime by the APK.
  #  secondary_abi_shared_libraries_runtime_deps_file:
  #  secondary_native_lib_placeholders: Optional. List of placeholder filenames
  #    to add to the APK for the secondary ABI.
  #  loadable_modules: Optional list of extra native libraries to
  #    be stored in the APK.
  #  secondary_abi_loadable_modules: Optional list of native libraries for
  #    secondary ABI.
  #  proto_resources_path: The path of an zip archive containing the APK's
  #    resources compiled to the protocol buffer format (instead of regular
  #    binary xml + resources.arsc).
  #  r_text_path: The path of the R.txt file generated when compiling the
  #    resources for this target.
  #  module_pathmap_path: The path of the pathmap file generated when compiling
  #    the resources for the bundle module, if path shortening is enabled.
  #  base_allowlist_rtxt_path: The path of the R.txt file containing the
  #    list of string resources to keep in the base split APK for any bundle
  #    that uses this target.
  #
  # For 'java_binary' and 'robolectric_binary' targets only. Ignored by others:
  #
  #  wrapper_script_name: Optional name for the generated wrapper script.
  #    Default is main target name.
  #  wrapper_script_args: Optional list of extra arguments used by the
  #    generated wrapper script.
  #
  template("java_library_impl") {
    forward_variables_from(invoker, [ "testonly" ])

    _target_dir = get_label_info(":any_name_here", "dir")

    _is_prebuilt = defined(invoker.jar_path)
    _type = invoker.type
    _is_annotation_processor = _type == "java_annotation_processor"
    _is_java_binary = _type == "java_binary" || _type == "robolectric_binary"
    _is_library = _type == "java_library"
    _supports_android =
        defined(invoker.supports_android) && invoker.supports_android
    _requires_android =
        defined(invoker.requires_android) && invoker.requires_android
    _supports_host = !_requires_android
    if (_is_java_binary || _is_annotation_processor) {
      assert(!_requires_android && !_supports_android)
    }

    _bypass_platform_checks = defined(invoker.bypass_platform_checks) &&
                              invoker.bypass_platform_checks
    _is_robolectric = defined(invoker.is_robolectric) && invoker.is_robolectric

    if (defined(invoker.sources)) {
      _source_files = invoker.sources
    } else {
      _source_files = []
    }
    _srcjar_deps = []
    if (defined(invoker.srcjar_deps)) {
      _srcjar_deps = invoker.srcjar_deps
    }
    _srcjars = []
    if (defined(invoker.srcjars)) {
      _srcjars = invoker.srcjars
    }
    _has_sources = _source_files != [] || _srcjar_deps != [] || _srcjars != []

    if (defined(invoker.chromium_code)) {
      _chromium_code = invoker.chromium_code
    } else {
      # Default based on whether target is in third_party.
      _chromium_code =
          filter_exclude([ _target_dir ], [ "*\bthird_party\b*" ]) != []
      if (!_chromium_code && !_is_prebuilt && _source_files != []) {
        # Unless third_party code has an org.chromium file in it.
        _chromium_code =
            filter_exclude(_source_files, [ "*\bchromium\b*" ]) != _source_files
      }
    }

    if (_chromium_code && _has_sources && _target_dir != "//build/android") {
      _default_deps = [ "//build/android:build_java" ]
    } else {
      _default_deps = []
    }
    _invoker_deps = _default_deps
    if (defined(invoker.deps)) {
      _invoker_deps += invoker.deps
    }
    if (defined(invoker.public_deps)) {
      _invoker_deps += invoker.public_deps
    }

    if (_is_prebuilt || _has_sources) {
      # This allows us to use jar_excluded_patterns and prevent even the
      # interface jars from having these classes. This means that, with this
      # flag, nobody depending on this java library will be able to see these
      # classes. These excluded classes are only used for the exact target they
      # are compiled in. We do this by not making a header jar, and replacing
      # all usages of the header jar with the processed (post-exclusion) jar.
      _skip_header_jar =
          defined(invoker.prevent_excluded_classes_from_classpath) &&
          invoker.prevent_excluded_classes_from_classpath
    }

    if (_is_prebuilt) {
      assert(!_has_sources)
    } else {
      # Allow java_binary to not specify any sources. This is needed when a prebuilt
      # is needed as a library as well as a binary.
      assert(_is_annotation_processor || _is_java_binary || _has_sources)
    }

    if (_is_java_binary) {
      assert(defined(invoker.main_class), "${_type}() must set main_class")
    } else if (_is_annotation_processor) {
      assert(defined(invoker.main_class),
             "java_annotation_processor() must set main_class")
    } else {
      assert(!defined(invoker.main_class),
             "main_class cannot be used for target of type ${_type}")
    }

    if (defined(invoker.main_target_name)) {
      _main_target_name = invoker.main_target_name
    } else {
      _main_target_name = target_name
    }

    # Define build_config_deps which will be a list of targets required to
    # build the _build_config.
    _build_config = "$target_gen_dir/$_main_target_name.build_config.json"
    _build_config_target_name =
        "${_main_target_name}$build_config_target_suffix"

    # The only target that might have no prebuilt and no sources is a java_binary.
    _build_host_jar = false
    _build_device_jar = false
    if (_is_prebuilt || _has_sources) {
      if (defined(invoker.output_name)) {
        _output_name = invoker.output_name
      } else {
        _output_name = _main_target_name
      }

      _build_host_jar = _is_java_binary || _is_annotation_processor ||
                        _type == "java_library" || _type == "dist_jar"
      _build_device_jar = _type != "system_java_library" && _supports_android

      _jacoco_instrument =
          use_jacoco_coverage && _chromium_code && _source_files != [] &&
          _build_device_jar && (!defined(invoker.testonly) || !invoker.testonly)
      if (defined(invoker.jacoco_never_instrument)) {
        _jacoco_instrument =
            !invoker.jacoco_never_instrument && _jacoco_instrument
      }
      if (_jacoco_instrument) {
        _invoker_deps += [ _jacoco_dep ]
      }

      if (_build_host_jar) {
        # Jar files can be needed at runtime (by Robolectric tests or java binaries),
        # so do not put them under obj/.
        # TODO(agrieve): I suspect it would be better to use dist_jar for java_binary
        #     rather than archiving unnecessary .jar files within lib.java.
        _host_processed_jar_path =
            "$root_out_dir/lib.java$_target_dir/$_output_name.jar"
      }
      if (_build_device_jar) {
        _dex_path = "$target_out_dir/$_main_target_name.dex.jar"
        _enable_desugar =
            !defined(invoker.enable_desugar) || invoker.enable_desugar

        # Build speed optimization: Skip "process device" step if the step
        # would be just a copy and avoid the copy.
        _process_device_jar =
            defined(invoker.bytecode_rewriter_target) || _jacoco_instrument ||
            defined(invoker.jar_excluded_patterns) ||
            defined(invoker.jar_included_patterns)
        if (!_process_device_jar && _is_prebuilt) {
          _device_processed_jar_path = invoker.jar_path
        } else {
          _device_processed_jar_path =
              "$target_out_dir/$_output_name.processed.jar"
        }
      }

      # For static libraries, the javac jar output is created at the intermediate
      # path so that it can be processed by another target and moved to the final
      # spot that the .build_config.json knows about. Technically this should be done
      # for the ijar as well, but this is only used for APK targets where
      # the ijar path isn't actually used.
      if (_has_sources) {
        _final_ijar_path = "$target_out_dir/$_output_name.turbine.jar"
      } else {
        _final_ijar_path = "$target_out_dir/$_output_name.ijar.jar"
      }

      if (_has_sources) {
        if (_build_device_jar && !_process_device_jar) {
          _javac_jar_path = _device_processed_jar_path
        } else {
          _javac_jar_path = "$target_out_dir/$_main_target_name.javac.jar"
        }
        _generated_jar_path =
            "$target_gen_dir/$_main_target_name.generated.srcjar"
      }

      if (_is_prebuilt) {
        _unprocessed_jar_path = invoker.jar_path
      } else {
        _unprocessed_jar_path = _javac_jar_path
      }
    }

    _java_assetres_deps = filter_include(_invoker_deps, java_resource_patterns)

    # Cannot use minus operator because it does not work when the operand has
    # repeated entries.
    _invoker_deps_minus_assetres =
        filter_exclude(_invoker_deps, _java_assetres_deps)
    _lib_deps =
        filter_include(_invoker_deps_minus_assetres, java_library_patterns)
    _non_java_deps = filter_exclude(_invoker_deps_minus_assetres, _lib_deps)

    _java_header_deps = []  # Turbine / ijar

    # It would be more ideal to split this into __host and __javac, but we
    # combine the two concepts to save on a group() target.
    _java_host_deps = []  # Processed host .jar + javac .jar.
    _java_validate_deps = []  # Bytecode checker & errorprone.

    foreach(_lib_dep, _lib_deps) {
      # Expand //foo/java -> //foo/java:java
      _lib_dep = get_label_info(_lib_dep, "label_no_toolchain")
      _java_assetres_deps += [ "${_lib_dep}__assetres" ]
      _java_header_deps += [ "${_lib_dep}__header" ]
      _java_host_deps += [ "${_lib_dep}__host" ]
      _java_validate_deps += [ "${_lib_dep}__validate" ]
    }

    # APK and base module targets are special because:
    # 1) They do not follow java target naming scheme (since they are not
    #    generally deps, there is no need for them to).
    # 2) They do not bother to define a __host target.
    # Since __host is used as an indirect dep for the compile_java artifacts,
    # add the __compile_java target directly for them.
    if (defined(invoker.apk_under_test)) {
      _java_assetres_deps += [ "${invoker.apk_under_test}__java__assetres" ]
      _java_header_deps += [ "${invoker.apk_under_test}__java__header" ]
      _java_validate_deps += [ "${invoker.apk_under_test}__java__validate" ]
      _java_host_deps += [ "${invoker.apk_under_test}__compile_java" ]
    }
    if (defined(invoker.base_module_target)) {
      _java_assetres_deps += [ "${invoker.base_module_target}__java__assetres" ]
      _java_header_deps += [ "${invoker.base_module_target}__java__header" ]
      _java_validate_deps += [ "${invoker.base_module_target}__java__validate" ]
      _java_host_deps += [ "${invoker.base_module_target}__compile_java" ]
    }

    not_needed([ "_non_java_deps" ])

    if (_is_prebuilt || _has_sources) {
      # Classpath deps are used for header and dex targets, they do not need
      # __assetres deps.
      # _non_java_deps are needed for input_jars_paths that are generated.
      _header_classpath_deps =
          _java_header_deps + _non_java_deps + [ ":$_build_config_target_name" ]

      _javac_classpath_deps =
          _java_host_deps + _non_java_deps + [ ":$_build_config_target_name" ]

      _include_android_sdk = _build_device_jar
      if (defined(invoker.include_android_sdk)) {
        _include_android_sdk = invoker.include_android_sdk
      }
      if (_include_android_sdk) {
        if (defined(invoker.alternative_android_sdk_dep)) {
          _android_sdk_dep = invoker.alternative_android_sdk_dep
        } else {
          _android_sdk_dep = default_android_sdk_dep
        }

        _header_classpath_deps += [ "${_android_sdk_dep}__header" ]
        _javac_classpath_deps += [ "${_android_sdk_dep}" ]
      }
    }

    # Often needed, but too hard to figure out when ahead of time.
    not_needed([
                 "_header_classpath_deps",
                 "_javac_classpath_deps",
               ])

    if (_source_files != []) {
      _target_sources_file = "$target_gen_dir/$_main_target_name.sources"
      write_file(_target_sources_file,
                 rebase_path(_source_files, root_build_dir))
    }

    write_build_config(_build_config_target_name) {
      forward_variables_from(invoker,
                             [
                               "aar_path",
                               "annotation_processor_deps",
                               "base_allowlist_rtxt_path",
                               "direct_deps_only",
                               "gradle_treat_as_prebuilt",
                               "input_jars_paths",
                               "preferred_dep",
                               "low_classpath_priority",
                               "main_class",
                               "mergeable_android_manifests",
                               "module_name",
                               "parent_module_target",
                               "proguard_configs",
                               "proguard_enabled",
                               "proguard_mapping_path",
                               "public_target_label",
                               "r_text_path",
                               "suffix_apk_assets_used_by",
                               "type",
                               "use_interface_jars",
                               "version_code",
                               "version_name",
                             ])
      if (_type == "android_apk" || _type == "android_app_bundle_module") {
        forward_variables_from(
            invoker,
            [
              "android_manifest",
              "android_manifest_dep",
              "merged_android_manifest",
              "final_dex_path",
              "loadable_modules",
              "native_lib_placeholders",
              "res_size_info_path",
              "secondary_abi_loadable_modules",
              "secondary_abi_shared_libraries_runtime_deps_file",
              "secondary_native_lib_placeholders",
              "shared_libraries_runtime_deps_file",
              "library_always_compress",
            ])
      }
      if (_type == "android_apk") {
        forward_variables_from(invoker,
                               [
                                 "apk_path",
                                 "apk_under_test",
                                 "incremental_apk_path",
                                 "incremental_install_json_path",
                               ])
      }
      if (_type == "android_app_bundle_module") {
        forward_variables_from(invoker,
                               [
                                 "add_view_trace_events",
                                 "base_module_target",
                                 "module_pathmap_path",
                                 "proto_resources_path",
                               ])
      }
      chromium_code = _chromium_code
      build_config = _build_config
      is_prebuilt = _is_prebuilt

      # Specifically avoid passing in invoker.base_module_target as one of the
      # possible_config_deps.
      possible_config_deps = _default_deps
      if (defined(invoker.deps)) {
        possible_config_deps += invoker.deps
      }
      if (defined(invoker.public_deps)) {
        possible_config_public_deps = invoker.public_deps
      }
      if (defined(invoker.asset_deps)) {
        possible_config_deps += invoker.asset_deps
      }
      if (defined(apk_under_test)) {
        possible_config_deps += [ apk_under_test ]
      }
      if (defined(_jacoco_instrument) && _jacoco_instrument) {
        possible_config_deps += [ _jacoco_dep ]
      }
      if (defined(_android_sdk_dep)) {
        possible_config_deps += [ _android_sdk_dep ]
      }

      supports_android = _supports_android
      requires_android = _requires_android
      is_robolectric = _is_robolectric
      bypass_platform_checks = _bypass_platform_checks

      if (defined(invoker.resources_package)) {
        custom_package = invoker.resources_package
      }
      if (_is_prebuilt || _has_sources) {
        if (_skip_header_jar) {
          # We are tricking everything that is looking for an ijar into looking
          # at the processed jar path, which is has the excluded classes
          # removed.
          ijar_path = _device_processed_jar_path
        } else {
          ijar_path = _final_ijar_path
        }
        unprocessed_jar_path = _unprocessed_jar_path
      }
      if (_build_host_jar) {
        host_jar_path = _host_processed_jar_path
      }
      if (_build_device_jar) {
        device_jar_path = _device_processed_jar_path
        dex_path = _dex_path
      }
      if (_source_files != []) {
        target_sources_file = _target_sources_file
      }

      bundled_srcjars = []
      foreach(d, _srcjar_deps) {
        _dep_gen_dir = get_label_info(d, "target_gen_dir")
        _dep_name = get_label_info(d, "name")
        bundled_srcjars += [ "$_dep_gen_dir/$_dep_name.srcjar" ]
      }
      bundled_srcjars += _srcjars
      if (defined(invoker.include_java_resources) &&
          invoker.include_java_resources) {
        java_resources_jar = _unprocessed_jar_path
        if (defined(invoker.jar_path)) {
          # Use original jar_path because _jar_path points to a library without
          # resources.
        } else {
          java_resources_jar = _device_processed_jar_path
        }
      }
    }

    if (_is_prebuilt || _has_sources) {
      _header_target_name = "${target_name}__header"
    }

    if (_has_sources) {
      _kt_files = filter_include(_source_files, [ "*.kt" ])
      _java_files = filter_exclude(_source_files, [ "*.kt" ])

      if (defined(invoker.enable_errorprone)) {
        _enable_errorprone = invoker.enable_errorprone
      } else {
        _enable_errorprone =
            _java_files != [] && _chromium_code && use_errorprone_java_compiler
      }
      if (_enable_errorprone) {
        # Rely on the header jar to provide all .class files so that it is
        # safe to omit generated files entirely for errorprone.
        _errorprone_source_files =
            filter_exclude(_java_files, [ "$root_gen_dir*" ])
        _enable_errorprone =
            _enable_errorprone && _errorprone_source_files != []
      } else {
        not_needed(invoker, [ "errorprone_args" ])
      }

      if (defined(invoker.resources_package) && _type == "java_library") {
        # TODO(crbug.com/40821816): remove _bypass_platform_checks from the list
        # once all robolectric targets have migrated to robolectric_library.
        assert(_requires_android || _bypass_platform_checks || _is_robolectric,
               "Setting resources_package applicable only for " +
                   "android_library(), or robolectric_library(). " +
                   "Target=$target_name")

        # Serves double purpose: Generating R.java, as well as being the
        #__assetres target (instead of using a separate group).
        _fake_rjava_target = "${target_name}__assetres"
        generate_r_java(_fake_rjava_target) {
          deps = [ ":$_build_config_target_name" ] + _java_assetres_deps +
                 _non_java_deps
          build_config = _build_config

          # Filepath has to be exactly this because compile_java looks for the
          # srcjar of srcjar_deps at this location $gen_dir/$target_name.srcjar
          srcjar_path = "$target_gen_dir/$target_name.srcjar"
          package = invoker.resources_package
        }
        _srcjar_deps += [ ":$_fake_rjava_target" ]
      }

      if (_kt_files != []) {
        _abs_kt_files = get_path_info(_kt_files, "abspath")
        _kt_allowlist = [
          "*/AsyncTabParamsManagerImpl.kt",
          "//third_party/androidx/*",
          "*/webengine_shell_apk/*",
          "local_modifications/pdf/java/androidx/pdf/viewer/fragment/PdfViewerFragment.kt",
        ]
        _found_kt = filter_exclude(_abs_kt_files, _kt_allowlist)
        assert(
            _found_kt == [],
            "Only a files in the allowlist can be included for now. Feel free to remove this assert when experimenting locally. Found: $_found_kt")
        _compile_kt_target_name = "${_main_target_name}__compile_kt"
        _kotlinc_jar_path = "$target_out_dir/$_output_name.kotlinc.jar"
        _kotlin_interface_jar_path =
            "$target_out_dir/$_output_name.kt-jvm-abi.jar"
        assert(filter_include(_lib_deps, [ _kotlin_stdlib_dep ]) != [],
               "${_main_target_name} is missing dep: $_kotlin_stdlib_dep")
        compile_kt(_compile_kt_target_name) {
          deps = _header_classpath_deps
          output_jar_path = _kotlinc_jar_path
          output_interface_jar_path = _kotlin_interface_jar_path
          main_target_name = _main_target_name
          build_config = _build_config
          srcjar_deps = _srcjar_deps
          source_files = _source_files
          target_sources_file = _target_sources_file
          chromium_code = _chromium_code
          include_android_sdk = _is_robolectric || _requires_android
        }
      }

      template("compile_java_helper") {
        _enable_errorprone =
            defined(invoker.enable_errorprone) && invoker.enable_errorprone
        compile_java(target_name) {
          forward_variables_from(invoker,
                                 "*",
                                 TESTONLY_AND_VISIBILITY + [ "deps" ])
          deps = _header_classpath_deps
          if (defined(invoker.deps)) {
            deps += invoker.deps
          }
          if (defined(invoker.kotlin_jar_path)) {
            deps += [ ":$_compile_kt_target_name" ]
            kotlin_jar_path = invoker.kotlin_jar_path
          }
          enable_errorprone = _enable_errorprone
          use_turbine = defined(invoker.use_turbine) && invoker.use_turbine

          build_config = _build_config

          if (_enable_errorprone) {
            source_files = _errorprone_source_files
          } else {
            main_target_name = _main_target_name
            source_files = _source_files
            srcjar_deps = _srcjar_deps
            srcjars = _srcjars
          }

          if (source_files != []) {
            target_sources_file = _target_sources_file
          }
          chromium_code = _chromium_code
          include_android_sdk = _is_robolectric || _requires_android
        }
      }
      _compile_java_forward_variables = [
        "additional_jar_files",
        "apk_name",
        "jar_excluded_patterns",
        "javac_args",
        "processor_args_javac",
      ]

      if (!_skip_header_jar) {
        _annotation_processor_deps = []
        if (defined(invoker.annotation_processor_deps)) {
          _annotation_processor_deps = invoker.annotation_processor_deps
        }

        compile_java_helper(_header_target_name) {
          forward_variables_from(invoker, _compile_java_forward_variables)
          use_turbine = true
          output_jar_path = _final_ijar_path
          generated_jar_path = _generated_jar_path
          deps = _annotation_processor_deps
          if (_kt_files != []) {
            kotlin_jar_path = _kotlin_interface_jar_path
          }
        }
      }

      _compile_java_target = "${_main_target_name}__compile_java"
      compile_java_helper(_compile_java_target) {
        forward_variables_from(invoker, _compile_java_forward_variables)
        output_jar_path = _javac_jar_path
        if (!_skip_header_jar) {
          deps = [ ":$_header_target_name" ]
          header_jar_path = _final_ijar_path
          generated_jar_path = _generated_jar_path
        }
        if (_kt_files != []) {
          kotlin_jar_path = _kotlinc_jar_path
        }
      }

      if (_enable_errorprone) {
        _compile_java_errorprone_target = "${_main_target_name}__errorprone"
        compile_java_helper(_compile_java_errorprone_target) {
          forward_variables_from(invoker, _compile_java_forward_variables)
          forward_variables_from(invoker, [ "skip_build_server" ])
          enable_errorprone = true
          if (defined(invoker.errorprone_args)) {
            if (!defined(javac_args)) {
              javac_args = []
            }
            javac_args += invoker.errorprone_args
          }
          if (_kt_files != []) {
            kotlin_jar_path = _kotlinc_jar_path
          }
          if (!_skip_header_jar) {
            deps = [ ":$_header_target_name" ]
            header_jar_path = _final_ijar_path
          }
        }
        _java_validate_deps += [ ":$_compile_java_errorprone_target" ]
      }
    }  # _has_sources

    if (_is_prebuilt || _build_device_jar || _build_host_jar) {
      if (_has_sources) {
        _unprocessed_jar_deps = [ ":$_compile_java_target" ]
      } else {
        # jars might be generated by a dep.
        _unprocessed_jar_deps = _non_java_deps
      }
    }

    if (defined(invoker.bytecode_rewriter_target)) {
      assert(_build_host_jar || _build_device_jar,
             "A host or device jar must be created to use bytecode rewriting")

      _rewritten_jar = "$target_out_dir/${target_name}_rewritten.jar"
      _rewritten_jar_target_name = "${target_name}__rewritten"
      _rewriter_path = root_build_dir + "/bin/helper/" +
                       get_label_info(invoker.bytecode_rewriter_target, "name")
      _rebased_build_config = rebase_path(_build_config, root_build_dir)
      action_with_pydeps(_rewritten_jar_target_name) {
        script = "//build/android/gyp/bytecode_rewriter.py"
        inputs = java_paths_for_inputs + [
                   _rewriter_path,
                   _build_config,
                   _unprocessed_jar_path,
                 ]
        outputs = [ _rewritten_jar ]
        depfile = "$target_gen_dir/$target_name.d"
        args = [
          "--depfile",
          rebase_path(depfile, root_build_dir),
          "--script",
          rebase_path(_rewriter_path, root_build_dir),
          "--classpath",
          "@FileArg($_rebased_build_config:deps_info:javac_full_classpath)",
          "--classpath",
          "@FileArg($_rebased_build_config:android:sdk_jars)",
          "--input-jar",
          rebase_path(_unprocessed_jar_path, root_build_dir),
          "--output-jar",
          rebase_path(_rewritten_jar, root_build_dir),
        ]
        deps = _unprocessed_jar_deps + _javac_classpath_deps +
               [ invoker.bytecode_rewriter_target ]
      }

      _unprocessed_jar_deps = []
      _unprocessed_jar_deps = [ ":$_rewritten_jar_target_name" ]
      _unprocessed_jar_path = _rewritten_jar
    }

    if (_is_prebuilt) {
      generate_interface_jar(_header_target_name) {
        # Always used the unfiltered .jar to create the interface jar so that
        # other targets will resolve filtered classes when depending on
        # BuildConfig, NativeLibraries, etc.
        input_jar = _unprocessed_jar_path
        output_jar = _final_ijar_path

        # ijar needs only _unprocessed_jar_deps, but this also needs to export
        # __header target from deps.
        deps = _unprocessed_jar_deps + _java_header_deps
      }
    }

    if (_build_host_jar || _build_device_jar) {
      _enable_bytecode_checks =
          (!defined(invoker.enable_bytecode_checks) ||
           invoker.enable_bytecode_checks) && !_is_prebuilt &&
          android_static_analysis != "off"
      if (_enable_bytecode_checks) {
        _validate_target_name = "${target_name}__validate"
        check_for_missing_direct_deps(_validate_target_name) {
          forward_variables_from(invoker, [ "missing_classes_allowlist" ])
          deps = _unprocessed_jar_deps + _javac_classpath_deps +
                 [ ":$_build_config_target_name" ]
          data_deps = _java_validate_deps
          if (defined(_compile_java_errorprone_target)) {
            data_deps += [ ":$_compile_java_errorprone_target" ]
          }

          include_android_sdk = _requires_android || _is_robolectric
          target_label =
              get_label_info(":${invoker.target_name}", "label_no_toolchain")
          input_jar = _unprocessed_jar_path
          build_config = _build_config
        }
      } else {
        not_needed(invoker, [ "missing_classes_allowlist" ])
      }

      if (_build_host_jar) {
        _process_host_jar_target_name = "${target_name}__host"
        process_java_library(_process_host_jar_target_name) {
          forward_variables_from(invoker,
                                 [
                                   "jar_excluded_patterns",
                                   "jar_included_patterns",
                                 ])

          # Robolectric tests require these to be on swarming.
          data = [ _host_processed_jar_path ]
          input_jar_path = _unprocessed_jar_path
          deps = _unprocessed_jar_deps + _javac_classpath_deps
          output_jar_path = _host_processed_jar_path
          jacoco_instrument = _jacoco_instrument
          if (_jacoco_instrument) {
            source_files = _source_files
            target_sources_file = _target_sources_file
          }

          # _java_host_deps isn't necessary for process_java_library(), but is
          # necessary so that this target can be used to depend on transitive
          # __device targets without the need to create a separate group()
          # target. This trade-off works because process_java_library is fast.
          deps += _java_host_deps

          # Add runtime_deps here since robolectric_binary does not depend on top-level group.
          if (defined(invoker.data)) {
            data += invoker.data
          }
          if (defined(invoker.data_deps)) {
            data_deps = invoker.data_deps
          }
        }
      }

      if (_build_device_jar) {
        if (_process_device_jar) {
          _process_device_jar_target_name = "${target_name}__process_device"
          process_java_library(_process_device_jar_target_name) {
            forward_variables_from(invoker,
                                   [
                                     "jar_excluded_patterns",
                                     "jar_included_patterns",
                                   ])
            input_jar_path = _unprocessed_jar_path

            deps = _unprocessed_jar_deps + _javac_classpath_deps
            output_jar_path = _device_processed_jar_path
            jacoco_instrument = _jacoco_instrument
            if (_jacoco_instrument) {
              source_files = _source_files
              target_sources_file = _target_sources_file
            }
          }
          _process_device_jar_deps = [ ":${_process_device_jar_target_name}" ]
        } else {
          assert(_unprocessed_jar_path == _device_processed_jar_path)
          _process_device_jar_deps = _unprocessed_jar_deps
        }

        if (_skip_header_jar) {
          group(_header_target_name) {
            public_deps = [ ":$_process_device_jar_target_name" ]
          }
        }

        _dex_target_name = "${target_name}__dex"
        dex(_dex_target_name) {
          forward_variables_from(invoker,
                                 [
                                   "proguard_enable_obfuscation",
                                   "repackage_classes",
                                 ])
          input_class_jars = [ _device_processed_jar_path ]
          enable_desugar = _enable_desugar
          ignore_desugar_missing_deps = !_enable_bytecode_checks

          # There's no value in per-class dexing prebuilts since they never
          # change just one class at a time.
          disable_incremental = _is_prebuilt
          output = _dex_path
          deps = _process_device_jar_deps

          if (enable_desugar) {
            # Desugaring with D8 requires full classpath.
            build_config = _build_config
            unprocessed_jar_path = _unprocessed_jar_path
            deps += _header_classpath_deps + _unprocessed_jar_deps
          }

          is_library = true

          # proguard_configs listed on java_library targets need to be marked
          # as inputs to at least one target so that "gn analyze" will know
          # about them. Although this target doesn't use them, it's a convenient spot
          # to list them.
          # https://crbug.com/827197
          if (compute_inputs_for_analyze && defined(invoker.proguard_configs)) {
            inputs = invoker.proguard_configs

            # For the aapt-generated proguard rules.
            deps += _non_java_deps + _srcjar_deps
          }
        }
      }
    }

    if (_is_java_binary) {
      # Targets might use the generated script while building, so make it a dep
      # rather than a data_dep.
      _java_binary_script_target_name = "${target_name}__java_binary_script"
      java_binary_script(_java_binary_script_target_name) {
        forward_variables_from(invoker,
                               [
                                 "tiered_stop_at_level_one",
                                 "main_class",
                                 "max_heap_size",
                                 "wrapper_script_args",
                               ])
        build_config = _build_config
        script_name = _main_target_name
        if (defined(invoker.wrapper_script_name)) {
          script_name = invoker.wrapper_script_name
        }
        deps = [ ":$_build_config_target_name" ]
        if (_is_robolectric) {
          # For robolectric tests, we add the sdk stub jars so that classes
          # that reference Android types can be loaded without throwing
          # NoClassDefFoundErrors. The Robolectric sandbox makes these types
          # available in non-stub form, but not until test classes are loaded
          # into it. Before being loaded into the sandbox, they must be loaded
          # outside of it in order to read their annotations (which configure
          # the sandbox), and to enumerate test methods.
          extra_classpath_jars = [
            android_sdk_jar,
            "$android_sdk/optional/android.test.base.jar",
            "$android_sdk/optional/android.test.runner.jar",
          ]
        }
      }
    }

    if (!defined(_validate_target_name)) {
      _validate_target_name = "${target_name}__validate"

      # Allow other targets to depend on this __validate one.
      group(_validate_target_name) {
        deps = _java_validate_deps
      }
    }

    if (_supports_host && !defined(_process_host_jar_target_name)) {
      group("${target_name}__host") {
        deps = _java_host_deps
      }
    }

    # robolectric_library can depend on java_library, so java_library must
    # define __assetres.
    if ((_is_library || _supports_android || _is_robolectric) &&
        !defined(_fake_rjava_target)) {
      group("${target_name}__assetres") {
        if (_supports_android || _is_robolectric) {
          deps = _java_assetres_deps
        }
      }
    }

    # The top-level group is used:
    # 1) To allow building the target explicitly via ninja,
    # 2) To trigger all analysis deps,
    # 3) By custom action() targets that want to use artifacts as inputs.
    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "assert_no_deps",
                               "data",
                               "data_deps",
                               "visibility",
                             ])
      if (_requires_android || (_supports_android && _is_library)) {
        # For non-robolectric targets, depend on other java target's top-level
        # groups so that the __dex step gets depended on.
        deps = _default_deps
        if (defined(invoker.deps)) {
          deps += invoker.deps
        }
        public_deps = []
        if (defined(invoker.public_deps)) {
          public_deps += invoker.public_deps
        }
        if (is_cronet_build) {
          _abs_deps = []
          foreach(dep, deps) {
            _abs_deps += [ get_label_info(dep, "label_no_toolchain") ]
          }
          foreach(dep, public_deps) {
            _abs_deps += [ get_label_info(dep, "label_no_toolchain") ]
          }
          if (defined(invoker.srcjar_deps)) {
            foreach(dep, invoker.srcjar_deps) {
              _abs_deps += [ get_label_info(dep, "label_no_toolchain") ]
            }
          }
          _abs_path_source_files = []
          if (defined(invoker.sources)) {
            foreach(source_file, invoker.sources) {
              _abs_path_source_files +=
                  [ get_path_info(source_file, "abspath") ]
            }
          }
          _abs_jar_path = ""
          if (defined(invoker.jar_path)) {
            _abs_jar_path = get_path_info(invoker.jar_path, "abspath")
          }
          _sdk_version = "current"
          if (defined(invoker.alternative_android_sdk_dep)) {
            _sdk_version = "system_current"
          }

          # See crbug/1449896 for more details about the metadata fields
          # and why they are added.
          metadata = {
            jar_path = [ _abs_jar_path ]
            source_files = _abs_path_source_files
            all_deps = _abs_deps
            target_type = [ _type ]
            sdk_version = [ _sdk_version ]
          }
        }
      } else {
        # For robolectric targets, depend only on non-java deps and the specific
        # subtargets below, which will not include __dex.
        deps = _non_java_deps
        public_deps = []
        if (defined(invoker.public_deps)) {
          public_deps +=
              filter_exclude(invoker.public_deps, java_target_patterns)
        }
      }
      if (defined(_jacoco_instrument) && _jacoco_instrument) {
        deps += [ _jacoco_dep ]
      }
      if (defined(invoker.apk_under_test)) {
        deps += [ invoker.apk_under_test ]
      }
      if (defined(_process_device_jar_target_name)) {
        public_deps += [ ":$_process_device_jar_target_name" ]
      }
      if (defined(_dex_target_name)) {
        public_deps += [ ":$_dex_target_name" ]
      }
      if (_supports_android && _is_library) {
        # Robolectric targets define __assetres, but there's no need to build it
        # by default.
        public_deps += [ ":${target_name}__assetres" ]
      }
      if (_supports_host) {
        # android_* targets define __host, but there's no need to build it by
        # default.
        public_deps += [ ":${target_name}__host" ]
      }
      if (_is_java_binary) {
        public_deps += [ ":$_java_binary_script_target_name" ]
      }
      if (!defined(data_deps)) {
        data_deps = []
      }
      if (defined(_validate_target_name)) {
        data_deps += [ ":$_validate_target_name" ]
      } else {
        data_deps += _java_validate_deps
      }
    }
  }
}

# Create a zip archive corresponding to an application bundle module.
#
# Compile all the components of a given android_apk_or_module() target into a
# zip archive suitable to later create an android_app_bundle() target. This
# archive's format is very similar to that on an APK, except for a few
# differences in internal directory layouts, and the fact that resources, as
# well as xml files, are compiled using a protocol-buffer based format (instead
# of the regular binary xml + resources.arsc).
#
# A final application bundle is built from one or more module bundle modules,
# plus some configuration file.
#
# Variables:
#   module_zip_path: Output module path.
#   build_config: Path to build_config of the android_apk_or_module() target.
#   dex_path: If module is proguarded separately from the base module, dex_path
#     is the path to its dex file and is passed directly to the creation script.
#     Otherwise, dex_path is undefined and we retrieve the module's dex file
#     using its build_config.
#   expected_libs_and_assets: Verify the list of included native libraries
#     and assets is consistent with the given expectation file.
#   expected_libs_and_assets_base: Treat expected_libs_and_assets as a diff
#     with this file as the base.
#   is_multi_abi: If true will add a library placeholder for the missing ABI if
#     either the primary or the secondary ABI has no native libraries set.
#   module_name: The module's name.
#   native_libraries_config: Path to file listing native libraries to be
#     packaged into each module.
#   proguard_enabled: Optional. True if proguarding is enabled for this
#     bundle. Default is to enable this only for release builds. Note that
#     this will always perform synchronized proguarding.
template("create_android_app_bundle_module") {
  _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
  _rebased_app_bundle_build_config =
      rebase_path(invoker.app_bundle_build_config, root_build_dir)

  forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
  _deps = invoker.deps
  _script = "//build/android/gyp/apkbuilder.py"

  # NOTE: Compared to the inputs of the "package_apk" template action,
  #       this list is much smaller, since finalize_apk is never called
  #       by apkbuild.py --format=bundle-module. This means not using
  #       apksigner and zipalign as well, nor the keystore. Other
  #       dependencies like extra native libraries are all pulled from the
  #       .build_config.json through @FileArg() references (see below) and
  #       will be listed in the generated depfile instead.
  _inputs = [
    invoker.build_config,
    invoker.app_bundle_build_config,
  ]
  _outputs = [ invoker.module_zip_path ]
  _args = [
    "--format=bundle-module",
    "--output-apk",
    rebase_path(invoker.module_zip_path, root_build_dir),
    "--resource-apk=@FileArg(" +
        "$_rebased_build_config:deps_info:proto_resources_path)",
    "--assets=@FileArg($_rebased_app_bundle_build_config:modules:${invoker.module_name}:assets)",
    "--uncompressed-assets=@FileArg(" +
        "$_rebased_build_config:deps_info:uncompressed_assets)",
    "--native-libs=@FileArg($_rebased_build_config:native:libraries)",
    "--native-libs=@FileArg($_rebased_build_config:native:loadable_modules)",
    "--native-lib-placeholders=@FileArg($_rebased_build_config" +
        ":native:native_library_placeholders)",
    "--secondary-native-lib-placeholders=@FileArg($_rebased_build_config" +
        ":native:secondary_native_library_placeholders)",
    "--android-abi=$android_app_abi",
    "--min-sdk-version=${invoker.min_sdk_version}",
    "--library-always-compress=@FileArg($_rebased_build_config:native:library_always_compress)",
  ]
  if (defined(android_app_secondary_abi)) {
    _args += [
      "--secondary-native-libs=@FileArg(" +
          "$_rebased_build_config:native:secondary_abi_libraries)",
      "--secondary-native-libs=@FileArg(" +
          "$_rebased_build_config:native:secondary_abi_loadable_modules)",
      "--secondary-android-abi=$android_app_secondary_abi",
    ]
  }
  if (defined(invoker.is_multi_abi) && invoker.is_multi_abi) {
    _args += [ "--is-multi-abi" ]
  }
  if (defined(invoker.uncompress_dex) && invoker.uncompress_dex) {
    _args += [ "--uncompress-dex" ]
  }
  if (defined(invoker.extra_assets)) {
    _args += [ "--assets=${invoker.extra_assets}" ]
  }

  # Use either provided dex path or build config path based on type of module.
  if (defined(invoker.dex_path)) {
    _inputs += [ invoker.dex_path ]
    _rebased_dex_path = rebase_path(invoker.dex_path, root_build_dir)
    _args += [ "--dex-file=$_rebased_dex_path" ]
  } else {
    _args += [ "--dex-file=@FileArg($_rebased_build_config:final_dex:path)" ]
  }

  if (treat_warnings_as_errors) {
    _args += [ "--warnings-as-errors" ]
  }

  if (defined(invoker.expected_libs_and_assets)) {
    _expectations_target = "${invoker.top_target_name}_validate_libs_and_assets"
    action_with_pydeps(_expectations_target) {
      _actual_file = "$target_gen_dir/$target_name.libs_and_assets"
      _failure_file = "$expectations_failure_dir/" +
                      string_replace(invoker.expected_libs_and_assets, "/", "_")
      inputs = [
        invoker.expected_libs_and_assets,
        invoker.build_config,
      ]
      deps = [
        invoker.build_config_target,
        invoker.app_bundle_build_config_target,
      ]
      outputs = [
        _actual_file,
        _failure_file,
      ]
      script = _script
      args = _args + [
               "--expected-file",
               rebase_path(invoker.expected_libs_and_assets, root_build_dir),
               "--actual-file",
               rebase_path(_actual_file, root_build_dir),
               "--failure-file",
               rebase_path(_failure_file, root_build_dir),
               "--only-verify-expectations",
             ]
      if (defined(invoker.expected_libs_and_assets_base)) {
        inputs += [ invoker.expected_libs_and_assets_base ]
        args += [
          "--expected-file-base",
          rebase_path(invoker.expected_libs_and_assets_base, root_build_dir),
        ]
      }
      if (fail_on_android_expectations) {
        args += [ "--fail-on-expectations" ]
      }
    }
    _deps += [ ":$_expectations_target" ]
  }

  action_with_pydeps(target_name) {
    deps = _deps
    inputs = _inputs
    outputs = _outputs
    script = _script
    depfile = "$target_gen_dir/$target_name.d"
    args = _args + [
             "--depfile",
             rebase_path(depfile, root_build_dir),
           ]
  }
}

template("rename_jar_classes") {
  action_with_pydeps(target_name) {
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                           ])
    script = "//build/android/gyp/rename_java_classes.py"
    inputs = [
      _r8_path,
      invoker.input,
    ]
    outputs = [ invoker.output ]
    args = [
      "--r8-path",
      rebase_path(_r8_path, root_build_dir),
      "--input-jar",
      rebase_path(invoker.input, root_build_dir),
      "--output-jar",
      rebase_path(invoker.output, root_build_dir),
    ]

    foreach(_rule, invoker.renaming_rules) {
      args += [
        "--map",
        _rule,
      ]
    }
  }
}
