# Copyright 2019 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//base/android/linker/config.gni")
import("//build/config/android/config.gni")
import("//build/util/version.gni")
import("//chrome/android/modules/chrome_feature_module_tmpl.gni")
import("//components/module_installer/android/module_desc_java.gni")

declare_args() {
  # Whether //chrome code and resources are in a DFM for Monochrome and
  # Trichrome bundles. This module will also include code and resources from all
  # other DFMs.
  enable_chrome_module = false
}

# Instantiates a Chrome-specific app bundle.
#
# Supports most variables of chrome_feature_module and android_app_bundle, plus:
#   module_descs: List of descriptors for modules that are part of this bundle.
#     See //chrome/android/modules/chrome_feature_modules.gni for the format of
#     a module descriptor.
#   is_64_bit_browser: (Optional) Whether Chrome (as opposed to WebView) runs in
#     64 bit.
#   include_32_bit_webview: (Optional) Whether to include 32 bit code for
#     WebView.
template("chrome_bundle") {
  _bundle_target_name = target_name
  _package_id = 126  # == 0x7e.
  _extra_modules = []
  _module_descs = []
  _enable_chrome_module =
      enable_chrome_module && invoker.is_monochrome_or_trichrome

  # If enable_chrome_module is true, //chrome Java code and resources will be
  # split out into a chrome DFM in Monochrome and Trichrome bundles. This will
  # additionally cause a few other changes in the structure of the APK:
  # - All other DFMs Java code and resources will be folded into the chrome DFM.
  # - All native code from other DFMs will be moved to the base module.
  # - All //chrome-specific manifest definitions (e.g. activities, services)
  #   will be moved to the chrome DFM AndroidManifest.xml.
  if (_enable_chrome_module) {
    _base_target_gen_dir =
        get_label_info(invoker.base_module_target, "target_gen_dir")
    _base_name = get_label_info(invoker.base_module_target, "name")
    _split_android_manifest = "${_base_target_gen_dir}/manifest/${_base_name}/AndroidManifest_split.xml"

    _java_deps = []
    _paks = []
    _pak_deps = []
    foreach(_module_desc, invoker.module_descs) {
      _module_desc_target_name =
          "${target_name}__${_module_desc.name}__module_desc_java"
      module_desc_java(_module_desc_target_name) {
        module_name = _module_desc.name
        if (defined(_module_desc.pak_deps)) {
          paks = _module_desc.paks
        }
        if (defined(_module_desc.load_native_on_get_impl)) {
          load_native_on_get_impl = _module_desc.load_native_on_get_impl
        }
      }
      _java_deps += _module_desc.java_deps + [ ":${_module_desc_target_name}" ]
      if (defined(_module_desc.pak_deps)) {
        _paks += _module_desc.paks
        _pak_deps += _module_desc.pak_deps
      }
    }
    chrome_module_desc = {
      name = "chrome"
      android_manifest = _split_android_manifest
      android_manifest_dep =
          "${invoker.base_module_target}__android_manifest__split"
      java_deps = [ "//chrome/android:chrome_all_java" ] + _java_deps
      if (enable_arcore) {
        java_deps += [
          "//chrome/browser/android/vr:ar_java",
          "//third_party/arcore-android-sdk-client:com_google_ar_core_java",
        ]
      }
      pak_deps = _pak_deps
      paks = _paks
      if (defined(invoker.chrome_deps)) {
        java_deps += invoker.chrome_deps
      }

      # Native code for all DFMs is moved to the base module's library, and paks
      # for DFMs will use the value of load_native_on_get_impl from the module
      # descriptor for that DFM.
      load_native_on_get_impl = false
    }
    _module_descs += [ chrome_module_desc ]
  } else {
    _module_descs = invoker.module_descs
  }
  foreach(_module_desc, _module_descs) {
    assert(_package_id > 2, "Too many modules, ran out of package IDs!")

    # Assert that |load_native_on_get_impl| is defined iff native libraries or
    # resources are defined.
    if (defined(_module_desc.native_deps) || defined(_module_desc.paks)) {
      assert(defined(_module_desc.load_native_on_get_impl))
    } else {
      assert(!defined(_module_desc.load_native_on_get_impl))
    }

    chrome_feature_module(
        "${_bundle_target_name}__${_module_desc.name}_bundle_module") {
      forward_variables_from(invoker,
                             [
                               "base_module_target",
                               "is_64_bit_browser",
                               "is_monochrome_or_trichrome",
                               "manifest_package",
                               "min_sdk_version",
                               "version_code",
                             ])
      module_desc = _module_desc
      version_name = chrome_version_name
      uncompress_shared_libraries =
          invoker.is_monochrome_or_trichrome || chromium_linker_supported

      # Each module needs a unique resource package ID so that we don't have ID
      # collisions between feature modules.
      package_id = _package_id
    }
    _module_desc.module_target =
        ":${_bundle_target_name}__${_module_desc.name}_bundle_module"
    _extra_modules += [ _module_desc ]
    _package_id -= 1
  }

  # Determine whether the bundle has native libraries for both the primary and
  # the secondary ABI. This is the case if we package WebView with the
  # complementary ABI of the browser.
  if (android_64bit_target_cpu) {
    if (invoker.is_64_bit_browser) {
      _is_multi_abi = invoker.include_32_bit_webview
    } else {
      _is_multi_abi = invoker.include_64_bit_webview
    }
  } else {
    _is_multi_abi = false
  }

  android_app_bundle(target_name) {
    forward_variables_from(invoker,
                           [
                             "base_module_target",
                             "bundle_name",
                             "compress_shared_libraries",
                             "enable_lint",
                             "expected_libs_and_assets",
                             "expected_libs_and_assets_base",
                             "expected_proguard_config",
                             "expected_proguard_config_base",
                             "keystore_name",
                             "keystore_password",
                             "keystore_path",
                             "lint_baseline_file",
                             "lint_min_sdk_version",
                             "lint_suppressions_file",
                             "lint_suppressions_dep",
                             "min_sdk_version",
                             "proguard_android_sdk_dep",
                             "sign_bundle",
                             "static_library_provider",
                             "static_library_synchronized_proguard",
                             "version_code",
                           ])
    command_line_flags_file = "chrome-command-line"
    proguard_enabled = !is_java_debug
    enable_language_splits = true
    extra_modules = _extra_modules
    system_image_locale_allowlist = android_apk_locales
    is_multi_abi = _is_multi_abi
    validate_services = _enable_chrome_module

    # Use a consistent baseline so that it is easy to regenerate by deleting the
    # file and re-building the "android_lint" target.
    if (defined(enable_lint) && enable_lint) {
      if (!defined(lint_baseline_file)) {
        lint_baseline_file = "//chrome/android/expectations/lint-baseline.xml"
      }
      if (!defined(lint_suppressions_file)) {
        lint_suppressions_file =
            "//chrome/android/expectations/lint-suppressions.xml"
      }
    }

    # List of DFMs that are installed by default by wrapper scripts, to make
    # testing easier. This removes the need to manually specify, e.g.,
    # "-m dev_ui" on every install or run.
    if (!_enable_chrome_module) {
      default_modules_for_testing = [ "dev_ui" ]
    }

    # NOTE: Only sign bundle for official builds since this is very slow.
    if (enable_chrome_android_internal && use_signing_keys &&
        is_official_build) {
      sign_bundle = true
      keystore_path = chrome_keystore_path
      keystore_name = chrome_keystore_name
      keystore_password = chrome_keystore_password
    }
  }
}
