# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/nacl/config.gni")
import("//ppapi/buildflags/buildflags.gni")
import("//tools/grit/grit_rule.gni")

# Applied by targets internal to content.
config("content_implementation") {
  defines = [ "CONTENT_IMPLEMENTATION" ]
  configs = [
    "//build/config/compiler:noshadowing",
    "//build/config/compiler:wexit_time_destructors",
  ]
}

assert(!is_ios, "Chromium/iOS shouldn't use anything in //content")

# When targets depend on, e.g. //content/public/browser, what happens? To
# facilitate the complexity here, the "public" targets are groups that forward
# to the right thing depending on the build mode. Say for additional
# illustration, the public browser sources also depend on the public common
# ones.
#
# The non-component build is easy:
# foo ->
#   //content/public/browser (group) ->
#     //content/public/browser:browser_sources (source set) ->
#       //content/browser (source set, this is the non-public browser target)
#       //content/public/common:common_sources (source set)
#
# The component build is more complicated because we want everybody to depend on
# one content shared library regardless of which public target they depend on:
# foo ->
#   //content/public/browser (group) ->
#     //content (shared library) ->
#       //content/public/browser:browser_sources (source set) ->
#         //content/browser (source set; this is the non-public browser target)
#         //content/public/common:common_sources (source set)
#
# That the internal content dependencies must depend on the *_sources targets
# to avoid dependency cycles, and external dependencies must depend on the
# //content/public/browser and similar targets to avoid double-linking (these
# targets make sure the dependency goes through the content shared library
# when doing a component build).
#
# TESTS
# -----
# Tests are a challenge. The content tests need to access internals of
# content/browser, for example, but the tests themselves are outside of the
# content component (which is a shared library in the component build). To
# prevent external-to-content targets from depending on private headers,
# the non-public content/browser target is not a public dep of the content
# component. But this means there is also no public path for the content
# tests and no way to restrict that just to //content/test/* if we added one.
#
# As a result, we check deps for //content/test/* only in non-component builds
# (which should verify the dependencies are correct for both component and
# non-component cases equally). There are targets like
# //content/browser:for_content_tests that allow content/test to depend on the
# //content/browser target only in non-component builds (when there are no
# linking problems) for when check is enabled.

if (!is_nacl_nonsfi) {
  content_shared_components = [
    "//content/gpu:gpu_sources",
    "//content/public/browser:browser_sources",
    "//content/public/child:child_sources",
    "//content/public/common:common_sources",
    "//content/public/gpu:gpu_sources",
    "//content/public/renderer:renderer_sources",
    "//content/public/utility:utility_sources",
  ]

  if (enable_plugins) {
    content_shared_components +=
        [ "//content/ppapi_plugin:ppapi_plugin_sources" ]
  }
}

if (is_component_build) {
  component("content") {
    public_deps =
        content_shared_components + [ "//content/public/app:both_sources" ]
  }
} else if (is_nacl_nonsfi) {
  source_set("content") {
    set_sources_assignment_filter([])
    sources = [
      "//services/service_manager/sandbox/linux/sandbox_seccomp_bpf_linux.cc",
      "common/sandbox_init_linux.cc",
      "public/common/content_switches.cc",
      "public/common/content_switches.h",
    ]
    set_sources_assignment_filter(sources_assignment_filter)
    deps = [
      "//base",
      "//media:media_buildflags",
      "//sandbox:sandbox_buildflags",
      "//sandbox/linux:sandbox",
      "//services/service_manager/sandbox",
    ]
  }
} else {
  group("content") {
    public_deps = content_shared_components
  }
}

grit("content_resources") {
  source = "content_resources.grd"

  outputs = [
    "grit/content_resources.h",
    "grit/content_resources_map.cc",
    "grit/content_resources_map.h",
    "content_resources.pak",
  ]
  grit_flags = [
    "-E",
    "root_gen_dir=" + rebase_path(root_gen_dir, root_build_dir),
  ]
  deps = [
    "//gpu/ipc/common:vulkan_interface_js",
    "//url/mojom:url_mojom_origin_js",
  ]
}

grit("dev_ui_content_resources") {
  source = "dev_ui_content_resources.grd"

  outputs = [
    "grit/dev_ui_content_resources.h",
    "dev_ui_content_resources.pak",
  ]
  grit_flags = [
    "-E",
    "root_gen_dir=" + rebase_path(root_gen_dir, root_build_dir),
  ]
  deps = [ "//content/browser/process_internals:mojo_bindings_js" ]
}

# This target exists to "hold" the content_export header so we can do proper
# inclusion testing of it.
source_set("export") {
  # Must only be used inside of content.
  visibility = [ "//content/*" ]
  sources = [ "common/content_export.h" ]
}

# In the GYP build, this file is listed in several targets. In GN just have
# those targets depend on this one. This can be depended on for any
# platform for simplicity, and is a no-op on non-Windows.
source_set("sandbox_helper_win") {
  if (is_win) {
    sources = [
      "app/sandbox_helper_win.cc",
      "public/app/sandbox_helper_win.h",
    ]

    deps = [ "//sandbox" ]
  }
}
