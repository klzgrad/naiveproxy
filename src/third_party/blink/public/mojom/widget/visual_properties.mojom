// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module blink.mojom;

import "cc/mojom/browser_controls_params.mojom";
import "services/viz/public/mojom/compositing/local_surface_id_allocation.mojom";
import "third_party/blink/public/mojom/manifest/display_mode.mojom";
import "third_party/blink/public/mojom/widget/screen_info.mojom";
import "ui/gfx/geometry/mojom/geometry.mojom";

// See public/common/widget/visual_properties.h
struct VisualProperties {
  // Information about the screen (dpi, depth, etc..).
  ScreenInfo screen_info;

  // Whether or not blink should be in auto-resize mode.
  bool auto_resize_enabled = false;

  // The minimum size for Blink if auto-resize is enabled.
  gfx.mojom.Size min_size_for_auto_resize;

  // The maximum size for Blink if auto-resize is enabled.
  gfx.mojom.Size max_size_for_auto_resize;

  // The size for the widget in DIPs.
  gfx.mojom.Size new_size;

  // The size of the area of the widget that is visible to the user, in DIPs.
  // The visible area may be empty if the visible area does not intersect with
  // the widget, for example in the case of a child frame that is entirely
  // scrolled out of the main frame's viewport. It may also be smaller than the
  // widget's size in |new_size| due to the UI hiding part of the widget, such
  // as with an on-screen keyboard.
  gfx.mojom.Size visible_viewport_size;

  // The rect of compositor's viewport in pixels. Note that for top level
  // widgets this is roughly the DSF scaled new_size put into a rect. For child
  // frame widgets it is a pixel-perfect bounds of the visible region of the
  // widget. The size would be similar to visible_viewport_size, but in physical
  // pixels and computed via very different means.
  // TODO(danakj): It would be super nice to remove one of |new_size|,
  // |visible_viewport_size| and |compositor_viewport_pixel_rect|. Their values
  // overlap in purpose, creating a very confusing situation about which to use
  // for what, and how they should relate or not.
  gfx.mojom.Rect compositor_viewport_pixel_rect;

  // Browser controls params such as top and bottom controls heights, whether
  // controls shrink blink size etc.
  cc.mojom.BrowserControlsParams? browser_controls_params;

  // Whether or not the focused node should be scrolled into view after the
  // resize.
  // Page scoped value.
  bool scroll_focused_node_into_view;

  // The local surface ID to use (if valid) and its allocation time.
  viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation;

  // Indicates whether tab-initiated fullscreen was granted.
  // Page scoped value.
  bool is_fullscreen_granted;

  // The display mode. This will be replicated amongst subframes.
  DisplayMode display_mode = DisplayMode.kUndefined;

  // This represents the latest capture sequence number requested. When this is
  // incremented, that means the caller wants to synchronize surfaces which
  // should cause a new LocalSurfaceId to be generated.
  uint32 capture_sequence_number;

  // This represents the page zoom level for a WebContents.
  // (0 is the default value which results in 1.0 zoom factor).
  // Page scoped value.
  double zoom_level;

  // This represents the page's scale factor, which changes during pinch zoom.
  // It needs to be shared with subframes.
  float page_scale_factor = 1;

  // The logical segments of the root widget, in widget-relative DIPs. This
  // property is set by the root RenderWidget in the renderer process, then
  // propagated to child local frame roots via RenderFrameProxy/
  // CrossProcessFrameConnector.
  array<gfx.mojom.Rect> root_widget_window_segments;

  // Indicates whether a pinch gesture is currently active. Originates in the
  // main frame's renderer, and needs to be shared with subframes.
  bool is_pinch_gesture_active;
};
