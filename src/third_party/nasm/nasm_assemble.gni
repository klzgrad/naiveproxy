# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This provides the nasm_assemble() template which uses NASM to assemble
# assembly files.
#
# Files to be assembled with NASM should have an extension of .asm.
#
# Parameters
#
#   nasm_flags (optional)
#       [list of strings] Pass additional flags into NASM. These are appended
#       to the command line. Note that the output format is already set up
#       based on the current toolchain so you don't need to specify these
#       things (see below).
#
#       Example: nasm_flags = [ "-Wall" ]
#
#   include_dirs (optional)
#       [list of dir names] List of additional include dirs. Note that the
#       source root and the root generated file dir is always added, just like
#       our C++ build sets up.
#
#       Example: include_dirs = [ "//some/other/path", target_gen_dir ]
#
#   defines (optional)
#       [list of strings] List of defines, as with the native code defines.
#
#       Example: defines = [ "FOO", "BAR=1" ]
#
#   inputs, deps, visibility  (optional)
#       These have the same meaning as in an action.
#
# Example
#
#   nasm_assemble("my_nasm_target") {
#     sources = [
#       "ultra_optimized_awesome.asm",
#     ]
#     include_dirs = [ "assembly_include" ]
#   }

import("//build/compiled_action.gni")

if (is_mac || is_ios) {
  if (current_cpu == "x86") {
    _nasm_flags = [ "-fmacho32" ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [ "-fmacho64" ]
  }
} else if (is_posix || is_fuchsia) {
  if (current_cpu == "x86") {
    _nasm_flags = [ "-felf32" ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [
      "-DPIC",
      "-felf64",
    ]
  }
} else if (is_win) {
  if (current_cpu == "x86") {
    _nasm_flags = [
      "-DPREFIX",
      "-fwin32",
    ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [ "-fwin64" ]
  }
}

if (is_win) {
  asm_obj_extension = "obj"
} else {
  asm_obj_extension = "o"
}

template("nasm_assemble") {
  assert(defined(invoker.sources), "Need sources defined for $target_name")

  # Only depend on NASM on x86 systems. Force compilation of .asm files for
  # ARM to fail.
  assert(current_cpu == "x86" || current_cpu == "x64")

  action_name = "${target_name}_action"
  source_set_name = target_name

  compiled_action_foreach(action_name) {
    # Only the source set can depend on this.
    visibility = [ ":$source_set_name" ]

    tool = "//third_party/nasm"

    forward_variables_from(invoker,
                           [
                             "sources",
                             "inputs",
                             "deps",
                           ])

    # Flags.
    args = _nasm_flags
    if (defined(invoker.nasm_flags)) {
      args += invoker.nasm_flags
    }

    # User defined include dirs go first.
    if (defined(invoker.include_dirs)) {
      foreach(include, invoker.include_dirs) {
        # NASM does not append path separators when processing the -I flags, so
        # -Ifoo means includes of bar look up "foobar" rather than "foo/bar".
        # Add the trailing slash for it.
        args += [ "-I" + rebase_path(include, root_build_dir) + "/" ]
      }
    }

    # Default nasm include dirs. Make it match the native build (source root and
    # root generated code directory).
    # This goes to the end of include list. Note that, as above, we must append
    # path separators because NASM does not do it itself.
    args += [
      "-I./",

      # rebase_path("//") already includes a trailing slash.
      "-I" + rebase_path("//", root_build_dir),
      "-I" + rebase_path(root_gen_dir, root_build_dir) + "/",
    ]

    # Extra defines.
    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [ "-D$def" ]
      }
    }

    # Output file.
    outputs = [
      "$target_out_dir/$source_set_name/{{source_name_part}}.o",
    ]
    args += [
      "-MD",
      rebase_path(outputs[0] + ".d", root_build_dir),
      "-o",
      rebase_path(outputs[0], root_build_dir),
      "{{source}}",
    ]

    depfile = outputs[0] + ".d"
  }

  # Gather the .o files into a linkable thing. This doesn't actually link
  # anything (a source set just compiles files to link later), but will pass
  # the object files generated by the action up the dependency chain.
  static_library(source_set_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }

    if (defined(invoker.all_dependent_configs)) {
      all_dependent_configs = invoker.all_dependent_configs
    }

    sources = get_target_outputs(":$action_name")

    # Do not publicize any header to remove build dependency.
    public = []

    deps = [
      ":$action_name",
    ]
  }
}
