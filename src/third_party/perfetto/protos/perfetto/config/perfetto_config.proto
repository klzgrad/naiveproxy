// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

option go_package = "github.com/google/perfetto/perfetto_proto";

// Begin of protos/perfetto/common/ftrace_descriptor.proto

message FtraceDescriptor {
  message AtraceCategory {
    optional string name = 1;
    optional string description = 2;
  }

  // Report the available atrace categories.
  //
  // Used by Traceur via `perfetto --query`.
  repeated AtraceCategory atrace_categories = 1;
}

// End of protos/perfetto/common/ftrace_descriptor.proto

// Begin of protos/perfetto/common/gpu_counter_descriptor.proto

// Description of GPU counters.
// This message is sent by a GPU counter producer to specify the counters
// available in the hardware.
message GpuCounterDescriptor {
  // Logical groups for a counter.  This is used in the UI to present the
  // related counters together.
  enum GpuCounterGroup {
    UNCLASSIFIED = 0;
    SYSTEM = 1;
    VERTICES = 2;
    FRAGMENTS = 3;
    PRIMITIVES = 4;
    // Includes counters relating to caching and bandwidth.
    MEMORY = 5;
    COMPUTE = 6;
  }

  message GpuCounterSpec {
    optional uint32 counter_id = 1;
    optional string name = 2;
    optional string description = 3;
    // MeasureUnit unit (deprecated)
    reserved 4;
    oneof peak_value {
      int64 int_peak_value = 5;
      double double_peak_value = 6;
    }
    repeated MeasureUnit numerator_units = 7;
    repeated MeasureUnit denominator_units = 8;
    optional bool select_by_default = 9;
    repeated GpuCounterGroup groups = 10;
  }
  repeated GpuCounterSpec specs = 1;

  // Allow producer to group counters into block to represent counter islands.
  // A capacity may be specified to indicate the number of counters that can be
  // enable simultaneously in that block.
  message GpuCounterBlock {
    // required. Unique ID for the counter group.
    optional uint32 block_id = 1;
    // optional. Number of counters supported by the block. No limit if unset.
    optional uint32 block_capacity = 2;
    // optional. Name of block.
    optional string name = 3;
    // optional. Description for the block.
    optional string description = 4;
    // list of counters that are part of the block.
    repeated uint32 counter_ids = 5;
  }
  repeated GpuCounterBlock blocks = 2;

  // optional.  Minimum sampling period supported by the producer in
  // nanoseconds.
  optional uint64 min_sampling_period_ns = 3;

  // optional.  Maximum sampling period supported by the producer in
  // nanoseconds.
  optional uint64 max_sampling_period_ns = 4;

  // optional.  The producer supports counter sampling by instrumenting the
  // command buffer.
  optional bool supports_instrumented_sampling = 5;

  // next id: 41
  enum MeasureUnit {
    NONE = 0;

    BIT = 1;
    KILOBIT = 2;
    MEGABIT = 3;
    GIGABIT = 4;
    TERABIT = 5;
    PETABIT = 6;

    BYTE = 7;
    KILOBYTE = 8;
    MEGABYTE = 9;
    GIGABYTE = 10;
    TERABYTE = 11;
    PETABYTE = 12;

    HERTZ = 13;
    KILOHERTZ = 14;
    MEGAHERTZ = 15;
    GIGAHERTZ = 16;
    TERAHERTZ = 17;
    PETAHERTZ = 18;

    NANOSECOND = 19;
    MICROSECOND = 20;
    MILLISECOND = 21;
    SECOND = 22;
    MINUTE = 23;
    HOUR = 24;

    VERTEX = 25;
    PIXEL = 26;
    TRIANGLE = 27;
    PRIMITIVE = 38;
    FRAGMENT = 39;

    MILLIWATT = 28;
    WATT = 29;
    KILOWATT = 30;

    JOULE = 31;
    VOLT = 32;
    AMPERE = 33;

    CELSIUS = 34;
    FAHRENHEIT = 35;
    KELVIN = 36;

    // Values should be out of 100.
    PERCENT = 37;

    INSTRUCTION = 40;
  }
}

// End of protos/perfetto/common/gpu_counter_descriptor.proto

// Begin of protos/perfetto/common/track_event_descriptor.proto

message TrackEventCategory {
  optional string name = 1;
  optional string description = 2;
  repeated string tags = 3;
}

message TrackEventDescriptor {
  repeated TrackEventCategory available_categories = 1;
}

// End of protos/perfetto/common/track_event_descriptor.proto

// Begin of protos/perfetto/common/data_source_descriptor.proto

// This message is sent from Producer(s) to the tracing Service when registering
// to advertise their capabilities. It describes the structure of tracing
// protos that will be produced by the data source and the supported filters.
message DataSourceDescriptor {
  // e.g., "linux.ftrace", "chromium.tracing"
  optional string name = 1;

  // When non-zero, this is a unique ID within the scope of the Producer for
  // this data source (it is NOT globally unique). This is useful to
  // differentiate between data sources with matching names when calling
  // UpdateDataSource(). This field has been introduced in November 2021
  // (v22, Android T) and is not supported on older versions.
  optional uint64 id = 7;

  // When true the data source is expected to ack the stop request through the
  // NotifyDataSourceStopped() IPC. This field has been introduced after
  // Android P in Jul 2018 and is not supported on older versions.
  optional bool will_notify_on_stop = 2;

  // When true the data source is expected to ack the start request through the
  // NotifyDataSourceStarted() IPC. This field has been introduced after
  // Android P in March 2019 and is not supported on older versions.
  optional bool will_notify_on_start = 3;

  // If true, opt into receiving the ClearIncrementalState() IPC. This should be
  // set if the data source writes packets that refer to previous trace
  // contents, and knows how to stop referring to the already-emitted data.
  optional bool handles_incremental_state_clear = 4;

  // If true, indicates that the data source does nothing upon Flush. This
  // allows the service to reduce the flush-related IPC traffic and better deal
  // with frozen producers (see go/perfetto-frozen). This is usually the case
  // for data sources like 'track_event' that don't have access to the various
  // thread task runners to post a flush task and rely purely on server-side
  // scraping.
  // Introduced in v39 / Android V.
  optional bool no_flush = 9;

  // Optional specification about available GPU counters.
  optional GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];

  optional TrackEventDescriptor track_event_descriptor = 6 [lazy = true];

  optional FtraceDescriptor ftrace_descriptor = 8 [lazy = true];
}

// End of protos/perfetto/common/data_source_descriptor.proto

// Begin of protos/perfetto/common/tracing_service_state.proto

// Reports the state of the tracing service. Used to gather details about the
// data sources connected.
// See ConsumerPort::QueryServiceState().
message TracingServiceState {
  // Describes a producer process.
  message Producer {
    // Unique ID of the producer (monotonic counter).
    optional int32 id = 1;

    // Typically matches the process name.
    optional string name = 2;

    // Unix pid of the remote process. Supported only on Linux-based systems.
    // Introduced in v24 / Android T.
    optional int32 pid = 5;

    // Unix uid of the remote process.
    optional int32 uid = 3;

    // The version of the client library used by the producer.
    // This is a human readable string with and its format varies depending on
    // the build system and the repo (standalone vs AOSP).
    // This is intended for human debugging only.
    optional string sdk_version = 4;

    // Returns true if the process appears to be frozen (Android only).
    // Introduced in Perfetto V49 / Android 24Q4.
    optional bool frozen = 6;
  }

  // Describes a data source registered by a producer. Data sources are listed
  // regardless of the fact that they are being used or not.
  message DataSource {
    // Descriptor passed by the data source when calling RegisterDataSource().
    optional DataSourceDescriptor ds_descriptor = 1;

    // ID of the producer, as per Producer.id.
    optional int32 producer_id = 2;
  }

  message TracingSession {
    // The TracingSessionID.
    optional uint64 id = 1;

    // The Unix uid of the consumer that started the session.
    // This is meaningful only if the caller is root. In all other cases only
    // tracing sessions that match the caller UID will be displayed.
    optional int32 consumer_uid = 2;

    // Internal state of the tracing session.
    // These strings are FYI only and subjected to change.
    optional string state = 3;

    // The unique_session_name as set in the trace config (might be empty).
    optional string unique_session_name = 4;

    // The number and size of each buffer.
    repeated uint32 buffer_size_kb = 5;

    // Duration, as specified in the TraceConfig.duration_ms.
    optional uint32 duration_ms = 6;

    // Number of data sources involved in the session.
    optional uint32 num_data_sources = 7;

    // Time when the session was started, in the CLOCK_REALTIME domain.
    // Available only on Linux-based systems.
    optional int64 start_realtime_ns = 8;

    // The fields below have been introduced in v42.

    // The bugreport_score, as set in TraceConfig.bugreport_score.
    optional int32 bugreport_score = 9;

    // As per TraceConfig.bugreport_filename.
    optional string bugreport_filename = 10;

    // If true, the session is in the STARTED state. If false the session is in
    // any other state (see `state` field).
    optional bool is_started = 11;
  }

  // Lists all the producers connected.
  repeated Producer producers = 1;

  // Lists the data sources available.
  repeated DataSource data_sources = 2;

  // Lists the tracing sessions active AND owned by a consumer that has the same
  // UID of the caller (or all of them if the caller is root).
  // Introduced in v24 / Android T.
  repeated TracingSession tracing_sessions = 6;

  // This is always set to true from v24 and beyond. This flag is only used to
  // tell the difference between: (1) talking to a recent service which happens
  // to have no tracing session active; (2) talking to an older version of the
  // service which will never report any tracing session.
  optional bool supports_tracing_sessions = 7;

  // Total number of tracing sessions.
  optional int32 num_sessions = 3;

  // Number of tracing sessions in the started state. Always <= num_sessions.
  optional int32 num_sessions_started = 4;

  // The version of traced (the same returned by `traced --version`).
  // This is a human readable string with and its format varies depending on
  // the build system and the repo (standalone vs AOSP).
  // This is intended for human debugging only.
  optional string tracing_service_version = 5;
}

// End of protos/perfetto/common/tracing_service_state.proto

// Begin of protos/perfetto/common/builtin_clock.proto

enum BuiltinClock {
  BUILTIN_CLOCK_UNKNOWN = 0;
  BUILTIN_CLOCK_REALTIME = 1;
  BUILTIN_CLOCK_REALTIME_COARSE = 2;
  BUILTIN_CLOCK_MONOTONIC = 3;
  BUILTIN_CLOCK_MONOTONIC_COARSE = 4;
  BUILTIN_CLOCK_MONOTONIC_RAW = 5;
  BUILTIN_CLOCK_BOOTTIME = 6;
  BUILTIN_CLOCK_TSC = 9;
  BUILTIN_CLOCK_PERF = 10;
  BUILTIN_CLOCK_MAX_ID = 63;

  reserved 7, 8;
}

// End of protos/perfetto/common/builtin_clock.proto

// Begin of protos/perfetto/config/android/android_game_intervention_list_config.proto

// Data source that lists game modes and game interventions of games
// on an Android device.
message AndroidGameInterventionListConfig {
  // If not empty, emit info about only the following list of package names
  // (exact match, no regex). Otherwise, emit info about all packages.
  repeated string package_name_filter = 1;
}

// End of protos/perfetto/config/android/android_game_intervention_list_config.proto

// Begin of protos/perfetto/config/android/android_input_event_config.proto

// Custom configuration for the "android.input.inputevent" data source.
//
// NOTE: Input traces can only be taken on debuggable (userdebug/eng) builds!
//
// Next ID: 5
message AndroidInputEventConfig {
  // Trace modes are tracing presets that are included in the system.
  enum TraceMode {
    // Preset mode for maximal tracing.
    // WARNING: This will bypass all privacy measures on debuggable builds, and
    // will record all
    //          input events processed by the system, regardless of the context
    //          in which they were processed. It should only be used for tracing
    //          on a local device or for tests. It should NEVER be used for
    //          field tracing.
    TRACE_MODE_TRACE_ALL = 0;
    // Use the tracing rules defined in this config to specify what events to
    // trace.
    TRACE_MODE_USE_RULES = 1;
  }

  // The tracing mode to use. If unspecified, it will default to
  // TRACE_MODE_USE_RULES.
  optional TraceMode mode = 1;

  // The level of tracing that should be applied to an event.
  enum TraceLevel {
    // Do not trace the input event.
    TRACE_LEVEL_NONE = 0;
    // Trace the event as a redacted event, where certain sensitive fields are
    // omitted from the trace, including the coordinates of pointer events and
    // the key/scan codes of key events.
    TRACE_LEVEL_REDACTED = 1;
    // Trace the complete event.
    TRACE_LEVEL_COMPLETE = 2;
  }

  // A rule that specifies the TraceLevel for an event based on matching
  // conditions. All matchers in the rule are optional. To trigger this rule, an
  // event must match all of its specified matchers (i.e. the matchers function
  // like a series of conditions connected by a logical 'AND' operator). A rule
  // with no specified matchers will match all events. Next ID: 6
  message TraceRule {
    // The trace level to be used for events that trigger this rule.
    // If unspecified, TRACE_LEVEL_NONE will be used by default.
    optional TraceLevel trace_level = 1;

    // --- Optional Matchers ---

    // Package matchers
    //
    // Respectively matches if all or any of the target apps for this event are
    // contained in the specified list of package names.
    //
    // Intended usage:
    //   - Use match_all_packages to selectively allow tracing for the listed
    //   packages.
    //   - Use match_any_packages to selectively deny tracing for certain
    //   packages.
    //
    // WARNING: Great care must be taken when designing rules for field tracing!
    //          This is because each event is almost always sent to more than
    //          one app.
    //              For example, when allowing tracing for a package that has a
    //              spy window
    //          over the display (e.g. SystemUI) using match_any_packages,
    //          essentially all input will be recorded on that display. This is
    //          because the events will be sent to the spy as well as the
    //          foreground app, and regardless of what the foreground app is,
    //          the event will end up being traced.
    //              Alternatively, when attempting to block tracing for specific
    //              packages using
    //          match_all_packages, no events will likely be blocked. This is
    //          because the event will also be sent to other apps (such as, but
    //          not limited to, ones with spy windows), so the matcher will not
    //          match unless all other targets are also listed under the
    //          match_all_packages list.
    repeated string match_all_packages = 2;
    repeated string match_any_packages = 3;

    // Matches if the event is secure, which means that at least one of the
    // targets of this event is using the window flag FLAG_SECURE.
    optional bool match_secure = 4;

    // Matches if there was an active IME connection while this event was being
    // processed.
    optional bool match_ime_connection_active = 5;
  }

  // The list of rules to use to determine the trace level of events.
  // Each event will be traced using the TraceLevel of the first rule that it
  // triggers from this list. The rules are evaluated in the order in which they
  // are specified. If an event does not match any of the rules,
  // TRACE_LEVEL_NONE will be used by default.
  repeated TraceRule rules = 2;

  // --- Control flags ---

  // Trace input events processed by the system as they are being dispatched
  // to application windows. All trace rules will apply.
  //   - If this flag is used without enabling trace_dispatcher_window_dispatch,
  //   it will
  //     trace InputDispatcher's inbound events (which does not include events
  //     synthesized within InputDispatcher) that match the rules.
  //   - If used with trace_dispatcher_window_dispatch, all inbound and outbound
  //   events
  //     matching the rules, including all events synthesized within
  //     InputDispatcher, will be traced.
  optional bool trace_dispatcher_input_events = 3;

  // Trace details about which windows the system is sending each input event
  // to. All trace rules will apply.
  optional bool trace_dispatcher_window_dispatch = 4;
}

// End of protos/perfetto/config/android/android_input_event_config.proto

// Begin of protos/perfetto/common/android_log_constants.proto

// Values from NDK's android/log.h.
enum AndroidLogId {
  // MAIN.
  LID_DEFAULT = 0;

  LID_RADIO = 1;
  LID_EVENTS = 2;
  LID_SYSTEM = 3;
  LID_CRASH = 4;
  LID_STATS = 5;
  LID_SECURITY = 6;
  LID_KERNEL = 7;
}

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0;

  // _DEFAULT, but should never be seen in logs.
  PRIO_UNUSED = 1;

  PRIO_VERBOSE = 2;
  PRIO_DEBUG = 3;
  PRIO_INFO = 4;
  PRIO_WARN = 5;
  PRIO_ERROR = 6;
  PRIO_FATAL = 7;
}

// End of protos/perfetto/common/android_log_constants.proto

// Begin of protos/perfetto/config/android/android_log_config.proto

message AndroidLogConfig {
  repeated AndroidLogId log_ids = 1;

  // Was |poll_ms|, deprecated.
  reserved 2;

  // If set ignores all log messages whose prio is < the given value.
  optional AndroidLogPriority min_prio = 3;

  // If non-empty ignores all log messages whose tag doesn't match one of the
  // specified values.
  repeated string filter_tags = 4;
}

// End of protos/perfetto/config/android/android_log_config.proto

// Begin of protos/perfetto/config/android/android_polled_state_config.proto

// Data source that polls for display state. This should only be used for
// backward-compatibility; AndroidSystemPropertyConfig should be preferred.
message AndroidPolledStateConfig {
  // Frequency of polling. If absent the state will be recorded once, at the
  // start of the trace.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/android_polled_state_config.proto

// Begin of protos/perfetto/config/android/android_sdk_sysprop_guard_config.proto

// Data source that controls the system properties used to guard initialization
// of track_event producers (i.e. Skia) in apps using HWUI, and certain
// processes like SurfaceFlinger.
//
// This data source only tells Skia to initialized the Perfetto SDK and start
// routing data to the Track Event system instead of ATrace. For those events
// to actually show up in a trace, the track_event data source must be used as
// well. The Perfetto SDK cannot be de-initialized, so some long-lived apps and
// processes may need to be restarted for Skia to revert to using ATrace if
// Track Events are no longer desired.
//
// In addition to switching Skia to use Perfetto's track_event data source,
// this "guard" also controls Skia's "broad tracing", which removes Skia's
// internal tracing constraints and allows the track_event config to specify
// which categories should be traced. Filtering to the "skia.always" category
// *tag* in a track_event config can be used to re-enable the standard
// constraints typically used with ATrace.
//
// Data source name: android.sdk_sysprop_guard
// Introduced in Android 14 (U) QPR1.
// Next id: 4
message AndroidSdkSyspropGuardConfig {
  // If true, configures SurfaceFlinger to initialize Skia's Perfetto
  // integration with the track_event data source in RenderEngine.
  // If false or omitted, the simpler ATrace fallback is used.
  //
  // NOTE: once enabled, Skia will only revert to ATrace if SurfaceFlinger is
  // restarted.
  //
  // Specifically this sets the following system properties:
  //   - debug.tracing.ctl.renderengine.skia_tracing_enabled
  //   - debug.tracing.ctl.renderengine.skia_use_perfetto_track_events
  //
  // Does not affect actual track_event data *collection*, which must be
  // configured separately.
  optional bool surfaceflinger_skia_track_events = 1;

  // If true, configures HWUI apps to initialize Skia's Perfetto integration
  // with the track_event data source. hwui_package_name_filter
  // can be used to control which apps are affected.
  // If false or omitted, the simpler ATrace fallback is used.
  //
  // NOTE: once enabled, Skia will only revert to ATrace if the app is
  // restarted.
  //
  // ATTENTION: affects ALL HWUI APPS if hwui_package_name_filter is not set!
  // If filtering is NOT set, this controls these GLOBAL system properties:
  //   - debug.tracing.ctl.hwui.skia_tracing_enabled
  //   - debug.tracing.ctl.hwui.skia_use_perfetto_track_events
  // If filtering IS set, this controls these APP-SPECIFIC system properties,
  // for each package listed in the filter:
  //   - debug.tracing.ctl.hwui.skia_tracing_enabled.<package.name>
  //   - debug.tracing.ctl.hwui.skia_use_perfetto_track_events.<package.name>
  //
  // Does not affect actual track_event data *collection*, which must be
  // configured separately.
  optional bool hwui_skia_track_events = 2;

  // If non-empty, hwui_skia_track_events applies to only the packages listed.
  // Otherwise, hwui_skia_track_events applies globally to all HWUI apps.
  repeated string hwui_package_name_filter = 3;
}

// End of protos/perfetto/config/android/android_sdk_sysprop_guard_config.proto

// Begin of protos/perfetto/config/android/android_system_property_config.proto

// Data source that polls for system properties.
message AndroidSystemPropertyConfig {
  // Frequency of polling. If absent the state will be recorded once, at the
  // start of the trace.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 poll_ms = 1;

  // Properties to poll. All property names must start with "debug.tracing.".
  repeated string property_name = 2;
}

// End of protos/perfetto/config/android/android_system_property_config.proto

// Begin of protos/perfetto/config/android/app_wakelock_config.proto

// Configuration for the android.app_wakelocks data source.
message AppWakelocksConfig {
  // Specifies the delay (in milliseconds) after which the data source will
  // attempt to write events. Writing less frequently reduces the trace size by
  // making better use of the packed arrays and reducing the total number of
  // TracePackets needed (which each have dozens of bytes of overhead). The
  // suggested delay is 5000ms.
  optional int32 write_delay_ms = 1;

  // When set, wakelocks held for less than this amount of time are filtered
  // from the resulting trace. Note: duration is computed by matching wakelocks
  // with identical attributes, not by tracking the underlying objects. The
  // threshold should be < the trace's flush_period_ms.
  optional int32 filter_duration_below_ms = 2;

  // When true, the owner_pid is dropped from the resulting output, reducing the
  // size of the interning tables.
  optional bool drop_owner_pid = 3;
}

// End of protos/perfetto/config/android/app_wakelock_config.proto

// Begin of protos/perfetto/config/android/cpu_per_uid_config.proto

// Data source that records CPU per UID data.
message CpuPerUidConfig {
  // Record at this frequency.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/cpu_per_uid_config.proto

// Begin of protos/perfetto/config/android/kernel_wakelocks_config.proto

// Data source that records kernel (and native) wakelock data.
message KernelWakelocksConfig {
  // Record at this frequency.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/kernel_wakelocks_config.proto

// Begin of protos/perfetto/config/android/network_trace_config.proto

// Network tracing data source that records details on all packets sent or
// received by the network.
message NetworkPacketTraceConfig {
  // Polling frequency in milliseconds. Network tracing writes to a fixed size
  // ring buffer. The polling interval should be such that the ring buffer is
  // unlikely to fill in that interval (or that filling is an acceptable risk).
  // The minimum polling rate is 100ms (values below this are ignored).
  // Introduced in Android 14 (U).
  optional uint32 poll_ms = 1;

  // The aggregation_threshold is the number of packets at which an event will
  // switch from per-packet details to aggregate details. For example, a value
  // of 50 means that if a particular event (grouped by the unique combinations
  // of metadata fields: {interface, direction, uid, etc}) has fewer than 50
  // packets, the exact timestamp and length are recorded for each packet. If
  // there were 50 or more packets in an event, it would only record the total
  // duration, packets, and length. A value of zero or unspecified will always
  /// record per-packet details. A value of 1 always records aggregate details.
  optional uint32 aggregation_threshold = 2;

  // Specifies the maximum number of packet contexts to intern at a time. This
  // prevents the interning table from growing too large and controls whether
  // interning is enabled or disabled (a value of zero disables interning and
  // is the default). When a data sources interning table reaches this amount,
  // packet contexts will be inlined into NetworkPacketEvents.
  optional uint32 intern_limit = 3;

  // The following fields specify whether certain fields should be dropped from
  // the output. Dropping fields improves normalization results, reduces the
  // size of the interning table, and slightly reduces event size.
  optional bool drop_local_port = 4;
  optional bool drop_remote_port = 5;
  optional bool drop_tcp_flags = 6;
}

// End of protos/perfetto/config/android/network_trace_config.proto

// Begin of protos/perfetto/config/android/packages_list_config.proto

// Data source that lists details (such as version code) about packages on an
// Android device.
message PackagesListConfig {
  // If not empty, emit info about only the following list of package names
  // (exact match, no regex). Otherwise, emit info about all packages.
  repeated string package_name_filter = 1;
}

// End of protos/perfetto/config/android/packages_list_config.proto

// Begin of protos/perfetto/config/android/pixel_modem_config.proto

// Data source that records events from the modem.
message PixelModemConfig {
  // Event group to record, as defined by the modem.
  enum EventGroup {
    EVENT_GROUP_UNKNOWN = 0;

    // Events suitable for low bandwidth tracing only.
    EVENT_GROUP_LOW_BANDWIDTH = 1;

    // Events suitable for high and low bandwidth tracing.
    EVENT_GROUP_HIGH_AND_LOW_BANDWIDTH = 2;
  }

  optional EventGroup event_group = 1;

  // If set, record only events with these hashes.
  repeated int64 pigweed_hash_allow_list = 2;

  // If set and allow_list is not set, deny events with these hashes.
  repeated int64 pigweed_hash_deny_list = 3;
}

// End of protos/perfetto/config/android/pixel_modem_config.proto

// Begin of protos/perfetto/common/protolog_common.proto

enum ProtoLogLevel {
  PROTOLOG_LEVEL_UNDEFINED = 0;
  PROTOLOG_LEVEL_DEBUG = 1;
  PROTOLOG_LEVEL_VERBOSE = 2;
  PROTOLOG_LEVEL_INFO = 3;
  PROTOLOG_LEVEL_WARN = 4;
  PROTOLOG_LEVEL_ERROR = 5;
  PROTOLOG_LEVEL_WTF = 6;
}
// End of protos/perfetto/common/protolog_common.proto

// Begin of protos/perfetto/config/android/protolog_config.proto

// Custom configuration for the "android.protolog" data source.
// ProtoLog is a logging mechanism that is intented to be more efficient than
// logcat. This configures what logs to capture in the tracing instance.
message ProtoLogConfig {
  enum TracingMode {
    // When using the DEFAULT tracing mode, only log groups and levels specified
    // in the group_overrides are traced.
    DEFAULT = 0;
    // When using the ENABLE_ALL tracing mode, all log groups and levels are
    // traced, unless specified in the group_overrides.
    ENABLE_ALL = 1;
  }

  // Specified the configurations for each of the logging groups. If none is
  // specified for a group the defaults will be used.
  repeated ProtoLogGroup group_overrides = 1;
  // Specified what tracing mode to use for the tracing instance.
  optional TracingMode tracing_mode = 2;
  // If set, any message with log level higher than this level (inclusive) will
  // be traced. Group overrides take precedence over this value.
  optional ProtoLogLevel default_log_from_level = 3;
}

message ProtoLogGroup {
  // The ProtoLog group name this configuration entry applies to.
  optional string group_name = 1;
  // Specify the level from which to start capturing protologs.
  // e.g. if ProtoLogLevel.WARN is specified only warning, errors and fatal log
  // message will be traced.
  optional ProtoLogLevel log_from = 2;
  // When set to true we will collect the stacktrace for each protolog message
  // in this group that we are tracing.
  optional bool collect_stacktrace = 3;
}

// End of protos/perfetto/config/android/protolog_config.proto

// Begin of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Custom configuration for the "android.surfaceflinger.layers" data source.
message SurfaceFlingerLayersConfig {
  enum Mode {
    MODE_UNSPECIFIED = 0;

    // Trace layers snapshots. A snapshot is taken every time a layers change
    // occurs.
    MODE_ACTIVE = 1;

    // Generate layers snapshots from the transactions kept in the
    // SurfaceFlinger's internal ring buffer.
    // The layers snapshots generation occurs when this data source is flushed.
    MODE_GENERATED = 2;

    // Trace a single layers snapshot.
    MODE_DUMP = 3;

    // Default mode (applied by SurfaceFlinger if no mode is specified).
    // Same as MODE_GENERATED, but triggers the layers snapshots generation only
    // when a bugreport is taken.
    MODE_GENERATED_BUGREPORT_ONLY = 4;
  }
  optional Mode mode = 1;

  enum TraceFlag {
    TRACE_FLAG_UNSPECIFIED = 0;
    TRACE_FLAG_INPUT = 0x02;
    TRACE_FLAG_COMPOSITION = 0x04;
    TRACE_FLAG_EXTRA = 0x08;
    TRACE_FLAG_HWC = 0x10;
    TRACE_FLAG_BUFFERS = 0x20;
    TRACE_FLAG_VIRTUAL_DISPLAYS = 0x40;

    // INPUT | COMPOSITION | EXTRA
    TRACE_FLAG_ALL = 0x0e;
  }
  repeated TraceFlag trace_flags = 2;
}

// End of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Begin of protos/perfetto/config/android/surfaceflinger_transactions_config.proto

// Custom configuration for the "android.surfaceflinger.transactions" data
// source.
message SurfaceFlingerTransactionsConfig {
  enum Mode {
    MODE_UNSPECIFIED = 0;

    // Default mode (applied by SurfaceFlinger if no mode is specified).
    // SurfaceFlinger writes its internal ring buffer of transactions every time
    // the data source is flushed. The ring buffer contains the SurfaceFlinger's
    // initial state and the latest transactions.
    MODE_CONTINUOUS = 1;

    // SurfaceFlinger writes the initial state and then each incoming
    // transaction until the data source is stopped.
    MODE_ACTIVE = 2;
  }
  optional Mode mode = 1;
}

// End of protos/perfetto/config/android/surfaceflinger_transactions_config.proto

// Begin of protos/perfetto/config/android/windowmanager_config.proto

// Custom configuration for the "android.windowmanager" data source.
message WindowManagerConfig {
  enum LogFrequency {
    LOG_FREQUENCY_UNSPECIFIED = 0;

    // Trace state snapshots when a frame is committed.
    LOG_FREQUENCY_FRAME = 1;

    // Trace state snapshots every time a transaction is committed.
    LOG_FREQUENCY_TRANSACTION = 2;

    // Trace single state snapshots when the data source is started.
    LOG_FREQUENCY_SINGLE_DUMP = 3;
  }
  optional LogFrequency log_frequency = 1;

  enum LogLevel {
    LOG_LEVEL_UNSPECIFIED = 0;

    // Logs all elements with maximum amount of information.
    LOG_LEVEL_VERBOSE = 1;

    // Logs all elements but doesn't write all configuration data.
    LOG_LEVEL_DEBUG = 2;

    // Logs only visible elements, with the minimum amount of performance
    // overhead
    LOG_LEVEL_CRITICAL = 3;
  }
  optional LogLevel log_level = 2;
}

// End of protos/perfetto/config/android/windowmanager_config.proto

// Begin of protos/perfetto/config/chrome/chrome_config.proto

message ChromeConfig {
  optional string trace_config = 1;

  // When enabled, the data source should only fill in fields in the output that
  // are not potentially privacy sensitive.
  optional bool privacy_filtering_enabled = 2;

  // Instead of emitting binary protobuf, convert the trace data to the legacy
  // JSON format. Note that the trace data will still be returned as a series of
  // TracePackets, but the embedded data will be JSON instead of serialized
  // protobuf.
  optional bool convert_to_legacy_json = 3;

  // Priority of the tracing session client. A higher priority session may
  // preempt a lower priority one in configurations where concurrent sessions
  // aren't supported.
  enum ClientPriority {
    UNKNOWN = 0;
    BACKGROUND = 1;
    USER_INITIATED = 2;
  }
  optional ClientPriority client_priority = 4;

  // Applicable only when using legacy JSON format.
  // If |json_agent_label_filter| is not empty, only data pertaining to
  // the specified tracing agent label (e.g. "traceEvents") will be returned.
  optional string json_agent_label_filter = 5;

  //  When enabled, event names should not contain package names.
  optional bool event_package_name_filter_enabled = 6;
}

// End of protos/perfetto/config/chrome/chrome_config.proto

// Begin of protos/perfetto/config/chrome/histogram_samples.proto

message ChromiumHistogramSamplesConfig {
  // Records when a value within the specified bounds [min_value, max_value] is
  // emitted into a Chrome histogram.
  message HistogramSample {
    optional string histogram_name = 1;
    optional int64 min_value = 2;
    optional int64 max_value = 3;
  }
  // List of histograms to record. If no histogram is specified, all histograms
  // are recorded.
  repeated HistogramSample histograms = 1;

  // Default: false (i.e. histogram names are NOT filtered out by default)
  // When true, histogram_name will be filtered out.
  optional bool filter_histogram_names = 2;
}

// End of protos/perfetto/config/chrome/histogram_samples.proto

// Begin of protos/perfetto/config/chrome/system_metrics.proto

message ChromiumSystemMetricsConfig {
  // Samples counters every X ms.
  optional uint32 sampling_interval_ms = 1;
}

// End of protos/perfetto/config/chrome/system_metrics.proto

// Begin of protos/perfetto/config/chrome/v8_config.proto

message V8Config {
  // Whether to log the actual content of scripts (e.g. content of the JS file
  // that was compiled to generate code).
  // ATTENTION: This could considerably increase the size of the resuling trace
  //            file.
  optional bool log_script_sources = 1;
  // Whether to log the generated code for jitted functions (machine code or
  // bytecode).
  // ATTENTION: This could considerably increase the size of the resuling trace
  //            file.
  optional bool log_instructions = 2;
}

// End of protos/perfetto/config/chrome/v8_config.proto

// Begin of protos/perfetto/config/etw/etw_config.proto

// Proto definition based on the struct _EVENT_TRACE_PROPERTIES definition
// See: https://learn.microsoft.com/en-us/windows/win32/api/evntrace/
// ns-evntrace-event_trace_properties
message EtwConfig {
  // The KernelFlag represent list of kernel flags that we are intrested in.
  // To get a more extensive list run 'xperf -providers k'.
  enum KernelFlag {
    CSWITCH = 0;
    DISPATCHER = 1;
  }

  // The kernel_flags determines the flags that will be used by the etw tracing
  // session. These kernel flags have been built to expose the useful events
  // captured from the kernel mode only.
  repeated KernelFlag kernel_flags = 1;
}
// End of protos/perfetto/config/etw/etw_config.proto

// Begin of protos/perfetto/config/ftrace/frozen_ftrace_config.proto

message FrozenFtraceConfig {
  // The instance name which stores the previous boot ftrace data. Required.
  optional string instance_name = 1;
}

// End of protos/perfetto/config/ftrace/frozen_ftrace_config.proto

// Begin of protos/perfetto/config/ftrace/ftrace_config.proto

// Next id: 34
message FtraceConfig {
  // Ftrace events to record, example: "sched/sched_switch".
  repeated string ftrace_events = 1;

  message KprobeEvent {
    enum KprobeType {
      KPROBE_TYPE_UNKNOWN = 0;
      KPROBE_TYPE_KPROBE = 1;
      KPROBE_TYPE_KRETPROBE = 2;
      KPROBE_TYPE_BOTH = 3;
    }
    // Kernel function name to attach to, for example "fuse_file_write_iter"
    optional string probe = 1;
    optional KprobeType type = 2;
  }

  // Ftrace events to record, specific for kprobes and kretprobes
  repeated KprobeEvent kprobe_events = 30;

  // Android-specific event categories:
  repeated string atrace_categories = 2;
  repeated string atrace_apps = 3;
  // Some processes can emit data through atrace or through the perfetto SDK via
  // the "track_event" data source. For these categories, the SDK will be
  // preferred, if possible, for this config.
  repeated string atrace_categories_prefer_sdk = 28;

  // Size of each per-cpu kernel ftrace ring buffer.
  // Not guaranteed if there are multiple concurrent tracing sessions, as the
  // buffers cannot be resized without pausing recording in the kernel.
  optional uint32 buffer_size_kb = 10;

  // If set, specifies how often the tracing daemon reads from the kernel ring
  // buffer. Not guaranteed if there are multiple concurrent tracing sessions.
  // Leave unset unless you're fine-tuning a local config.
  optional uint32 drain_period_ms = 11;

  // If set, the tracing daemon will read kernel ring buffers as soon as
  // they're filled past this percentage of occupancy. In other words, a value
  // of 50 means that a read pass is triggered as soon as any per-cpu buffer is
  // half-full. Not guaranteed if there are multiple concurrent tracing
  // sessions.
  // Currently does nothing on Linux kernels below v6.9.
  // Introduced in: perfetto v48.
  optional uint32 drain_buffer_percent = 29;

  // Configuration for compact encoding of scheduler events. When enabled (and
  // recording the relevant ftrace events), specific high-volume events are
  // encoded in a denser format than normal.
  message CompactSchedConfig {
    // If true, and sched_switch or sched_waking ftrace events are enabled,
    // record those events in the compact format.
    //
    // If the field is unset, the default is:
    // * perfetto v42.0+: enabled
    // * before: disabled
    optional bool enabled = 1;
  }
  optional CompactSchedConfig compact_sched = 12;

  // Optional filter for "ftrace/print" events.
  //
  // The filter consists of multiple rules. As soon as a rule matches (the rules
  // are processed in order), its `allow` field will be used as the outcome: if
  // `allow` is true, the event will be included in the trace, otherwise it will
  // be discarded. If an event does not match any rule, it will be allowed by
  // default (a rule with an empty prefix and allow=false, disallows everything
  // by default).
  message PrintFilter {
    message Rule {
      // Matches an atrace message of the form:
      // <type>|pid|<prefix>...
      message AtraceMessage {
        optional string type = 1;
        optional string prefix = 2;
      }
      oneof match {
        // This rule matches if `prefix` matches exactly with the beginning of
        // the "ftrace/print" "buf" field.
        string prefix = 1;
        // This rule matches if the "buf" field contains an atrace-style print
        // message as specified in `atrace_msg`.
        AtraceMessage atrace_msg = 3;
      }
      optional bool allow = 2;
    }
    repeated Rule rules = 1;
  }
  optional PrintFilter print_filter = 22;

  // Enables symbol name resolution against /proc/kallsyms.
  // It requires that either traced_probes is running as root or that
  // kptr_restrict has been manually lowered.
  // It does not disclose KASLR, symbol addresses are mangled.
  optional bool symbolize_ksyms = 13;

  // When symbolize_ksyms=true, determines whether the traced_probes daemon
  // should keep the symbol map in memory (and reuse it for future tracing
  // sessions) or clear it (saving memory) and re-create it on each tracing
  // session (wasting cpu and wall time).
  // The tradeoff is roughly:
  //  KSYMS_RETAIN: pay a fixed ~1.2 MB cost after the first trace.
  //  KSYMS_CLEANUP_ON_STOP: pay a ~300-500ms cost when starting each trace.
  // Default behavior: KSYMS_CLEANUP_ON_STOP.
  enum KsymsMemPolicy {
    KSYMS_UNSPECIFIED = 0;
    KSYMS_CLEANUP_ON_STOP = 1;
    KSYMS_RETAIN = 2;
  }
  optional KsymsMemPolicy ksyms_mem_policy = 17;

  // By default the kernel symbolizer is lazily initialized on a deferred task
  // to reduce ftrace's time-to-start-recording. Unfortunately that makes
  // ksyms integration tests hard. This flag forces the kernel symbolizer to be
  // initialized synchronously on the data source start and hence avoiding
  // timing races in tests.
  // DEPRECATED in v28 / Android U. This is now the default behavior, setting it
  // to true is a no-op.
  optional bool initialize_ksyms_synchronously_for_testing = 14
      [deprecated = true];

  // When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
  // this option causes traced_probes to enable the "kmem/rss_stat_throttled"
  // event instead if present, and fall back to "kmem/rss_stat" if not present.
  // The historical context for this is the following:
  // - Up to Android S (12), the rss_stat was internally throttled in its
  //   kernel implementation.
  // - A change introduced in the kernels after S has introduced a new
  //   "rss_stat_throttled" making the original "rss_stat" event unthrottled
  //   (hence very spammy).
  // - Not all Android T/13 devices will receive a new kernel though, hence we
  //   need to deal with both cases.
  // For more context: go/rss-stat-throttled.
  optional bool throttle_rss_stat = 15;

  // If true, use self-describing proto messages when writing events not known
  // at compile time (aka generic events). Each event bundle will have a set of
  // serialised proto descriptors for events within that bundle.
  // Added in: perfetto v50.
  optional bool denser_generic_event_encoding = 32;

  // If true, avoid enabling events that aren't statically known by
  // traced_probes. Otherwise, the default is to emit such events as
  // GenericFtraceEvent protos.
  // Prefer to keep this flag at its default. This was added for Android
  // tracing, where atrace categories and/or atrace HAL requested events can
  // expand to events that aren't of interest to the tracing user.
  // Introduced in: Android T.
  optional bool disable_generic_events = 16;

  // The subset of syscalls to record. To record all syscalls, leave this unset
  // and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
  // * before perfetto v43, requires the config to also enable
  //   raw_syscalls/sys_{enter,exit}.
  // * perfetto v43+ does the right thing if you set only this field.
  // Example: ["sys_read", "sys_open"].
  // Introduced in: Android U.
  repeated string syscall_events = 18;

  // If true, enable the "function_graph" kernel tracer that emits events
  // whenever a kernel function is entered and exited
  // (funcgraph_entry/funcgraph_exit).
  // Notes on use:
  // * Requires |symbolize_ksyms| for function name resolution.
  // * Use |function_filters| or |function_graph_roots| to constrain the traced
  //   set of functions, otherwise the event bandwidth will be too high for
  //   practical use.
  // * The data source might be rejected if there is already a concurrent
  //   ftrace data source that does not use function graph itself, as we do not
  //   support switching kernel tracers mid-trace.
  // * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
  //   enabled if "cat /sys/kernel/tracing/available_tracers" includes
  //   "function_graph".
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  optional bool enable_function_graph = 19;

  // Constrains the set of functions traced when |enable_function_graph| is
  // true. Supports globs, e.g. "sched*". You can specify multiple filters,
  // in which case all matching functions will be traced. See kernel
  // documentation on ftrace "set_ftrace_filter" file for more details.
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  repeated string function_filters = 20;

  // If |enable_function_graph| is true, trace this set of functions *and* all
  // of its callees. Supports globs. Can be set together with
  // |function_filters|, in which case only callees matching the filter will be
  // traced. If setting both, you most likely want all roots to also be
  // included in |function_filters|.
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  repeated string function_graph_roots = 21;

  // If true, does not clear ftrace buffers before the start of the program.
  // This makes sense only if this is the first ftrace data source instance
  // created after the daemon has been started. Can be useful for gathering boot
  // traces, if ftrace has been separately configured (e.g. via kernel
  // commandline).
  optional bool preserve_ftrace_buffer = 23;

  // If true, overrides the default timestamp clock and uses a raw hardware
  // based monotonic clock for getting timestamps.
  // * Introduced in: Android U.
  optional bool use_monotonic_raw_clock = 24;

  // If |instance_name| is not empty, then attempt to use that tracefs instance
  // for event recording. Normally, this means
  // `/sys/kernel/tracing/instances/$instance_name`.
  //
  // The name "hyp" is reserved.
  //
  // The instance must already exist, the tracing daemon *will not* create it
  // for you as it typically doesn't have such permissions.
  // Only a subset of features is guaranteed to work with non-default instances,
  // at the time of writing:
  //  * ftrace_events
  //  * buffer_size_kb
  optional string instance_name = 25;

  // If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
  // implementation to choose a bigger buffer size.
  //
  // Most configs for perfetto v43+ should simply leave both fields unset.
  //
  // If you need a config compatible with a range of perfetto builds and you
  // used to set a non-default buffer_size_kb, consider setting both fields.
  // Example:
  //   buffer_size_kb: 4096
  //   buffer_size_lower_bound: true
  // On older builds, the per-cpu buffers will be exactly 4 MB.
  // On v43+, buffers will be at least 4 MB.
  // In both cases, neither is guaranteed if there are other concurrent
  // perfetto ftrace sessions, as the buffers cannot be resized without pausing
  // the recording in the kernel.
  // Introduced in: perfetto v43.
  optional bool buffer_size_lower_bound = 27;

  // For perfetto developer use. If true and on a debuggable android build,
  // serialise raw tracing pages that the implementation cannot parse.
  optional bool debug_ftrace_abi = 31;

  // Previously drain_buffer_percent, perfetto v43-v47.
  reserved 26;

  // If |enable_function_graph| is true, only trace the specified
  // number of calls down the stack. Sets the max_graph_depth value
  // in sys/kernel/tracing/
  //
  // Only respected for the first tracing session that enables
  // function_graph tracing.
  //
  // Introduced in: perfetto v51.
  // Supported on: Android 25Q3+.
  optional uint32 function_graph_max_depth = 33;
}

// End of protos/perfetto/config/ftrace/ftrace_config.proto

// Begin of protos/perfetto/config/gpu/gpu_counter_config.proto

message GpuCounterConfig {
  // Desired sampling interval for counters.
  optional uint64 counter_period_ns = 1;

  // List of counters to be sampled. Counter IDs correspond to the ones
  // described in GpuCounterSpec in the data source descriptor.
  repeated uint32 counter_ids = 2;

  // Sample counters by instrumenting command buffers.
  optional bool instrumented_sampling = 3;

  // Fix gpu clock rate during trace session.
  optional bool fix_gpu_clock = 4;
}

// End of protos/perfetto/config/gpu/gpu_counter_config.proto

// Begin of protos/perfetto/config/gpu/gpu_renderstages_config.proto

message GpuRenderStagesConfig {
  // Enable to separate the color and depth/stencil load and store stages
  // into a separate stages. If disabled, the depth/stencil load and store
  // stages will be combined.  Disabled by default. This option has no effect if
  // Low Overhead mode is enabled.
  optional bool full_loadstore = 1;

  // Use the low overhead mode for traces. In this mode render stages are
  // combined into a single workload stage. This provides less granular data but
  // induces minimal GPU overhead. Disabled by default.
  optional bool low_overhead = 2;

  // Trace metrics to capture for each render stage
  repeated string trace_metrics = 3;
}

// End of protos/perfetto/config/gpu/gpu_renderstages_config.proto

// Begin of protos/perfetto/config/gpu/vulkan_memory_config.proto

message VulkanMemoryConfig {
  // Tracking driver memory usage events
  optional bool track_driver_memory_usage = 1;

  // Tracking device memory usage events
  optional bool track_device_memory_usage = 2;
}

// End of protos/perfetto/config/gpu/vulkan_memory_config.proto

// Begin of protos/perfetto/config/inode_file/inode_file_config.proto

message InodeFileConfig {
  message MountPointMappingEntry {
    optional string mountpoint = 1;
    repeated string scan_roots = 2;
  }

  // How long to pause between batches.
  optional uint32 scan_interval_ms = 1;

  // How long to wait before the first scan in order to accumulate inodes.
  optional uint32 scan_delay_ms = 2;

  // How many inodes to scan in one batch.
  optional uint32 scan_batch_size = 3;

  // Do not scan for inodes not found in the static map.
  optional bool do_not_scan = 4;

  // If non-empty, only scan inodes corresponding to block devices named in
  // this list.
  repeated string scan_mount_points = 5;

  // When encountering an inode belonging to a block device corresponding
  // to one of the mount points in this map, scan its scan_roots instead.
  repeated MountPointMappingEntry mount_point_mapping = 6;
}

// End of protos/perfetto/config/inode_file/inode_file_config.proto

// Begin of protos/perfetto/config/interceptors/console_config.proto

message ConsoleConfig {
  enum Output {
    OUTPUT_UNSPECIFIED = 0;
    OUTPUT_STDOUT = 1;
    OUTPUT_STDERR = 2;
  }
  optional Output output = 1;
  optional bool enable_colors = 2;
}

// End of protos/perfetto/config/interceptors/console_config.proto

// Begin of protos/perfetto/config/interceptor_config.proto

// Configuration for trace packet interception. Used for diverting trace data to
// non-Perfetto sources (e.g., logging to the console, ETW) when using the
// Perfetto SDK.
message InterceptorConfig {
  // Matches the name given to RegisterInterceptor().
  optional string name = 1;

  optional ConsoleConfig console_config = 100;
}

// End of protos/perfetto/config/interceptor_config.proto

// Begin of protos/perfetto/config/power/android_power_config.proto

message AndroidPowerConfig {
  enum BatteryCounters {
    BATTERY_COUNTER_UNSPECIFIED = 0;

    // Coulomb counter.
    BATTERY_COUNTER_CHARGE = 1;

    // Charge (%).
    BATTERY_COUNTER_CAPACITY_PERCENT = 2;

    // Instantaneous current.
    BATTERY_COUNTER_CURRENT = 3;

    // Avg current.
    BATTERY_COUNTER_CURRENT_AVG = 4;

    // Instantaneous voltage.
    BATTERY_COUNTER_VOLTAGE = 5;
  }
  optional uint32 battery_poll_ms = 1;
  repeated BatteryCounters battery_counters = 2;

  // Where available enables per-power-rail measurements.
  optional bool collect_power_rails = 3;

  // Provides a breakdown of energy estimation for various subsystem (e.g. GPU).
  // Available from Android S.
  optional bool collect_energy_estimation_breakdown = 4;

  // Provides a breakdown of time in state for various subsystems.
  // Available from Android U.
  optional bool collect_entity_state_residency = 5;
}

// End of protos/perfetto/config/power/android_power_config.proto

// Begin of protos/perfetto/config/process_stats/process_stats_config.proto

message ProcessStatsConfig {
  enum Quirks {
    QUIRKS_UNSPECIFIED = 0;

    // This has been deprecated and ignored as per 2018-05-01. Full scan at
    // startup is now disabled by default and can be re-enabled using the
    // |scan_all_processes_on_start| arg.
    DISABLE_INITIAL_DUMP = 1 [deprecated = true];

    DISABLE_ON_DEMAND = 2;
  }
  repeated Quirks quirks = 1;

  // If enabled all processes will be scanned and dumped when the trace starts.
  optional bool scan_all_processes_on_start = 2;

  // If enabled thread names are also recoded (this is redundant if sched_switch
  // is enabled).
  optional bool record_thread_names = 3;

  // If > 0 samples counters (see process_stats.proto) from
  // /proc/pid/status and oom_score_adj every X ms.
  // It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 proc_stats_poll_ms = 4;

  // id 5 never used

  // This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
  // (default: |proc_stats_poll_ms|). If = 0, will be set to
  // |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
  // multiple.
  optional uint32 proc_stats_cache_ttl_ms = 6;

  // Niche feature: If true this will resolve file descriptors for each process
  // so these can be mapped to their actual device or file.
  // Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
  // new fds opened after initially scanning a process will not be
  // recognized.
  optional bool resolve_process_fds = 9;

  // If true, output will include memory stats from /proc/pid/smaps_rollup.
  //
  // Does NOT work with the Android system daemon by default, as it requires
  // running the recording process (traced_probes or tracebox) as root. It is
  // possible to avoid the root requirement, but the exact steps depend on the
  // Linux distibution. The proc file requires passing a PTRACE_MODE_READ
  // check, and might be further covered by the procfs "hidepid" mount option.
  optional bool scan_smaps_rollup = 10;

  // If true: process descriptions will include process age (starttime in
  // /proc/pid/stat).
  // Introduced in: perfetto v44.
  optional bool record_process_age = 11;

  // If true and |proc_stats_poll_ms| is true, process stats will include time
  // spent running in user/kernel mode (utime/stime in /proc/pid/stat).
  // Introduced in: perfetto v44.
  optional bool record_process_runtime = 12;

  // record_thread_time_in_state
  reserved 7;
  // thread_time_in_state_cache_size
  reserved 8;
}

// End of protos/perfetto/config/process_stats/process_stats_config.proto

// Begin of protos/perfetto/config/profiling/heapprofd_config.proto

// Configuration for go/heapprofd.
// Next id: 28
message HeapprofdConfig {
  message ContinuousDumpConfig {
    // ms to wait before first dump.
    optional uint32 dump_phase_ms = 5;
    // ms to wait between following dumps.
    optional uint32 dump_interval_ms = 6;
  }

  // Sampling rate for all heaps not specified via heap_sampling_intervals.
  //
  // These are:
  // * All heaps if heap_sampling_intervals is empty.
  // * Those profiled due to all_heaps and not named in heaps if
  //   heap_sampling_intervals is not empty.
  // * The implicit libc.malloc heap if heaps is empty.
  //
  // Set to 1 for perfect accuracy.
  // Otherwise, sample every sample_interval_bytes on average.
  //
  // See
  // https://perfetto.dev/docs/data-sources/native-heap-profiler#sampling-interval
  // for more details.
  //
  // BUGS
  // Before Android 12, setting this to 0 would crash the target process.
  //
  // N.B. This must be explicitly set to a non-zero value for all heaps (with
  // this field or with heap_sampling_intervals), otherwise the producer will
  // not start.
  optional uint64 sampling_interval_bytes = 1;

  // If less than the given numbers of bytes are left free in the shared
  // memory buffer, increase sampling interval by a factor of two.
  // Adaptive sampling is disabled when set to 0.
  optional uint64 adaptive_sampling_shmem_threshold = 24;
  // Stop doubling the sampling_interval once the sampling interval has reached
  // this value.
  optional uint64 adaptive_sampling_max_sampling_interval_bytes = 25;

  // E.g. surfaceflinger, com.android.phone
  // This input is normalized in the following way: if it contains slashes,
  // everything up to the last slash is discarded. If it contains "@",
  // everything after the first @ is discared.
  // E.g. /system/bin/surfaceflinger@1.0 normalizes to surfaceflinger.
  // This transformation is also applied to the processes' command lines when
  // matching.
  repeated string process_cmdline = 2;

  // For watermark based triggering or local debugging.
  repeated uint64 pid = 4;

  // Only profile target if it was installed by one of the packages given.
  // Special values are:
  // * @system: installed on the system partition
  // * @product: installed on the product partition
  // * @null: sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 26;

  // Which heaps to sample, e.g. "libc.malloc". If left empty, only samples
  // "malloc".
  //
  // Introduced in Android 12.
  repeated string heaps = 20;

  // Which heaps not to sample, e.g. "libc.malloc". This is useful when used in
  // combination with all_heaps;
  //
  // Introduced in Android 12.
  repeated string exclude_heaps = 27;

  optional bool stream_allocations = 23;

  // If given, needs to be the same length as heaps and gives the sampling
  // interval for the respective entry in heaps.
  //
  // Otherwise, sampling_interval_bytes is used.
  //
  // It is recommended to set sampling_interval_bytes to a reasonable default
  // value when using this, as a value of 0 for sampling_interval_bytes will
  // crash the target process before Android 12.
  //
  // Introduced in Android 12.
  //
  // All values must be non-zero or the producer will not start.
  repeated uint64 heap_sampling_intervals = 22;

  // Sample all heaps registered by target process. Introduced in Android 12.
  optional bool all_heaps = 21;

  // Profile all processes eligible for profiling on the system.
  // See
  // https://perfetto.dev/docs/data-sources/native-heap-profiler#heapprofd-targets
  // for which processes are eligible.
  //
  // On unmodified userdebug builds, this will lead to system crashes. Zygote
  // will crash when trying to launch a new process as it will have an
  // unexpected open socket to heapprofd.
  //
  // heapprofd will likely be overloaded by the amount of data for low
  // sampling intervals.
  optional bool all = 5;

  // Do not profile processes whose anon RSS + swap < given value.
  // Introduced in Android 11.
  optional uint32 min_anonymous_memory_kb = 15;

  // Stop profile if heapprofd memory usage goes beyond the given value.
  // Introduced in Android 11.
  optional uint32 max_heapprofd_memory_kb = 16;

  // Stop profile if heapprofd CPU time since start of this data-source
  // goes beyond given value.
  // Introduced in Android 11.
  optional uint64 max_heapprofd_cpu_secs = 17;

  // Do not emit function names for mappings starting with this prefix.
  // E.g. /system to not emit symbols for any system libraries.
  repeated string skip_symbol_prefix = 7;

  // Dump at a predefined interval.
  optional ContinuousDumpConfig continuous_dump_config = 6;

  // Size of the shared memory buffer between the profiled processes and
  // heapprofd. Defaults to 8 MiB. If larger than 500 MiB, truncated to 500
  // MiB.
  //
  // Needs to be:
  // * at least 8192,
  // * a power of two,
  // * a multiple of 4096.
  optional uint64 shmem_size_bytes = 8;

  // When the shmem buffer is full, block the client instead of ending the
  // trace. Use with caution as this will significantly slow down the target
  // process.
  optional bool block_client = 9;

  // If set, stop the trace session after blocking the client for this
  // timeout. Needs to be larger than 100 us, otherwise no retries are done.
  // Introduced in Android 11.
  optional uint32 block_client_timeout_us = 14;

  // Do not profile processes from startup, only match already running
  // processes.
  //
  // Can not be set at the same time as no_running.
  // Introduced in Android 11.
  optional bool no_startup = 10;

  // Do not profile running processes. Only match processes on startup.
  //
  // Can not be set at the same time as no_startup.
  // Introduced in Android 11.
  optional bool no_running = 11;

  // deprecated idle_allocations.
  reserved 12;

  // Cause heapprofd to emit a single dump at the end, showing the memory usage
  // at the point in time when the sampled heap usage of the process was at its
  // maximum. This causes ProfilePacket.HeapSample.self_max to be set, and
  // self_allocated and self_freed to not be set.
  // Introduced in Android 11.
  optional bool dump_at_max = 13;

  // FEATURE FLAGS. THERE BE DRAGONS.

  // Escape hatch if the session is being torn down because of a forked child
  // that shares memory space, but is not correctly identified as a vforked
  // child.
  // Introduced in Android 11.
  optional bool disable_fork_teardown = 18;

  // We try to automatically detect when a target applicatation vforks but then
  // does a memory allocation (or free). This auto-detection can be disabled
  // with this.
  // Introduced in Android 11.
  optional bool disable_vfork_detection = 19;
}

// End of protos/perfetto/config/profiling/heapprofd_config.proto

// Begin of protos/perfetto/config/profiling/java_hprof_config.proto

// Configuration for managed app heap graph snapshots.
message JavaHprofConfig {
  // If dump_interval_ms != 0, the following configuration is used.
  message ContinuousDumpConfig {
    // ms to wait before first continuous dump.
    // A dump is always created at the beginning of the trace.
    optional uint32 dump_phase_ms = 1;
    // ms to wait between following dumps.
    optional uint32 dump_interval_ms = 2;
    // If true, scans all the processes to find `process_cmdline` and filter by
    // `min_anonymous_memory_kb` only at data source start. Default on Android
    // S-.
    //
    // If false, rescans all the processes to find on every dump. Default on
    // Android T+.
    optional bool scan_pids_only_on_start = 3;
  }

  // Command line allowlist, matched against the /proc/<pid>/cmdline (not the
  // comm string). The semantics of this field were changed since its original
  // introduction.
  //
  // On Android T+ (13+), this field can specify a single wildcard (*), and
  // the profiler will attempt to match it in two possible ways:
  // * if the pattern starts with a '/', then it is matched against the first
  //   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
  //   "/bin/echo".
  // * otherwise the pattern is matched against the part of argv0
  //   corresponding to the binary name (this is unrelated to /proc/pid/exe).
  //   For example "echo" would match "/bin/echo".
  //
  // On Android S (12) and below, both this pattern and /proc/pid/cmdline get
  // normalized prior to an exact string comparison. Normalization is as
  // follows: (1) trim everything beyond the first null or "@" byte; (2) if
  // the string contains forward slashes, trim everything up to and including
  // the last one.
  //
  // Implementation note: in either case, at most 511 characters of cmdline
  // are considered.
  repeated string process_cmdline = 1;

  // For watermark based triggering or local debugging.
  repeated uint64 pid = 2;

  // Only profile target if it was installed by one of the packages given.
  // Special values are:
  // * @system: installed on the system partition
  // * @product: installed on the product partition
  // * @null: sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 7;

  // Dump at a predefined interval.
  optional ContinuousDumpConfig continuous_dump_config = 3;

  // Do not profile processes whose anon RSS + swap < given value.
  optional uint32 min_anonymous_memory_kb = 4;

  // Include the process' /proc/self/smaps.
  // This only shows maps that:
  // * start with /system
  // * start with /vendor
  // * start with /data/app
  // * contain "extracted in memory from Y", where Y matches any of the above
  optional bool dump_smaps = 5;

  // Exclude objects of the following types from the profile. This can be
  // useful if lots of uninteresting objects, e.g. "sun.misc.Cleaner".
  repeated string ignored_types = 6;
}

// End of protos/perfetto/config/profiling/java_hprof_config.proto

// Begin of protos/perfetto/common/perf_events.proto

message PerfEvents {
  // The primary event to count. If recording multiple events, this
  // counter is the "group leader".
  // Commented from the perspective of its use in |PerfEventConfig|.
  // Next id: 12
  message Timebase {
    // How often to snapshot the counter, along with any follower events and
    // any additional sampled data such as callstacks.
    //
    // This choice also controls how the readings are taken:
    // * With |frequency| or |period|, samples are taken by the kernel
    //   into a ring buffer. Analogous to `perf record`.
    // * With |poll_period_ms|, the userspace periodically snapshots
    //   the counters using the read syscall. Analogous to `perf stat -I`.
    // Prefer the sampling options unless you're recording PMUs whose
    // perf drivers only support the reading mode.
    //
    // If unset, an implementation-defined sampling default is used.
    oneof interval {
      // Per-cpu sampling frequency in Hz, as requested from the kernel. Not the
      // same as 1/period.
      // Details: the actual sampling will still be based on a period, but the
      // kernel will dynamically adjust it based on the observed event rate, to
      // approximate this frequency. Works best with steady-rate events like
      // timers.
      // Not guaranteed to be honored as the kernel can throttle the sampling
      // rate if it's too high.
      uint64 frequency = 2;

      // Per-cpu sampling will occur every |period| counts of |event|.
      // Prefer |frequency| by default, as it's easier to oversample with a
      // fixed period.
      // Not guaranteed to be honored as the kernel can throttle the sampling
      // rate if it's too high.
      uint64 period = 1;

      // Per-cpu values are read by the userspace every interval. If using this
      // mode, only follower events are supported. Options such as
      // |PerfEventConfig.CallstackSampling| are incompatible.
      // The period can't be guaranteed to be exact since the readings are taken
      // by userspace.
      uint32 poll_period_ms = 6;
    }

    // Counting event to use as the timebase.
    // If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
    // which is what you usually want.
    oneof event {
      Counter counter = 4;
      Tracepoint tracepoint = 3;
      RawEvent raw_event = 5;
    }

    // If set, samples will be timestamped with the given clock.
    // If unset, the clock is chosen by the implementation.
    // For software events, prefer PERF_CLOCK_BOOTTIME. However it cannot be
    // used for hardware events (due to interrupt safety), for which the
    // recommendation is to use one of the monotonic clocks.
    optional PerfClock timestamp_clock = 11;

    // Optional arbitrary name for the event, to identify it in the parsed
    // trace. Does *not* affect the profiling itself. If unset, the trace
    // parser will choose a suitable name.
    optional string name = 10;
  }

  // Builtin counter names from the uapi header. Commented with their perf tool
  // aliases.
  // TODO(rsavitski): consider generating enums for cache events (should be
  // finite), and generally make this list as extensive as possible. Excluding
  // things like dynamic PMUs since those don't fit into a static enum.
  // Next id: 21
  enum Counter {
    UNKNOWN_COUNTER = 0;

    // cpu-clock
    SW_CPU_CLOCK = 1;
    // page-faults, faults
    SW_PAGE_FAULTS = 2;
    // task-clock
    SW_TASK_CLOCK = 3;
    // context-switches, cs
    SW_CONTEXT_SWITCHES = 4;
    // cpu-migrations, migrations
    SW_CPU_MIGRATIONS = 5;
    // minor-faults
    SW_PAGE_FAULTS_MIN = 6;
    // major-faults
    SW_PAGE_FAULTS_MAJ = 7;
    // alignment-faults
    SW_ALIGNMENT_FAULTS = 8;
    // emulation-faults
    SW_EMULATION_FAULTS = 9;
    // dummy
    SW_DUMMY = 20;

    // cpu-cycles, cycles
    HW_CPU_CYCLES = 10;
    // instructions
    HW_INSTRUCTIONS = 11;
    // cache-references
    HW_CACHE_REFERENCES = 12;
    // cache-misses
    HW_CACHE_MISSES = 13;
    // branch-instructions, branches
    HW_BRANCH_INSTRUCTIONS = 14;
    // branch-misses
    HW_BRANCH_MISSES = 15;
    // bus-cycles
    HW_BUS_CYCLES = 16;
    // stalled-cycles-frontend, idle-cycles-frontend
    HW_STALLED_CYCLES_FRONTEND = 17;
    // stalled-cycles-backend, idle-cycles-backend
    HW_STALLED_CYCLES_BACKEND = 18;
    // ref-cycles
    HW_REF_CPU_CYCLES = 19;
  }

  message Tracepoint {
    // Group and name for the tracepoint, acceptable forms:
    // * "sched/sched_switch"
    // * "sched:sched_switch"
    optional string name = 1;

    // Optional field-level filter for the tracepoint. Only events matching this
    // filter will be counted (and therefore contribute to the sampling period).
    // Example: "prev_pid >= 42 && next_pid == 0".
    // For full syntax, see kernel documentation on "Event filtering":
    // https://www.kernel.org/doc/Documentation/trace/events.txt
    optional string filter = 2;
  }

  // Syscall-level description of the event, propagated to the perf_event_attr
  // struct. Primarily for local use-cases, since the event availability and
  // encoding is hardware-specific.
  message RawEvent {
    optional uint32 type = 1;
    optional uint64 config = 2;
    optional uint64 config1 = 3;
    optional uint64 config2 = 4;
  }

  // Subset of clocks that is supported by perf timestamping.
  // CLOCK_TAI is excluded since it's not expected to be used in practice, but
  // would require additions to the trace clock synchronisation logic.
  enum PerfClock {
    UNKNOWN_PERF_CLOCK = 0;
    PERF_CLOCK_REALTIME = 1;
    PERF_CLOCK_MONOTONIC = 2;
    PERF_CLOCK_MONOTONIC_RAW = 3;
    PERF_CLOCK_BOOTTIME = 4;
  }
}

// Additional events associated with a leader.
// Configuration is similar to Timebase event. Because data acquisition is
// driven by the leader there is no option to configure the clock or the
// frequency.
message FollowerEvent {
  oneof event {
    PerfEvents.Counter counter = 1;
    PerfEvents.Tracepoint tracepoint = 2;
    PerfEvents.RawEvent raw_event = 3;
  }
  optional string name = 4;
}

// End of protos/perfetto/common/perf_events.proto

// Begin of protos/perfetto/config/profiling/perf_event_config.proto

// Configuration for the traced_perf profiler.
//
// Example config for basic cpu profiling:
//   perf_event_config {
//     timebase {
//       frequency: 80
//     }
//     callstack_sampling {
//       scope {
//         target_cmdline: "surfaceflinger"
//         target_cmdline: "system_server"
//       }
//       kernel_frames: true
//     }
//   }
//
// Next id: 21
message PerfEventConfig {
  // What event to sample on, and how often.
  // Defined in common/perf_events.proto.
  optional PerfEvents.Timebase timebase = 15;

  // Other events associated with the leader described in the timebase.
  repeated FollowerEvent followers = 19;

  // If set, the profiler will sample userspace processes' callstacks at the
  // interval specified by the |timebase|.
  // If unset, the profiler will record only the event counts.
  optional CallstackSampling callstack_sampling = 16;

  // List of cpu indices for counting. If empty, the default is all cpus.
  //
  // Note: this is not inside |callstack_sampling.scope| as it also applies to
  // counter-only traces. A future change will likely reorganise the options,
  // but this field will continue to be supported.
  //
  // Available since: perfetto v50.
  repeated uint32 target_cpu = 20;

  //
  // Kernel <-> userspace ring buffer options:
  //

  // How often the per-cpu ring buffers are read by the producer.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_read_period_ms = 8;

  // Size (in 4k pages) of each per-cpu ring buffer that is filled by the
  // kernel. If set, must be a power of two.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_pages = 3;

  //
  // Daemon's resource usage limits:
  //

  // Drop samples if the heap memory held by the samples in the unwinder queue
  // is above the given limit. This counts the memory across all concurrent data
  // sources (not just this one's), and there is no fairness guarantee - the
  // whole quota might be used up by a concurrent source.
  optional uint64 max_enqueued_footprint_kb = 17;

  // Stop the data source if traced_perf's combined {RssAnon + Swap} memory
  // footprint exceeds this value.
  optional uint32 max_daemon_memory_kb = 13;

  //
  // Uncommon options:
  //

  // Timeout for the remote /proc/<pid>/{maps,mem} file descriptors for a
  // sampled process. This is primarily for Android, where this lookup is
  // asynchronous. As long as the producer is waiting, the associated samples
  // will be kept enqueued (putting pressure on the capacity of the shared
  // unwinding queue). Once a lookup for a process expires, all associated
  // samples are discarded. However, if the lookup still succeeds after the
  // timeout, future samples will be handled normally.
  // If unset, an implementation-defined default is used.
  optional uint32 remote_descriptor_timeout_ms = 9;

  // Optional period for clearing state cached by the unwinder. This is a heavy
  // operation that is only necessary for traces that target a wide set of
  // processes, and require the memory footprint to be reset periodically.
  // If unset, the cached state will not be cleared.
  optional uint32 unwind_state_clear_period_ms = 10;

  // If set, only profile target if it was installed by a package with one of
  // these names. Special values:
  // * "@system": installed on the system partition
  // * "@product": installed on the product partition
  // * "@null": sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 18;

  //
  // Deprecated (superseded by options above):
  //
  // Do not set *any* of these fields in new configs.
  //

  // Note: legacy configs had to set |all_cpus| to true to pass parsing.
  // We rely on this to detect such configs.
  optional bool all_cpus = 1;
  optional uint32 sampling_frequency = 2;
  optional bool kernel_frames = 12;
  repeated int32 target_pid = 4;
  repeated string target_cmdline = 5;
  repeated int32 exclude_pid = 6;
  repeated string exclude_cmdline = 7;
  optional uint32 additional_cmdline_count = 11;
  // previously |tracepoint|
  reserved 14;

  //
  // Sub-messages (nested for generated code namespacing).
  //

  message CallstackSampling {
    // Defines a set of processes for which samples are retained/skipped. If
    // unset, all samples are kept, but beware that it will be very heavy on the
    // stack unwinder, which might start dropping samples due to overload.
    optional Scope scope = 1;

    // If true, callstacks will include the kernel-space frames. Such frames can
    // be identified by a magical "kernel" string as their mapping name.
    // Requires traced_perf to be running as root, or kptr_restrict to have been
    // manually unrestricted. On Android, the platform should do the right thing
    // on debug builds.
    // This does *not* disclose KASLR, as only the function names are emitted.
    optional bool kernel_frames = 2;

    // Whether to record and unwind userspace callstacks. If unset, defaults to
    // including userspace (UNWIND_DWARF) both for backwards compatibility and
    // as the most common default (this defaulting is only applicable if the
    // outer CallstackSampling message is explicitly set).
    optional UnwindMode user_frames = 3;
  }

  message Scope {
    // Process ID (TGID) allowlist. If this list is not empty, only matching
    // samples will be retained. If multiple allow/deny-lists are
    // specified by the config, then all of them are evaluated for each sampled
    // process.
    repeated int32 target_pid = 1;

    // Command line allowlist, matched against the /proc/<pid>/cmdline (not the
    // comm string). The semantics of this field were changed since its original
    // introduction.
    //
    // On Android T+ (13+), this field can specify a single wildcard (*), and
    // the profiler will attempt to match it in two possible ways:
    // * if the pattern starts with a '/', then it is matched against the first
    //   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
    //   "/bin/echo".
    // * otherwise the pattern is matched against the part of argv0
    //   corresponding to the binary name (this is unrelated to /proc/pid/exe).
    //   For example "echo" would match "/bin/echo".
    //
    // On Android S (12) and below, both this pattern and /proc/pid/cmdline get
    // normalized prior to an exact string comparison. Normalization is as
    // follows: (1) trim everything beyond the first null or "@" byte; (2) if
    // the string contains forward slashes, trim everything up to and including
    // the last one.
    //
    // Implementation note: in either case, at most 511 characters of cmdline
    // are considered.
    repeated string target_cmdline = 2;

    // List of excluded pids.
    repeated int32 exclude_pid = 3;

    // List of excluded cmdlines. See description of |target_cmdline| for how
    // this is handled.
    repeated string exclude_cmdline = 4;

    // Niche features for systemwide callstacks:

    // Number of additional command lines to sample. Only those which are
    // neither explicitly included nor excluded will be considered. Processes
    // are accepted on a first come, first served basis.
    optional uint32 additional_cmdline_count = 5;

    // If set to N, all encountered processes will be put into one of the N
    // possible bins, and only one randomly-chosen bin will be selected for
    // unwinding. The binning is simply "pid % N", under the assumption that
    // low-order bits of pids are roughly uniformly distributed. Other explicit
    // inclusions/exclusions in this |Scope| message are still respected.
    //
    // The profiler will report the chosen shard in PerfSampleDefaults, and the
    // values will be queryable in trace processor under the "stats" table as
    // "perf_process_shard_count" and "perf_chosen_process_shard".
    //
    // NB: all data sources in a config that set |process_shard_count| must set
    // it to the same value. The profiler will choose one bin for all those data
    // sources.
    optional uint32 process_shard_count = 6;
  }

  // Userspace unwinding mode. A possible future addition is kernel-unwound
  // callchains for frame pointer based systems.
  enum UnwindMode {
    UNWIND_UNKNOWN = 0;
    // Do not unwind userspace:
    UNWIND_SKIP = 1;
    // Use libunwindstack (default):
    UNWIND_DWARF = 2;
    // Use userspace frame pointer unwinder:
    UNWIND_FRAME_POINTER = 3;
  }
}

// End of protos/perfetto/config/profiling/perf_event_config.proto

// Begin of protos/perfetto/config/statsd/atom_ids.proto

// This enum is obtained by post-processing
// AOSP/frameworks/proto_logging/stats/atoms.proto through
// AOSP/external/perfetto/tools/update-statsd-descriptor, which extracts one
// enum value for each proto field defined in the upstream atoms.proto.
enum AtomId {
  ATOM_UNSPECIFIED = 0;
  ATOM_BLE_SCAN_STATE_CHANGED = 2;
  ATOM_PROCESS_STATE_CHANGED = 3;
  ATOM_BLE_SCAN_RESULT_RECEIVED = 4;
  ATOM_SENSOR_STATE_CHANGED = 5;
  ATOM_GPS_SCAN_STATE_CHANGED = 6;
  ATOM_SYNC_STATE_CHANGED = 7;
  ATOM_SCHEDULED_JOB_STATE_CHANGED = 8;
  ATOM_SCREEN_BRIGHTNESS_CHANGED = 9;
  ATOM_WAKELOCK_STATE_CHANGED = 10;
  ATOM_LONG_PARTIAL_WAKELOCK_STATE_CHANGED = 11;
  ATOM_MOBILE_RADIO_POWER_STATE_CHANGED = 12;
  ATOM_WIFI_RADIO_POWER_STATE_CHANGED = 13;
  ATOM_ACTIVITY_MANAGER_SLEEP_STATE_CHANGED = 14;
  ATOM_MEMORY_FACTOR_STATE_CHANGED = 15;
  ATOM_EXCESSIVE_CPU_USAGE_REPORTED = 16;
  ATOM_CACHED_KILL_REPORTED = 17;
  ATOM_PROCESS_MEMORY_STAT_REPORTED = 18;
  ATOM_LAUNCHER_EVENT = 19;
  ATOM_BATTERY_SAVER_MODE_STATE_CHANGED = 20;
  ATOM_DEVICE_IDLE_MODE_STATE_CHANGED = 21;
  ATOM_DEVICE_IDLING_MODE_STATE_CHANGED = 22;
  ATOM_AUDIO_STATE_CHANGED = 23;
  ATOM_MEDIA_CODEC_STATE_CHANGED = 24;
  ATOM_CAMERA_STATE_CHANGED = 25;
  ATOM_FLASHLIGHT_STATE_CHANGED = 26;
  ATOM_UID_PROCESS_STATE_CHANGED = 27;
  ATOM_PROCESS_LIFE_CYCLE_STATE_CHANGED = 28;
  ATOM_SCREEN_STATE_CHANGED = 29;
  ATOM_BATTERY_LEVEL_CHANGED = 30;
  ATOM_CHARGING_STATE_CHANGED = 31;
  ATOM_PLUGGED_STATE_CHANGED = 32;
  ATOM_INTERACTIVE_STATE_CHANGED = 33;
  ATOM_TOUCH_EVENT_REPORTED = 34;
  ATOM_WAKEUP_ALARM_OCCURRED = 35;
  ATOM_KERNEL_WAKEUP_REPORTED = 36;
  ATOM_WIFI_LOCK_STATE_CHANGED = 37;
  ATOM_WIFI_SIGNAL_STRENGTH_CHANGED = 38;
  ATOM_WIFI_SCAN_STATE_CHANGED = 39;
  ATOM_PHONE_SIGNAL_STRENGTH_CHANGED = 40;
  ATOM_SETTING_CHANGED = 41;
  ATOM_ACTIVITY_FOREGROUND_STATE_CHANGED = 42;
  ATOM_ISOLATED_UID_CHANGED = 43;
  ATOM_PACKET_WAKEUP_OCCURRED = 44;
  ATOM_WALL_CLOCK_TIME_SHIFTED = 45;
  ATOM_ANOMALY_DETECTED = 46;
  ATOM_APP_BREADCRUMB_REPORTED = 47;
  ATOM_APP_START_OCCURRED = 48;
  ATOM_APP_START_CANCELED = 49;
  ATOM_APP_START_FULLY_DRAWN = 50;
  ATOM_LMK_KILL_OCCURRED = 51;
  ATOM_PICTURE_IN_PICTURE_STATE_CHANGED = 52;
  ATOM_WIFI_MULTICAST_LOCK_STATE_CHANGED = 53;
  ATOM_APP_START_MEMORY_STATE_CAPTURED = 55;
  ATOM_SHUTDOWN_SEQUENCE_REPORTED = 56;
  ATOM_BOOT_SEQUENCE_REPORTED = 57;
  ATOM_OVERLAY_STATE_CHANGED = 59;
  ATOM_FOREGROUND_SERVICE_STATE_CHANGED = 60;
  ATOM_CALL_STATE_CHANGED = 61;
  ATOM_KEYGUARD_STATE_CHANGED = 62;
  ATOM_KEYGUARD_BOUNCER_STATE_CHANGED = 63;
  ATOM_KEYGUARD_BOUNCER_PASSWORD_ENTERED = 64;
  ATOM_APP_DIED = 65;
  ATOM_RESOURCE_CONFIGURATION_CHANGED = 66;
  ATOM_BLUETOOTH_ENABLED_STATE_CHANGED = 67;
  ATOM_BLUETOOTH_CONNECTION_STATE_CHANGED = 68;
  ATOM_GPS_SIGNAL_QUALITY_CHANGED = 69;
  ATOM_USB_CONNECTOR_STATE_CHANGED = 70;
  ATOM_SPEAKER_IMPEDANCE_REPORTED = 71;
  ATOM_HARDWARE_FAILED = 72;
  ATOM_PHYSICAL_DROP_DETECTED = 73;
  ATOM_CHARGE_CYCLES_REPORTED = 74;
  ATOM_MOBILE_CONNECTION_STATE_CHANGED = 75;
  ATOM_MOBILE_RADIO_TECHNOLOGY_CHANGED = 76;
  ATOM_USB_DEVICE_ATTACHED = 77;
  ATOM_APP_CRASH_OCCURRED = 78;
  ATOM_ANR_OCCURRED = 79;
  ATOM_WTF_OCCURRED = 80;
  ATOM_LOW_MEM_REPORTED = 81;
  ATOM_GENERIC_ATOM = 82;
  ATOM_VIBRATOR_STATE_CHANGED = 84;
  ATOM_DEFERRED_JOB_STATS_REPORTED = 85;
  ATOM_THERMAL_THROTTLING = 86;
  ATOM_BIOMETRIC_ACQUIRED = 87;
  ATOM_BIOMETRIC_AUTHENTICATED = 88;
  ATOM_BIOMETRIC_ERROR_OCCURRED = 89;
  ATOM_UI_EVENT_REPORTED = 90;
  ATOM_BATTERY_HEALTH_SNAPSHOT = 91;
  ATOM_SLOW_IO = 92;
  ATOM_BATTERY_CAUSED_SHUTDOWN = 93;
  ATOM_PHONE_SERVICE_STATE_CHANGED = 94;
  ATOM_PHONE_STATE_CHANGED = 95;
  ATOM_USER_RESTRICTION_CHANGED = 96;
  ATOM_SETTINGS_UI_CHANGED = 97;
  ATOM_CONNECTIVITY_STATE_CHANGED = 98;
  ATOM_SERVICE_STATE_CHANGED = 99;
  ATOM_SERVICE_LAUNCH_REPORTED = 100;
  ATOM_FLAG_FLIP_UPDATE_OCCURRED = 101;
  ATOM_BINARY_PUSH_STATE_CHANGED = 102;
  ATOM_DEVICE_POLICY_EVENT = 103;
  ATOM_DOCS_UI_FILE_OP_CANCELED = 104;
  ATOM_DOCS_UI_FILE_OP_COPY_MOVE_MODE_REPORTED = 105;
  ATOM_DOCS_UI_FILE_OP_FAILURE = 106;
  ATOM_DOCS_UI_PROVIDER_FILE_OP = 107;
  ATOM_DOCS_UI_INVALID_SCOPED_ACCESS_REQUEST = 108;
  ATOM_DOCS_UI_LAUNCH_REPORTED = 109;
  ATOM_DOCS_UI_ROOT_VISITED = 110;
  ATOM_DOCS_UI_STARTUP_MS = 111;
  ATOM_DOCS_UI_USER_ACTION_REPORTED = 112;
  ATOM_WIFI_ENABLED_STATE_CHANGED = 113;
  ATOM_WIFI_RUNNING_STATE_CHANGED = 114;
  ATOM_APP_COMPACTED = 115;
  ATOM_NETWORK_DNS_EVENT_REPORTED = 116;
  ATOM_DOCS_UI_PICKER_LAUNCHED_FROM_REPORTED = 117;
  ATOM_DOCS_UI_PICK_RESULT_REPORTED = 118;
  ATOM_DOCS_UI_SEARCH_MODE_REPORTED = 119;
  ATOM_DOCS_UI_SEARCH_TYPE_REPORTED = 120;
  ATOM_DATA_STALL_EVENT = 121;
  ATOM_RESCUE_PARTY_RESET_REPORTED = 122;
  ATOM_SIGNED_CONFIG_REPORTED = 123;
  ATOM_GNSS_NI_EVENT_REPORTED = 124;
  ATOM_BLUETOOTH_LINK_LAYER_CONNECTION_EVENT = 125;
  ATOM_BLUETOOTH_ACL_CONNECTION_STATE_CHANGED = 126;
  ATOM_BLUETOOTH_SCO_CONNECTION_STATE_CHANGED = 127;
  ATOM_APP_DOWNGRADED = 128;
  ATOM_APP_OPTIMIZED_AFTER_DOWNGRADED = 129;
  ATOM_LOW_STORAGE_STATE_CHANGED = 130;
  ATOM_GNSS_NFW_NOTIFICATION_REPORTED = 131;
  ATOM_GNSS_CONFIGURATION_REPORTED = 132;
  ATOM_USB_PORT_OVERHEAT_EVENT_REPORTED = 133;
  ATOM_NFC_ERROR_OCCURRED = 134;
  ATOM_NFC_STATE_CHANGED = 135;
  ATOM_NFC_BEAM_OCCURRED = 136;
  ATOM_NFC_CARDEMULATION_OCCURRED = 137;
  ATOM_NFC_TAG_OCCURRED = 138;
  ATOM_NFC_HCE_TRANSACTION_OCCURRED = 139;
  ATOM_SE_STATE_CHANGED = 140;
  ATOM_SE_OMAPI_REPORTED = 141;
  ATOM_BROADCAST_DISPATCH_LATENCY_REPORTED = 142;
  ATOM_ATTENTION_MANAGER_SERVICE_RESULT_REPORTED = 143;
  ATOM_ADB_CONNECTION_CHANGED = 144;
  ATOM_SPEECH_DSP_STAT_REPORTED = 145;
  ATOM_USB_CONTAMINANT_REPORTED = 146;
  ATOM_WATCHDOG_ROLLBACK_OCCURRED = 147;
  ATOM_BIOMETRIC_SYSTEM_HEALTH_ISSUE_DETECTED = 148;
  ATOM_BUBBLE_UI_CHANGED = 149;
  ATOM_SCHEDULED_JOB_CONSTRAINT_CHANGED = 150;
  ATOM_BLUETOOTH_ACTIVE_DEVICE_CHANGED = 151;
  ATOM_BLUETOOTH_A2DP_PLAYBACK_STATE_CHANGED = 152;
  ATOM_BLUETOOTH_A2DP_CODEC_CONFIG_CHANGED = 153;
  ATOM_BLUETOOTH_A2DP_CODEC_CAPABILITY_CHANGED = 154;
  ATOM_BLUETOOTH_A2DP_AUDIO_UNDERRUN_REPORTED = 155;
  ATOM_BLUETOOTH_A2DP_AUDIO_OVERRUN_REPORTED = 156;
  ATOM_BLUETOOTH_DEVICE_RSSI_REPORTED = 157;
  ATOM_BLUETOOTH_DEVICE_FAILED_CONTACT_COUNTER_REPORTED = 158;
  ATOM_BLUETOOTH_DEVICE_TX_POWER_LEVEL_REPORTED = 159;
  ATOM_BLUETOOTH_HCI_TIMEOUT_REPORTED = 160;
  ATOM_BLUETOOTH_QUALITY_REPORT_REPORTED = 161;
  ATOM_BLUETOOTH_DEVICE_INFO_REPORTED = 162;
  ATOM_BLUETOOTH_REMOTE_VERSION_INFO_REPORTED = 163;
  ATOM_BLUETOOTH_SDP_ATTRIBUTE_REPORTED = 164;
  ATOM_BLUETOOTH_BOND_STATE_CHANGED = 165;
  ATOM_BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED = 166;
  ATOM_BLUETOOTH_SMP_PAIRING_EVENT_REPORTED = 167;
  ATOM_SCREEN_TIMEOUT_EXTENSION_REPORTED = 168;
  ATOM_PROCESS_START_TIME = 169;
  ATOM_PERMISSION_GRANT_REQUEST_RESULT_REPORTED = 170;
  ATOM_BLUETOOTH_SOCKET_CONNECTION_STATE_CHANGED = 171;
  ATOM_DEVICE_IDENTIFIER_ACCESS_DENIED = 172;
  ATOM_BUBBLE_DEVELOPER_ERROR_REPORTED = 173;
  ATOM_ASSIST_GESTURE_STAGE_REPORTED = 174;
  ATOM_ASSIST_GESTURE_FEEDBACK_REPORTED = 175;
  ATOM_ASSIST_GESTURE_PROGRESS_REPORTED = 176;
  ATOM_TOUCH_GESTURE_CLASSIFIED = 177;
  ATOM_HIDDEN_API_USED = 178;
  ATOM_STYLE_UI_CHANGED = 179;
  ATOM_PRIVACY_INDICATORS_INTERACTED = 180;
  ATOM_APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED = 181;
  ATOM_NETWORK_STACK_REPORTED = 182;
  ATOM_APP_MOVED_STORAGE_REPORTED = 183;
  ATOM_BIOMETRIC_ENROLLED = 184;
  ATOM_SYSTEM_SERVER_WATCHDOG_OCCURRED = 185;
  ATOM_TOMB_STONE_OCCURRED = 186;
  ATOM_BLUETOOTH_CLASS_OF_DEVICE_REPORTED = 187;
  ATOM_INTELLIGENCE_EVENT_REPORTED = 188;
  ATOM_THERMAL_THROTTLING_SEVERITY_STATE_CHANGED = 189;
  ATOM_ROLE_REQUEST_RESULT_REPORTED = 190;
  ATOM_MEDIAMETRICS_AUDIOPOLICY_REPORTED = 191;
  ATOM_MEDIAMETRICS_AUDIORECORD_REPORTED = 192;
  ATOM_MEDIAMETRICS_AUDIOTHREAD_REPORTED = 193;
  ATOM_MEDIAMETRICS_AUDIOTRACK_REPORTED = 194;
  ATOM_MEDIAMETRICS_CODEC_REPORTED = 195;
  ATOM_MEDIAMETRICS_DRM_WIDEVINE_REPORTED = 196;
  ATOM_MEDIAMETRICS_EXTRACTOR_REPORTED = 197;
  ATOM_MEDIAMETRICS_MEDIADRM_REPORTED = 198;
  ATOM_MEDIAMETRICS_NUPLAYER_REPORTED = 199;
  ATOM_MEDIAMETRICS_RECORDER_REPORTED = 200;
  ATOM_MEDIAMETRICS_DRMMANAGER_REPORTED = 201;
  ATOM_CAR_POWER_STATE_CHANGED = 203;
  ATOM_GARAGE_MODE_INFO = 204;
  ATOM_TEST_ATOM_REPORTED = 205;
  ATOM_CONTENT_CAPTURE_CALLER_MISMATCH_REPORTED = 206;
  ATOM_CONTENT_CAPTURE_SERVICE_EVENTS = 207;
  ATOM_CONTENT_CAPTURE_SESSION_EVENTS = 208;
  ATOM_CONTENT_CAPTURE_FLUSHED = 209;
  ATOM_LOCATION_MANAGER_API_USAGE_REPORTED = 210;
  ATOM_REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED = 211;
  ATOM_RUNTIME_PERMISSIONS_UPGRADE_RESULT = 212;
  ATOM_GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS = 213;
  ATOM_LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION = 214;
  ATOM_APP_PERMISSION_FRAGMENT_ACTION_REPORTED = 215;
  ATOM_APP_PERMISSION_FRAGMENT_VIEWED = 216;
  ATOM_APP_PERMISSIONS_FRAGMENT_VIEWED = 217;
  ATOM_PERMISSION_APPS_FRAGMENT_VIEWED = 218;
  ATOM_TEXT_SELECTION_EVENT = 219;
  ATOM_TEXT_LINKIFY_EVENT = 220;
  ATOM_CONVERSATION_ACTIONS_EVENT = 221;
  ATOM_LANGUAGE_DETECTION_EVENT = 222;
  ATOM_EXCLUSION_RECT_STATE_CHANGED = 223;
  ATOM_BACK_GESTURE_REPORTED_REPORTED = 224;
  ATOM_UPDATE_ENGINE_UPDATE_ATTEMPT_REPORTED = 225;
  ATOM_UPDATE_ENGINE_SUCCESSFUL_UPDATE_REPORTED = 226;
  ATOM_CAMERA_ACTION_EVENT = 227;
  ATOM_APP_COMPATIBILITY_CHANGE_REPORTED = 228;
  ATOM_PERFETTO_UPLOADED = 229;
  ATOM_VMS_CLIENT_CONNECTION_STATE_CHANGED = 230;
  ATOM_MEDIA_PROVIDER_SCAN_OCCURRED = 233;
  ATOM_MEDIA_CONTENT_DELETED = 234;
  ATOM_MEDIA_PROVIDER_PERMISSION_REQUESTED = 235;
  ATOM_MEDIA_PROVIDER_SCHEMA_CHANGED = 236;
  ATOM_MEDIA_PROVIDER_IDLE_MAINTENANCE_FINISHED = 237;
  ATOM_REBOOT_ESCROW_RECOVERY_REPORTED = 238;
  ATOM_BOOT_TIME_EVENT_DURATION_REPORTED = 239;
  ATOM_BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED = 240;
  ATOM_BOOT_TIME_EVENT_UTC_TIME_REPORTED = 241;
  ATOM_BOOT_TIME_EVENT_ERROR_CODE_REPORTED = 242;
  ATOM_USERSPACE_REBOOT_REPORTED = 243;
  ATOM_NOTIFICATION_REPORTED = 244;
  ATOM_NOTIFICATION_PANEL_REPORTED = 245;
  ATOM_NOTIFICATION_CHANNEL_MODIFIED = 246;
  ATOM_INTEGRITY_CHECK_RESULT_REPORTED = 247;
  ATOM_INTEGRITY_RULES_PUSHED = 248;
  ATOM_CB_MESSAGE_REPORTED = 249;
  ATOM_CB_MESSAGE_ERROR = 250;
  ATOM_WIFI_HEALTH_STAT_REPORTED = 251;
  ATOM_WIFI_FAILURE_STAT_REPORTED = 252;
  ATOM_WIFI_CONNECTION_RESULT_REPORTED = 253;
  ATOM_APP_FREEZE_CHANGED = 254;
  ATOM_SNAPSHOT_MERGE_REPORTED = 255;
  ATOM_FOREGROUND_SERVICE_APP_OP_SESSION_ENDED = 256;
  ATOM_DISPLAY_JANK_REPORTED = 257;
  ATOM_APP_STANDBY_BUCKET_CHANGED = 258;
  ATOM_SHARESHEET_STARTED = 259;
  ATOM_RANKING_SELECTED = 260;
  ATOM_TVSETTINGS_UI_INTERACTED = 261;
  ATOM_LAUNCHER_SNAPSHOT = 262;
  ATOM_PACKAGE_INSTALLER_V2_REPORTED = 263;
  ATOM_USER_LIFECYCLE_JOURNEY_REPORTED = 264;
  ATOM_USER_LIFECYCLE_EVENT_OCCURRED = 265;
  ATOM_ACCESSIBILITY_SHORTCUT_REPORTED = 266;
  ATOM_ACCESSIBILITY_SERVICE_REPORTED = 267;
  ATOM_DOCS_UI_DRAG_AND_DROP_REPORTED = 268;
  ATOM_APP_USAGE_EVENT_OCCURRED = 269;
  ATOM_AUTO_REVOKE_NOTIFICATION_CLICKED = 270;
  ATOM_AUTO_REVOKE_FRAGMENT_APP_VIEWED = 271;
  ATOM_AUTO_REVOKED_APP_INTERACTION = 272;
  ATOM_APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION = 273;
  ATOM_EVS_USAGE_STATS_REPORTED = 274;
  ATOM_AUDIO_POWER_USAGE_DATA_REPORTED = 275;
  ATOM_TV_TUNER_STATE_CHANGED = 276;
  ATOM_MEDIAOUTPUT_OP_SWITCH_REPORTED = 277;
  ATOM_CB_MESSAGE_FILTERED = 278;
  ATOM_TV_TUNER_DVR_STATUS = 279;
  ATOM_TV_CAS_SESSION_OPEN_STATUS = 280;
  ATOM_ASSISTANT_INVOCATION_REPORTED = 281;
  ATOM_DISPLAY_WAKE_REPORTED = 282;
  ATOM_CAR_USER_HAL_MODIFY_USER_REQUEST_REPORTED = 283;
  ATOM_CAR_USER_HAL_MODIFY_USER_RESPONSE_REPORTED = 284;
  ATOM_CAR_USER_HAL_POST_SWITCH_RESPONSE_REPORTED = 285;
  ATOM_CAR_USER_HAL_INITIAL_USER_INFO_REQUEST_REPORTED = 286;
  ATOM_CAR_USER_HAL_INITIAL_USER_INFO_RESPONSE_REPORTED = 287;
  ATOM_CAR_USER_HAL_USER_ASSOCIATION_REQUEST_REPORTED = 288;
  ATOM_CAR_USER_HAL_SET_USER_ASSOCIATION_RESPONSE_REPORTED = 289;
  ATOM_NETWORK_IP_PROVISIONING_REPORTED = 290;
  ATOM_NETWORK_DHCP_RENEW_REPORTED = 291;
  ATOM_NETWORK_VALIDATION_REPORTED = 292;
  ATOM_NETWORK_STACK_QUIRK_REPORTED = 293;
  ATOM_MEDIAMETRICS_AUDIORECORDDEVICEUSAGE_REPORTED = 294;
  ATOM_MEDIAMETRICS_AUDIOTHREADDEVICEUSAGE_REPORTED = 295;
  ATOM_MEDIAMETRICS_AUDIOTRACKDEVICEUSAGE_REPORTED = 296;
  ATOM_MEDIAMETRICS_AUDIODEVICECONNECTION_REPORTED = 297;
  ATOM_BLOB_COMMITTED = 298;
  ATOM_BLOB_LEASED = 299;
  ATOM_BLOB_OPENED = 300;
  ATOM_CONTACTS_PROVIDER_STATUS_REPORTED = 301;
  ATOM_KEYSTORE_KEY_EVENT_REPORTED = 302;
  ATOM_NETWORK_TETHERING_REPORTED = 303;
  ATOM_IME_TOUCH_REPORTED = 304;
  ATOM_UI_INTERACTION_FRAME_INFO_REPORTED = 305;
  ATOM_UI_ACTION_LATENCY_REPORTED = 306;
  ATOM_WIFI_DISCONNECT_REPORTED = 307;
  ATOM_WIFI_CONNECTION_STATE_CHANGED = 308;
  ATOM_HDMI_CEC_ACTIVE_SOURCE_CHANGED = 309;
  ATOM_HDMI_CEC_MESSAGE_REPORTED = 310;
  ATOM_AIRPLANE_MODE = 311;
  ATOM_MODEM_RESTART = 312;
  ATOM_CARRIER_ID_MISMATCH_REPORTED = 313;
  ATOM_CARRIER_ID_TABLE_UPDATED = 314;
  ATOM_DATA_STALL_RECOVERY_REPORTED = 315;
  ATOM_MEDIAMETRICS_MEDIAPARSER_REPORTED = 316;
  ATOM_TLS_HANDSHAKE_REPORTED = 317;
  ATOM_TEXT_CLASSIFIER_API_USAGE_REPORTED = 318;
  ATOM_CAR_WATCHDOG_KILL_STATS_REPORTED = 319;
  ATOM_MEDIAMETRICS_PLAYBACK_REPORTED = 320;
  ATOM_MEDIA_NETWORK_INFO_CHANGED = 321;
  ATOM_MEDIA_PLAYBACK_STATE_CHANGED = 322;
  ATOM_MEDIA_PLAYBACK_ERROR_REPORTED = 323;
  ATOM_MEDIA_PLAYBACK_TRACK_CHANGED = 324;
  ATOM_WIFI_SCAN_REPORTED = 325;
  ATOM_WIFI_PNO_SCAN_REPORTED = 326;
  ATOM_TIF_TUNE_CHANGED = 327;
  ATOM_AUTO_ROTATE_REPORTED = 328;
  ATOM_PERFETTO_TRIGGER = 329;
  ATOM_TRANSCODING_DATA = 330;
  ATOM_IMS_SERVICE_ENTITLEMENT_UPDATED = 331;
  ATOM_DEVICE_ROTATED = 333;
  ATOM_SIM_SPECIFIC_SETTINGS_RESTORED = 334;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_REPORTED = 335;
  ATOM_PIN_STORAGE_EVENT = 336;
  ATOM_FACE_DOWN_REPORTED = 337;
  ATOM_BLUETOOTH_HAL_CRASH_REASON_REPORTED = 338;
  ATOM_REBOOT_ESCROW_PREPARATION_REPORTED = 339;
  ATOM_REBOOT_ESCROW_LSKF_CAPTURE_REPORTED = 340;
  ATOM_REBOOT_ESCROW_REBOOT_REPORTED = 341;
  ATOM_BINDER_LATENCY_REPORTED = 342;
  ATOM_MEDIAMETRICS_AAUDIOSTREAM_REPORTED = 343;
  ATOM_MEDIA_TRANSCODING_SESSION_ENDED = 344;
  ATOM_MAGNIFICATION_USAGE_REPORTED = 345;
  ATOM_MAGNIFICATION_MODE_WITH_IME_ON_REPORTED = 346;
  ATOM_APP_SEARCH_CALL_STATS_REPORTED = 347;
  ATOM_APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED = 348;
  ATOM_DEVICE_CONTROL_CHANGED = 349;
  ATOM_DEVICE_STATE_CHANGED = 350;
  ATOM_INPUTDEVICE_REGISTERED = 351;
  ATOM_SMARTSPACE_CARD_REPORTED = 352;
  ATOM_AUTH_PROMPT_AUTHENTICATE_INVOKED = 353;
  ATOM_AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED = 354;
  ATOM_AUTH_ENROLL_ACTION_INVOKED = 355;
  ATOM_AUTH_DEPRECATED_API_USED = 356;
  ATOM_UNATTENDED_REBOOT_OCCURRED = 357;
  ATOM_LONG_REBOOT_BLOCKING_REPORTED = 358;
  ATOM_LOCATION_TIME_ZONE_PROVIDER_STATE_CHANGED = 359;
  ATOM_FDTRACK_EVENT_OCCURRED = 364;
  ATOM_TIMEOUT_AUTO_EXTENDED_REPORTED = 365;
  ATOM_ALARM_BATCH_DELIVERED = 367;
  ATOM_ALARM_SCHEDULED = 368;
  ATOM_CAR_WATCHDOG_IO_OVERUSE_STATS_REPORTED = 369;
  ATOM_USER_LEVEL_HIBERNATION_STATE_CHANGED = 370;
  ATOM_APP_SEARCH_INITIALIZE_STATS_REPORTED = 371;
  ATOM_APP_SEARCH_QUERY_STATS_REPORTED = 372;
  ATOM_APP_PROCESS_DIED = 373;
  ATOM_NETWORK_IP_REACHABILITY_MONITOR_REPORTED = 374;
  ATOM_SLOW_INPUT_EVENT_REPORTED = 375;
  ATOM_ANR_OCCURRED_PROCESSING_STARTED = 376;
  ATOM_APP_SEARCH_REMOVE_STATS_REPORTED = 377;
  ATOM_MEDIA_CODEC_REPORTED = 378;
  ATOM_PERMISSION_USAGE_FRAGMENT_INTERACTION = 379;
  ATOM_PERMISSION_DETAILS_INTERACTION = 380;
  ATOM_PRIVACY_SENSOR_TOGGLE_INTERACTION = 381;
  ATOM_PRIVACY_TOGGLE_DIALOG_INTERACTION = 382;
  ATOM_APP_SEARCH_OPTIMIZE_STATS_REPORTED = 383;
  ATOM_NON_A11Y_TOOL_SERVICE_WARNING_REPORT = 384;
  ATOM_APP_COMPAT_STATE_CHANGED = 386;
  ATOM_SIZE_COMPAT_RESTART_BUTTON_EVENT_REPORTED = 387;
  ATOM_SPLITSCREEN_UI_CHANGED = 388;
  ATOM_NETWORK_DNS_HANDSHAKE_REPORTED = 389;
  ATOM_BLUETOOTH_CODE_PATH_COUNTER = 390;
  ATOM_BLUETOOTH_LE_BATCH_SCAN_REPORT_DELAY = 392;
  ATOM_ACCESSIBILITY_FLOATING_MENU_UI_CHANGED = 393;
  ATOM_NEURALNETWORKS_COMPILATION_COMPLETED = 394;
  ATOM_NEURALNETWORKS_EXECUTION_COMPLETED = 395;
  ATOM_NEURALNETWORKS_COMPILATION_FAILED = 396;
  ATOM_NEURALNETWORKS_EXECUTION_FAILED = 397;
  ATOM_CONTEXT_HUB_BOOTED = 398;
  ATOM_CONTEXT_HUB_RESTARTED = 399;
  ATOM_CONTEXT_HUB_LOADED_NANOAPP_SNAPSHOT_REPORTED = 400;
  ATOM_CHRE_CODE_DOWNLOAD_TRANSACTED = 401;
  ATOM_UWB_SESSION_INITED = 402;
  ATOM_UWB_SESSION_CLOSED = 403;
  ATOM_UWB_FIRST_RANGING_RECEIVED = 404;
  ATOM_UWB_RANGING_MEASUREMENT_RECEIVED = 405;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_SCHEDULED = 406;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_COMPLETED = 407;
  ATOM_CLIPBOARD_CLEARED = 408;
  ATOM_VM_CREATION_REQUESTED = 409;
  ATOM_NEARBY_DEVICE_SCAN_STATE_CHANGED = 410;
  ATOM_APPLICATION_LOCALES_CHANGED = 412;
  ATOM_MEDIAMETRICS_AUDIOTRACKSTATUS_REPORTED = 413;
  ATOM_FOLD_STATE_DURATION_REPORTED = 414;
  ATOM_LOCATION_TIME_ZONE_PROVIDER_CONTROLLER_STATE_CHANGED = 415;
  ATOM_DISPLAY_HBM_STATE_CHANGED = 416;
  ATOM_DISPLAY_HBM_BRIGHTNESS_CHANGED = 417;
  ATOM_PERSISTENT_URI_PERMISSIONS_FLUSHED = 418;
  ATOM_EARLY_BOOT_COMP_OS_ARTIFACTS_CHECK_REPORTED = 419;
  ATOM_VBMETA_DIGEST_REPORTED = 420;
  ATOM_APEX_INFO_GATHERED = 421;
  ATOM_PVM_INFO_GATHERED = 422;
  ATOM_WEAR_SETTINGS_UI_INTERACTED = 423;
  ATOM_TRACING_SERVICE_REPORT_EVENT = 424;
  ATOM_MEDIAMETRICS_AUDIORECORDSTATUS_REPORTED = 425;
  ATOM_LAUNCHER_LATENCY = 426;
  ATOM_DROPBOX_ENTRY_DROPPED = 427;
  ATOM_WIFI_P2P_CONNECTION_REPORTED = 428;
  ATOM_GAME_STATE_CHANGED = 429;
  ATOM_HOTWORD_DETECTOR_CREATE_REQUESTED = 430;
  ATOM_HOTWORD_DETECTION_SERVICE_INIT_RESULT_REPORTED = 431;
  ATOM_HOTWORD_DETECTION_SERVICE_RESTARTED = 432;
  ATOM_HOTWORD_DETECTOR_KEYPHRASE_TRIGGERED = 433;
  ATOM_HOTWORD_DETECTOR_EVENTS = 434;
  ATOM_BOOT_COMPLETED_BROADCAST_COMPLETION_LATENCY_REPORTED = 437;
  ATOM_CONTACTS_INDEXER_UPDATE_STATS_REPORTED = 440;
  ATOM_APP_BACKGROUND_RESTRICTIONS_INFO = 441;
  ATOM_MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED = 442;
  ATOM_MMS_SMS_DATABASE_HELPER_ON_UPGRADE_FAILED = 443;
  ATOM_PERMISSION_REMINDER_NOTIFICATION_INTERACTED = 444;
  ATOM_RECENT_PERMISSION_DECISIONS_INTERACTED = 445;
  ATOM_GNSS_PSDS_DOWNLOAD_REPORTED = 446;
  ATOM_LE_AUDIO_CONNECTION_SESSION_REPORTED = 447;
  ATOM_LE_AUDIO_BROADCAST_SESSION_REPORTED = 448;
  ATOM_DREAM_UI_EVENT_REPORTED = 449;
  ATOM_TASK_MANAGER_EVENT_REPORTED = 450;
  ATOM_CDM_ASSOCIATION_ACTION = 451;
  ATOM_MAGNIFICATION_TRIPLE_TAP_AND_HOLD_ACTIVATED_SESSION_REPORTED = 452;
  ATOM_MAGNIFICATION_FOLLOW_TYPING_FOCUS_ACTIVATED_SESSION_REPORTED = 453;
  ATOM_ACCESSIBILITY_TEXT_READING_OPTIONS_CHANGED = 454;
  ATOM_WIFI_SETUP_FAILURE_CRASH_REPORTED = 455;
  ATOM_UWB_DEVICE_ERROR_REPORTED = 456;
  ATOM_ISOLATED_COMPILATION_SCHEDULED = 457;
  ATOM_ISOLATED_COMPILATION_ENDED = 458;
  ATOM_ONS_OPPORTUNISTIC_ESIM_PROVISIONING_COMPLETE = 459;
  ATOM_SYSTEM_SERVER_PRE_WATCHDOG_OCCURRED = 460;
  ATOM_TELEPHONY_ANOMALY_DETECTED = 461;
  ATOM_LETTERBOX_POSITION_CHANGED = 462;
  ATOM_REMOTE_KEY_PROVISIONING_ATTEMPT = 463;
  ATOM_REMOTE_KEY_PROVISIONING_NETWORK_INFO = 464;
  ATOM_REMOTE_KEY_PROVISIONING_TIMING = 465;
  ATOM_MEDIAOUTPUT_OP_INTERACTION_REPORT = 466;
  ATOM_SYNC_EXEMPTION_OCCURRED = 468;
  ATOM_AUTOFILL_PRESENTATION_EVENT_REPORTED = 469;
  ATOM_DOCK_STATE_CHANGED = 470;
  ATOM_SAFETY_SOURCE_STATE_COLLECTED = 471;
  ATOM_SAFETY_CENTER_SYSTEM_EVENT_REPORTED = 472;
  ATOM_SAFETY_CENTER_INTERACTION_REPORTED = 473;
  ATOM_SETTINGS_PROVIDER_SETTING_CHANGED = 474;
  ATOM_BROADCAST_DELIVERY_EVENT_REPORTED = 475;
  ATOM_SERVICE_REQUEST_EVENT_REPORTED = 476;
  ATOM_PROVIDER_ACQUISITION_EVENT_REPORTED = 477;
  ATOM_BLUETOOTH_DEVICE_NAME_REPORTED = 478;
  ATOM_CB_CONFIG_UPDATED = 479;
  ATOM_CB_MODULE_ERROR_REPORTED = 480;
  ATOM_CB_SERVICE_FEATURE_CHANGED = 481;
  ATOM_CB_RECEIVER_FEATURE_CHANGED = 482;
  ATOM_PRIVACY_SIGNAL_NOTIFICATION_INTERACTION = 484;
  ATOM_PRIVACY_SIGNAL_ISSUE_CARD_INTERACTION = 485;
  ATOM_PRIVACY_SIGNALS_JOB_FAILURE = 486;
  ATOM_VIBRATION_REPORTED = 487;
  ATOM_UWB_RANGING_START = 489;
  ATOM_APP_COMPACTED_V2 = 491;
  ATOM_DISPLAY_BRIGHTNESS_CHANGED = 494;
  ATOM_ACTIVITY_ACTION_BLOCKED = 495;
  ATOM_NETWORK_DNS_SERVER_SUPPORT_REPORTED = 504;
  ATOM_VM_BOOTED = 505;
  ATOM_VM_EXITED = 506;
  ATOM_AMBIENT_BRIGHTNESS_STATS_REPORTED = 507;
  ATOM_MEDIAMETRICS_SPATIALIZERCAPABILITIES_REPORTED = 508;
  ATOM_MEDIAMETRICS_SPATIALIZERDEVICEENABLED_REPORTED = 509;
  ATOM_MEDIAMETRICS_HEADTRACKERDEVICEENABLED_REPORTED = 510;
  ATOM_MEDIAMETRICS_HEADTRACKERDEVICESUPPORTED_REPORTED = 511;
  ATOM_HEARING_AID_INFO_REPORTED = 513;
  ATOM_DEVICE_WIDE_JOB_CONSTRAINT_CHANGED = 514;
  ATOM_AMBIENT_MODE_CHANGED = 515;
  ATOM_ANR_LATENCY_REPORTED = 516;
  ATOM_RESOURCE_API_INFO = 517;
  ATOM_SYSTEM_DEFAULT_NETWORK_CHANGED = 518;
  ATOM_IWLAN_SETUP_DATA_CALL_RESULT_REPORTED = 519;
  ATOM_IWLAN_PDN_DISCONNECTED_REASON_REPORTED = 520;
  ATOM_AIRPLANE_MODE_SESSION_REPORTED = 521;
  ATOM_VM_CPU_STATUS_REPORTED = 522;
  ATOM_VM_MEM_STATUS_REPORTED = 523;
  ATOM_PACKAGE_INSTALLATION_SESSION_REPORTED = 524;
  ATOM_DEFAULT_NETWORK_REMATCH_INFO = 525;
  ATOM_NETWORK_SELECTION_PERFORMANCE = 526;
  ATOM_NETWORK_NSD_REPORTED = 527;
  ATOM_BLUETOOTH_DISCONNECTION_REASON_REPORTED = 529;
  ATOM_BLUETOOTH_LOCAL_VERSIONS_REPORTED = 530;
  ATOM_BLUETOOTH_REMOTE_SUPPORTED_FEATURES_REPORTED = 531;
  ATOM_BLUETOOTH_LOCAL_SUPPORTED_FEATURES_REPORTED = 532;
  ATOM_BLUETOOTH_GATT_APP_INFO = 533;
  ATOM_BRIGHTNESS_CONFIGURATION_UPDATED = 534;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_LAUNCHED = 538;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FINISHED = 539;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECTION_REPORTED = 540;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_TRIGGERED = 541;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FIRST_DEVICE_SCAN_LATENCY = 542;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECT_DEVICE_LATENCY = 543;
  ATOM_PACKAGE_MANAGER_SNAPSHOT_REPORTED = 544;
  ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_BUILD_REPORTED = 545;
  ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_UPDATE_REPORTED = 546;
  ATOM_LAUNCHER_IMPRESSION_EVENT = 547;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_ALL_DEVICES_SCAN_LATENCY = 549;
  ATOM_WS_WATCH_FACE_EDITED = 551;
  ATOM_WS_WATCH_FACE_FAVORITE_ACTION_REPORTED = 552;
  ATOM_WS_WATCH_FACE_SET_ACTION_REPORTED = 553;
  ATOM_PACKAGE_UNINSTALLATION_REPORTED = 554;
  ATOM_GAME_MODE_CHANGED = 555;
  ATOM_GAME_MODE_CONFIGURATION_CHANGED = 556;
  ATOM_BEDTIME_MODE_STATE_CHANGED = 557;
  ATOM_NETWORK_SLICE_SESSION_ENDED = 558;
  ATOM_NETWORK_SLICE_DAILY_DATA_USAGE_REPORTED = 559;
  ATOM_NFC_TAG_TYPE_OCCURRED = 560;
  ATOM_NFC_AID_CONFLICT_OCCURRED = 561;
  ATOM_NFC_READER_CONFLICT_OCCURRED = 562;
  ATOM_WS_TILE_LIST_CHANGED = 563;
  ATOM_GET_TYPE_ACCESSED_WITHOUT_PERMISSION = 564;
  ATOM_MOBILE_BUNDLED_APP_INFO_GATHERED = 566;
  ATOM_WS_WATCH_FACE_COMPLICATION_SET_CHANGED = 567;
  ATOM_MEDIA_DRM_CREATED = 568;
  ATOM_MEDIA_DRM_ERRORED = 569;
  ATOM_MEDIA_DRM_SESSION_OPENED = 570;
  ATOM_MEDIA_DRM_SESSION_CLOSED = 571;
  ATOM_USER_SELECTED_RESOLUTION = 572;
  ATOM_UNSAFE_INTENT_EVENT_REPORTED = 573;
  ATOM_PERFORMANCE_HINT_SESSION_REPORTED = 574;
  ATOM_MEDIAMETRICS_MIDI_DEVICE_CLOSE_REPORTED = 576;
  ATOM_BIOMETRIC_TOUCH_REPORTED = 577;
  ATOM_HOTWORD_AUDIO_EGRESS_EVENT_REPORTED = 578;
  ATOM_LOCATION_ENABLED_STATE_CHANGED = 580;
  ATOM_IME_REQUEST_FINISHED = 581;
  ATOM_USB_COMPLIANCE_WARNINGS_REPORTED = 582;
  ATOM_APP_SUPPORTED_LOCALES_CHANGED = 583;
  ATOM_MEDIA_PROVIDER_VOLUME_RECOVERY_REPORTED = 586;
  ATOM_BIOMETRIC_PROPERTIES_COLLECTED = 587;
  ATOM_KERNEL_WAKEUP_ATTRIBUTED = 588;
  ATOM_SCREEN_STATE_CHANGED_V2 = 589;
  ATOM_WS_BACKUP_ACTION_REPORTED = 590;
  ATOM_WS_RESTORE_ACTION_REPORTED = 591;
  ATOM_DEVICE_LOG_ACCESS_EVENT_REPORTED = 592;
  ATOM_MEDIA_SESSION_UPDATED = 594;
  ATOM_WEAR_OOBE_STATE_CHANGED = 595;
  ATOM_WS_NOTIFICATION_UPDATED = 596;
  ATOM_NETWORK_VALIDATION_FAILURE_STATS_DAILY_REPORTED = 601;
  ATOM_WS_COMPLICATION_TAPPED = 602;
  ATOM_WS_NOTIFICATION_BLOCKING = 780;
  ATOM_WS_NOTIFICATION_BRIDGEMODE_UPDATED = 822;
  ATOM_WS_NOTIFICATION_DISMISSAL_ACTIONED = 823;
  ATOM_WS_NOTIFICATION_ACTIONED = 824;
  ATOM_WS_NOTIFICATION_LATENCY = 880;
  ATOM_WIFI_BYTES_TRANSFER = 10000;
  ATOM_WIFI_BYTES_TRANSFER_BY_FG_BG = 10001;
  ATOM_MOBILE_BYTES_TRANSFER = 10002;
  ATOM_MOBILE_BYTES_TRANSFER_BY_FG_BG = 10003;
  ATOM_BLUETOOTH_BYTES_TRANSFER = 10006;
  ATOM_KERNEL_WAKELOCK = 10004;
  ATOM_SUBSYSTEM_SLEEP_STATE = 10005;
  ATOM_CPU_TIME_PER_UID = 10009;
  ATOM_CPU_TIME_PER_UID_FREQ = 10010;
  ATOM_WIFI_ACTIVITY_INFO = 10011;
  ATOM_MODEM_ACTIVITY_INFO = 10012;
  ATOM_BLUETOOTH_ACTIVITY_INFO = 10007;
  ATOM_PROCESS_MEMORY_STATE = 10013;
  ATOM_SYSTEM_ELAPSED_REALTIME = 10014;
  ATOM_SYSTEM_UPTIME = 10015;
  ATOM_CPU_ACTIVE_TIME = 10016;
  ATOM_CPU_CLUSTER_TIME = 10017;
  ATOM_DISK_SPACE = 10018;
  ATOM_REMAINING_BATTERY_CAPACITY = 10019;
  ATOM_FULL_BATTERY_CAPACITY = 10020;
  ATOM_TEMPERATURE = 10021;
  ATOM_BINDER_CALLS = 10022;
  ATOM_BINDER_CALLS_EXCEPTIONS = 10023;
  ATOM_LOOPER_STATS = 10024;
  ATOM_DISK_STATS = 10025;
  ATOM_DIRECTORY_USAGE = 10026;
  ATOM_APP_SIZE = 10027;
  ATOM_CATEGORY_SIZE = 10028;
  ATOM_PROC_STATS = 10029;
  ATOM_BATTERY_VOLTAGE = 10030;
  ATOM_NUM_FINGERPRINTS_ENROLLED = 10031;
  ATOM_DISK_IO = 10032;
  ATOM_POWER_PROFILE = 10033;
  ATOM_PROC_STATS_PKG_PROC = 10034;
  ATOM_PROCESS_CPU_TIME = 10035;
  ATOM_CPU_TIME_PER_THREAD_FREQ = 10037;
  ATOM_ON_DEVICE_POWER_MEASUREMENT = 10038;
  ATOM_DEVICE_CALCULATED_POWER_USE = 10039;
  ATOM_PROCESS_MEMORY_HIGH_WATER_MARK = 10042;
  ATOM_BATTERY_LEVEL = 10043;
  ATOM_BUILD_INFORMATION = 10044;
  ATOM_BATTERY_CYCLE_COUNT = 10045;
  ATOM_DEBUG_ELAPSED_CLOCK = 10046;
  ATOM_DEBUG_FAILING_ELAPSED_CLOCK = 10047;
  ATOM_NUM_FACES_ENROLLED = 10048;
  ATOM_ROLE_HOLDER = 10049;
  ATOM_DANGEROUS_PERMISSION_STATE = 10050;
  ATOM_TRAIN_INFO = 10051;
  ATOM_TIME_ZONE_DATA_INFO = 10052;
  ATOM_EXTERNAL_STORAGE_INFO = 10053;
  ATOM_GPU_STATS_GLOBAL_INFO = 10054;
  ATOM_GPU_STATS_APP_INFO = 10055;
  ATOM_SYSTEM_ION_HEAP_SIZE = 10056;
  ATOM_APPS_ON_EXTERNAL_STORAGE_INFO = 10057;
  ATOM_FACE_SETTINGS = 10058;
  ATOM_COOLING_DEVICE = 10059;
  ATOM_APP_OPS = 10060;
  ATOM_PROCESS_SYSTEM_ION_HEAP_SIZE = 10061;
  ATOM_SURFACEFLINGER_STATS_GLOBAL_INFO = 10062;
  ATOM_SURFACEFLINGER_STATS_LAYER_INFO = 10063;
  ATOM_PROCESS_MEMORY_SNAPSHOT = 10064;
  ATOM_VMS_CLIENT_STATS = 10065;
  ATOM_NOTIFICATION_REMOTE_VIEWS = 10066;
  ATOM_DANGEROUS_PERMISSION_STATE_SAMPLED = 10067;
  ATOM_GRAPHICS_STATS = 10068;
  ATOM_RUNTIME_APP_OP_ACCESS = 10069;
  ATOM_ION_HEAP_SIZE = 10070;
  ATOM_PACKAGE_NOTIFICATION_PREFERENCES = 10071;
  ATOM_PACKAGE_NOTIFICATION_CHANNEL_PREFERENCES = 10072;
  ATOM_PACKAGE_NOTIFICATION_CHANNEL_GROUP_PREFERENCES = 10073;
  ATOM_GNSS_STATS = 10074;
  ATOM_ATTRIBUTED_APP_OPS = 10075;
  ATOM_VOICE_CALL_SESSION = 10076;
  ATOM_VOICE_CALL_RAT_USAGE = 10077;
  ATOM_SIM_SLOT_STATE = 10078;
  ATOM_SUPPORTED_RADIO_ACCESS_FAMILY = 10079;
  ATOM_SETTING_SNAPSHOT = 10080;
  ATOM_BLOB_INFO = 10081;
  ATOM_DATA_USAGE_BYTES_TRANSFER = 10082;
  ATOM_BYTES_TRANSFER_BY_TAG_AND_METERED = 10083;
  ATOM_DND_MODE_RULE = 10084;
  ATOM_GENERAL_EXTERNAL_STORAGE_ACCESS_STATS = 10085;
  ATOM_INCOMING_SMS = 10086;
  ATOM_OUTGOING_SMS = 10087;
  ATOM_CARRIER_ID_TABLE_VERSION = 10088;
  ATOM_DATA_CALL_SESSION = 10089;
  ATOM_CELLULAR_SERVICE_STATE = 10090;
  ATOM_CELLULAR_DATA_SERVICE_SWITCH = 10091;
  ATOM_SYSTEM_MEMORY = 10092;
  ATOM_IMS_REGISTRATION_TERMINATION = 10093;
  ATOM_IMS_REGISTRATION_STATS = 10094;
  ATOM_CPU_TIME_PER_CLUSTER_FREQ = 10095;
  ATOM_CPU_CYCLES_PER_UID_CLUSTER = 10096;
  ATOM_DEVICE_ROTATED_DATA = 10097;
  ATOM_CPU_CYCLES_PER_THREAD_GROUP_CLUSTER = 10098;
  ATOM_MEDIA_DRM_ACTIVITY_INFO = 10099;
  ATOM_OEM_MANAGED_BYTES_TRANSFER = 10100;
  ATOM_GNSS_POWER_STATS = 10101;
  ATOM_TIME_ZONE_DETECTOR_STATE = 10102;
  ATOM_KEYSTORE2_STORAGE_STATS = 10103;
  ATOM_RKP_POOL_STATS = 10104;
  ATOM_PROCESS_DMABUF_MEMORY = 10105;
  ATOM_PENDING_ALARM_INFO = 10106;
  ATOM_USER_LEVEL_HIBERNATED_APPS = 10107;
  ATOM_LAUNCHER_LAYOUT_SNAPSHOT = 10108;
  ATOM_GLOBAL_HIBERNATED_APPS = 10109;
  ATOM_INPUT_EVENT_LATENCY_SKETCH = 10110;
  ATOM_BATTERY_USAGE_STATS_BEFORE_RESET = 10111;
  ATOM_BATTERY_USAGE_STATS_SINCE_RESET = 10112;
  ATOM_BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL = 10113;
  ATOM_INSTALLED_INCREMENTAL_PACKAGE = 10114;
  ATOM_TELEPHONY_NETWORK_REQUESTS = 10115;
  ATOM_APP_SEARCH_STORAGE_INFO = 10116;
  ATOM_VMSTAT = 10117;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_GENERAL_INFO = 10118;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_AUTH_INFO = 10119;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_PURPOSE_AND_MODES_INFO = 10120;
  ATOM_KEYSTORE2_ATOM_WITH_OVERFLOW = 10121;
  ATOM_KEYSTORE2_KEY_OPERATION_WITH_PURPOSE_AND_MODES_INFO = 10122;
  ATOM_KEYSTORE2_KEY_OPERATION_WITH_GENERAL_INFO = 10123;
  ATOM_RKP_ERROR_STATS = 10124;
  ATOM_KEYSTORE2_CRASH_STATS = 10125;
  ATOM_VENDOR_APEX_INFO = 10126;
  ATOM_ACCESSIBILITY_SHORTCUT_STATS = 10127;
  ATOM_ACCESSIBILITY_FLOATING_MENU_STATS = 10128;
  ATOM_DATA_USAGE_BYTES_TRANSFER_V2 = 10129;
  ATOM_MEDIA_CAPABILITIES = 10130;
  ATOM_CAR_WATCHDOG_SYSTEM_IO_USAGE_SUMMARY = 10131;
  ATOM_CAR_WATCHDOG_UID_IO_USAGE_SUMMARY = 10132;
  ATOM_IMS_REGISTRATION_FEATURE_TAG_STATS = 10133;
  ATOM_RCS_CLIENT_PROVISIONING_STATS = 10134;
  ATOM_RCS_ACS_PROVISIONING_STATS = 10135;
  ATOM_SIP_DELEGATE_STATS = 10136;
  ATOM_SIP_TRANSPORT_FEATURE_TAG_STATS = 10137;
  ATOM_SIP_MESSAGE_RESPONSE = 10138;
  ATOM_SIP_TRANSPORT_SESSION = 10139;
  ATOM_IMS_DEDICATED_BEARER_LISTENER_EVENT = 10140;
  ATOM_IMS_DEDICATED_BEARER_EVENT = 10141;
  ATOM_IMS_REGISTRATION_SERVICE_DESC_STATS = 10142;
  ATOM_UCE_EVENT_STATS = 10143;
  ATOM_PRESENCE_NOTIFY_EVENT = 10144;
  ATOM_GBA_EVENT = 10145;
  ATOM_PER_SIM_STATUS = 10146;
  ATOM_GPU_WORK_PER_UID = 10147;
  ATOM_PERSISTENT_URI_PERMISSIONS_AMOUNT_PER_PACKAGE = 10148;
  ATOM_SIGNED_PARTITION_INFO = 10149;
  ATOM_PINNED_FILE_SIZES_PER_PACKAGE = 10150;
  ATOM_PENDING_INTENTS_PER_PACKAGE = 10151;
  ATOM_USER_INFO = 10152;
  ATOM_TELEPHONY_NETWORK_REQUESTS_V2 = 10153;
  ATOM_DEVICE_TELEPHONY_PROPERTIES = 10154;
  ATOM_REMOTE_KEY_PROVISIONING_ERROR_COUNTS = 10155;
  ATOM_SAFETY_STATE = 10156;
  ATOM_INCOMING_MMS = 10157;
  ATOM_OUTGOING_MMS = 10158;
  ATOM_MULTI_USER_INFO = 10160;
  ATOM_NETWORK_BPF_MAP_INFO = 10161;
  ATOM_OUTGOING_SHORT_CODE_SMS = 10162;
  ATOM_CONNECTIVITY_STATE_SAMPLE = 10163;
  ATOM_NETWORK_SELECTION_REMATCH_REASONS_INFO = 10164;
  ATOM_GAME_MODE_INFO = 10165;
  ATOM_GAME_MODE_CONFIGURATION = 10166;
  ATOM_GAME_MODE_LISTENER = 10167;
  ATOM_NETWORK_SLICE_REQUEST_COUNT = 10168;
  ATOM_WS_TILE_SNAPSHOT = 10169;
  ATOM_WS_ACTIVE_WATCH_FACE_COMPLICATION_SET_SNAPSHOT = 10170;
  ATOM_PROCESS_STATE = 10171;
  ATOM_PROCESS_ASSOCIATION = 10172;
  ATOM_ADPF_SYSTEM_COMPONENT_INFO = 10173;
  ATOM_NOTIFICATION_MEMORY_USE = 10174;
  ATOM_HDR_CAPABILITIES = 10175;
  ATOM_WS_FAVOURITE_WATCH_FACE_LIST_SNAPSHOT = 10176;
  ATOM_ACCESSIBILITY_CHECK_RESULT_REPORTED = 910;
  ATOM_ADAPTIVE_AUTH_UNLOCK_AFTER_LOCK_REPORTED = 820;
  ATOM_THERMAL_STATUS_CALLED = 772;
  ATOM_THERMAL_HEADROOM_CALLED = 773;
  ATOM_THERMAL_HEADROOM_THRESHOLDS_CALLED = 774;
  ATOM_ADPF_HINT_SESSION_TID_CLEANUP = 839;
  ATOM_THERMAL_HEADROOM_THRESHOLDS = 10201;
  ATOM_ADPF_SESSION_SNAPSHOT = 10218;
  ATOM_JSSCRIPTENGINE_LATENCY_REPORTED = 483;
  ATOM_AD_SERVICES_API_CALLED = 435;
  ATOM_AD_SERVICES_MESUREMENT_REPORTS_UPLOADED = 436;
  ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STATUS_REPORTED = 490;
  ATOM_MOBILE_DATA_DOWNLOAD_DOWNLOAD_RESULT_REPORTED = 502;
  ATOM_AD_SERVICES_SETTINGS_USAGE_REPORTED = 493;
  ATOM_BACKGROUND_FETCH_PROCESS_REPORTED = 496;
  ATOM_UPDATE_CUSTOM_AUDIENCE_PROCESS_REPORTED = 497;
  ATOM_RUN_AD_BIDDING_PROCESS_REPORTED = 498;
  ATOM_RUN_AD_SCORING_PROCESS_REPORTED = 499;
  ATOM_RUN_AD_SELECTION_PROCESS_REPORTED = 500;
  ATOM_RUN_AD_BIDDING_PER_CA_PROCESS_REPORTED = 501;
  ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STORAGE_STATS_REPORTED = 503;
  ATOM_AD_SERVICES_MEASUREMENT_REGISTRATIONS = 512;
  ATOM_AD_SERVICES_GET_TOPICS_REPORTED = 535;
  ATOM_AD_SERVICES_EPOCH_COMPUTATION_GET_TOP_TOPICS_REPORTED = 536;
  ATOM_AD_SERVICES_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 537;
  ATOM_AD_SERVICES_BACK_COMPAT_GET_TOPICS_REPORTED = 598;
  ATOM_AD_SERVICES_BACK_COMPAT_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 599;
  ATOM_AD_SERVICES_MEASUREMENT_DEBUG_KEYS = 640;
  ATOM_AD_SERVICES_ERROR_REPORTED = 662;
  ATOM_AD_SERVICES_BACKGROUND_JOBS_EXECUTION_REPORTED = 663;
  ATOM_AD_SERVICES_MEASUREMENT_DELAYED_SOURCE_REGISTRATION = 673;
  ATOM_AD_SERVICES_MEASUREMENT_ATTRIBUTION = 674;
  ATOM_AD_SERVICES_MEASUREMENT_JOBS = 675;
  ATOM_AD_SERVICES_MEASUREMENT_WIPEOUT = 676;
  ATOM_AD_SERVICES_MEASUREMENT_AD_ID_MATCH_FOR_DEBUG_KEYS = 695;
  ATOM_AD_SERVICES_ENROLLMENT_DATA_STORED = 697;
  ATOM_AD_SERVICES_ENROLLMENT_FILE_DOWNLOADED = 698;
  ATOM_AD_SERVICES_ENROLLMENT_MATCHED = 699;
  ATOM_AD_SERVICES_CONSENT_MIGRATED = 702;
  ATOM_AD_SERVICES_ENROLLMENT_FAILED = 714;
  ATOM_AD_SERVICES_MEASUREMENT_CLICK_VERIFICATION = 756;
  ATOM_AD_SERVICES_ENCRYPTION_KEY_FETCHED = 765;
  ATOM_AD_SERVICES_ENCRYPTION_KEY_DB_TRANSACTION_ENDED = 766;
  ATOM_DESTINATION_REGISTERED_BEACONS = 767;
  ATOM_REPORT_INTERACTION_API_CALLED = 768;
  ATOM_INTERACTION_REPORTING_TABLE_CLEARED = 769;
  ATOM_APP_MANIFEST_CONFIG_HELPER_CALLED = 788;
  ATOM_AD_FILTERING_PROCESS_JOIN_CA_REPORTED = 793;
  ATOM_AD_FILTERING_PROCESS_AD_SELECTION_REPORTED = 794;
  ATOM_AD_COUNTER_HISTOGRAM_UPDATER_REPORTED = 795;
  ATOM_SIGNATURE_VERIFICATION = 807;
  ATOM_K_ANON_IMMEDIATE_SIGN_JOIN_STATUS_REPORTED = 808;
  ATOM_K_ANON_BACKGROUND_JOB_STATUS_REPORTED = 809;
  ATOM_K_ANON_INITIALIZE_STATUS_REPORTED = 810;
  ATOM_K_ANON_SIGN_STATUS_REPORTED = 811;
  ATOM_K_ANON_JOIN_STATUS_REPORTED = 812;
  ATOM_K_ANON_KEY_ATTESTATION_STATUS_REPORTED = 813;
  ATOM_GET_AD_SELECTION_DATA_API_CALLED = 814;
  ATOM_GET_AD_SELECTION_DATA_BUYER_INPUT_GENERATED = 815;
  ATOM_BACKGROUND_JOB_SCHEDULING_REPORTED = 834;
  ATOM_TOPICS_ENCRYPTION_EPOCH_COMPUTATION_REPORTED = 840;
  ATOM_TOPICS_ENCRYPTION_GET_TOPICS_REPORTED = 841;
  ATOM_ADSERVICES_SHELL_COMMAND_CALLED = 842;
  ATOM_UPDATE_SIGNALS_API_CALLED = 843;
  ATOM_ENCODING_JOB_RUN = 844;
  ATOM_ENCODING_JS_FETCH = 845;
  ATOM_ENCODING_JS_EXECUTION = 846;
  ATOM_PERSIST_AD_SELECTION_RESULT_CALLED = 847;
  ATOM_SERVER_AUCTION_KEY_FETCH_CALLED = 848;
  ATOM_SERVER_AUCTION_BACKGROUND_KEY_FETCH_ENABLED = 849;
  ATOM_AD_SERVICES_MEASUREMENT_PROCESS_ODP_REGISTRATION = 864;
  ATOM_AD_SERVICES_MEASUREMENT_NOTIFY_REGISTRATION_TO_ODP = 865;
  ATOM_SELECT_ADS_FROM_OUTCOMES_API_CALLED = 876;
  ATOM_REPORT_IMPRESSION_API_CALLED = 877;
  ATOM_AD_SERVICES_ENROLLMENT_TRANSACTION_STATS = 885;
  ATOM_AD_SERVICES_COBALT_LOGGER_EVENT_REPORTED = 902;
  ATOM_AD_SERVICES_COBALT_PERIODIC_JOB_EVENT_REPORTED = 903;
  ATOM_UPDATE_SIGNALS_PROCESS_REPORTED = 905;
  ATOM_TOPICS_SCHEDULE_EPOCH_JOB_SETTING_REPORTED = 930;
  ATOM_AI_WALLPAPERS_BUTTON_PRESSED = 706;
  ATOM_AI_WALLPAPERS_TEMPLATE_SELECTED = 707;
  ATOM_AI_WALLPAPERS_TERM_SELECTED = 708;
  ATOM_AI_WALLPAPERS_WALLPAPER_SET = 709;
  ATOM_AI_WALLPAPERS_SESSION_SUMMARY = 710;
  ATOM_APEX_INSTALLATION_REQUESTED = 732;
  ATOM_APEX_INSTALLATION_STAGED = 733;
  ATOM_APEX_INSTALLATION_ENDED = 734;
  ATOM_APP_SEARCH_SET_SCHEMA_STATS_REPORTED = 385;
  ATOM_APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED = 579;
  ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_STATS_REPORTED = 825;
  ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_RAW_QUERY_STATS_REPORTED = 826;
  ATOM_APP_SEARCH_APPS_INDEXER_STATS_REPORTED = 909;
  ATOM_ART_DATUM_REPORTED = 332;
  ATOM_ART_DEVICE_DATUM_REPORTED = 550;
  ATOM_ART_DATUM_DELTA_REPORTED = 565;
  ATOM_ART_DEX2OAT_REPORTED = 929;
  ATOM_ART_DEVICE_STATUS = 10205;
  ATOM_BACKGROUND_DEXOPT_JOB_ENDED = 467;
  ATOM_PREREBOOT_DEXOPT_JOB_ENDED = 883;
  ATOM_ODREFRESH_REPORTED = 366;
  ATOM_ODSIGN_REPORTED = 548;
  ATOM_AUTOFILL_UI_EVENT_REPORTED = 603;
  ATOM_AUTOFILL_FILL_REQUEST_REPORTED = 604;
  ATOM_AUTOFILL_FILL_RESPONSE_REPORTED = 605;
  ATOM_AUTOFILL_SAVE_EVENT_REPORTED = 606;
  ATOM_AUTOFILL_SESSION_COMMITTED = 607;
  ATOM_AUTOFILL_FIELD_CLASSIFICATION_EVENT_REPORTED = 659;
  ATOM_CAR_RECENTS_EVENT_REPORTED = 770;
  ATOM_CAR_CALM_MODE_EVENT_REPORTED = 797;
  ATOM_CAR_WAKEUP_FROM_SUSPEND_REPORTED = 852;
  ATOM_PLUGIN_INITIALIZED = 655;
  ATOM_BLUETOOTH_HASHED_DEVICE_NAME_REPORTED = 613;
  ATOM_BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION = 614;
  ATOM_BLUETOOTH_L2CAP_COC_SERVER_CONNECTION = 615;
  ATOM_BLUETOOTH_LE_SESSION_CONNECTED = 656;
  ATOM_RESTRICTED_BLUETOOTH_DEVICE_NAME_REPORTED = 666;
  ATOM_BLUETOOTH_PROFILE_CONNECTION_ATTEMPTED = 696;
  ATOM_BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED = 781;
  ATOM_BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED = 782;
  ATOM_REMOTE_DEVICE_INFORMATION_WITH_METRIC_ID = 862;
  ATOM_LE_APP_SCAN_STATE_CHANGED = 870;
  ATOM_LE_RADIO_SCAN_STOPPED = 871;
  ATOM_LE_SCAN_RESULT_RECEIVED = 872;
  ATOM_LE_SCAN_ABUSED = 873;
  ATOM_LE_ADV_STATE_CHANGED = 874;
  ATOM_LE_ADV_ERROR_REPORTED = 875;
  ATOM_A2DP_SESSION_REPORTED = 904;
  ATOM_BLUETOOTH_CROSS_LAYER_EVENT_REPORTED = 916;
  ATOM_BROADCAST_AUDIO_SESSION_REPORTED = 927;
  ATOM_BROADCAST_AUDIO_SYNC_REPORTED = 928;
  ATOM_BLUETOOTH_RFCOMM_CONNECTION_REPORTED_AT_CLOSE = 982;
  ATOM_BLUETOOTH_LE_CONNECTION = 988;
  ATOM_BROADCAST_SENT = 922;
  ATOM_CAMERA_FEATURE_COMBINATION_QUERY_EVENT = 900;
  ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_STATE_CHANGED = 934;
  ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_FAILED = 972;
  ATOM_DAILY_KEEPALIVE_INFO_REPORTED = 650;
  ATOM_NETWORK_REQUEST_STATE_CHANGED = 779;
  ATOM_TETHERING_ACTIVE_SESSIONS_REPORTED = 925;
  ATOM_NETWORK_STATS_RECORDER_FILE_OPERATED = 783;
  ATOM_CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED = 979;
  ATOM_APF_SESSION_INFO_REPORTED = 777;
  ATOM_IP_CLIENT_RA_INFO_REPORTED = 778;
  ATOM_VPN_CONNECTION_STATE_CHANGED = 850;
  ATOM_VPN_CONNECTION_REPORTED = 851;
  ATOM_CPU_POLICY = 10199;
  ATOM_CREDENTIAL_MANAGER_API_CALLED = 585;
  ATOM_CREDENTIAL_MANAGER_INIT_PHASE_REPORTED = 651;
  ATOM_CREDENTIAL_MANAGER_CANDIDATE_PHASE_REPORTED = 652;
  ATOM_CREDENTIAL_MANAGER_FINAL_PHASE_REPORTED = 653;
  ATOM_CREDENTIAL_MANAGER_TOTAL_REPORTED = 667;
  ATOM_CREDENTIAL_MANAGER_FINALNOUID_REPORTED = 668;
  ATOM_CREDENTIAL_MANAGER_GET_REPORTED = 669;
  ATOM_CREDENTIAL_MANAGER_AUTH_CLICK_REPORTED = 670;
  ATOM_CREDENTIAL_MANAGER_APIV2_CALLED = 671;
  ATOM_CRONET_ENGINE_CREATED = 703;
  ATOM_CRONET_TRAFFIC_REPORTED = 704;
  ATOM_CRONET_ENGINE_BUILDER_INITIALIZED = 762;
  ATOM_CRONET_HTTP_FLAGS_INITIALIZED = 763;
  ATOM_CRONET_INITIALIZED = 764;
  ATOM_DESKTOP_MODE_UI_CHANGED = 818;
  ATOM_DESKTOP_MODE_SESSION_TASK_UPDATE = 819;
  ATOM_DESKTOP_MODE_TASK_SIZE_UPDATED = 935;
  ATOM_DEVICE_LOCK_CHECK_IN_REQUEST_REPORTED = 726;
  ATOM_DEVICE_LOCK_PROVISIONING_COMPLETE_REPORTED = 727;
  ATOM_DEVICE_LOCK_KIOSK_APP_REQUEST_REPORTED = 728;
  ATOM_DEVICE_LOCK_CHECK_IN_RETRY_REPORTED = 789;
  ATOM_DEVICE_LOCK_PROVISION_FAILURE_REPORTED = 790;
  ATOM_DEVICE_LOCK_LOCK_UNLOCK_DEVICE_FAILURE_REPORTED = 791;
  ATOM_DEVICE_POLICY_MANAGEMENT_MODE = 10216;
  ATOM_DEVICE_POLICY_STATE = 10217;
  ATOM_DISPLAY_MODE_DIRECTOR_VOTE_CHANGED = 792;
  ATOM_EXTERNAL_DISPLAY_STATE_CHANGED = 806;
  ATOM_DND_STATE_CHANGED = 657;
  ATOM_DREAM_SETTING_CHANGED = 705;
  ATOM_DREAM_SETTING_SNAPSHOT = 10192;
  ATOM_EXPRESS_EVENT_REPORTED = 528;
  ATOM_EXPRESS_HISTOGRAM_SAMPLE_REPORTED = 593;
  ATOM_EXPRESS_UID_EVENT_REPORTED = 644;
  ATOM_EXPRESS_UID_HISTOGRAM_SAMPLE_REPORTED = 658;
  ATOM_FEDERATED_COMPUTE_API_CALLED = 712;
  ATOM_FEDERATED_COMPUTE_TRAINING_EVENT_REPORTED = 771;
  ATOM_EXAMPLE_ITERATOR_NEXT_LATENCY_REPORTED = 838;
  ATOM_FULL_SCREEN_INTENT_LAUNCHED = 631;
  ATOM_BAL_ALLOWED = 632;
  ATOM_IN_TASK_ACTIVITY_STARTED = 685;
  ATOM_DEVICE_ORIENTATION_CHANGED = 906;
  ATOM_CACHED_APPS_HIGH_WATERMARK = 10189;
  ATOM_STYLUS_PREDICTION_METRICS_REPORTED = 718;
  ATOM_USER_RISK_EVENT_REPORTED = 725;
  ATOM_MEDIA_PROJECTION_STATE_CHANGED = 729;
  ATOM_MEDIA_PROJECTION_TARGET_CHANGED = 730;
  ATOM_EXCESSIVE_BINDER_PROXY_COUNT_REPORTED = 853;
  ATOM_PROXY_BYTES_TRANSFER_BY_FG_BG = 10200;
  ATOM_MOBILE_BYTES_TRANSFER_BY_PROC_STATE = 10204;
  ATOM_BIOMETRIC_FRR_NOTIFICATION = 817;
  ATOM_SENSITIVE_CONTENT_MEDIA_PROJECTION_SESSION = 830;
  ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_SESSION = 831;
  ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_APPLIED = 832;
  ATOM_SENSITIVE_NOTIFICATION_REDACTION = 833;
  ATOM_SENSITIVE_CONTENT_APP_PROTECTION = 835;
  ATOM_APP_RESTRICTION_STATE_CHANGED = 866;
  ATOM_BATTERY_USAGE_STATS_PER_UID = 10209;
  ATOM_POSTGC_MEMORY_SNAPSHOT = 924;
  ATOM_POWER_SAVE_TEMP_ALLOWLIST_CHANGED = 926;
  ATOM_APP_OP_ACCESS_TRACKED = 931;
  ATOM_CONTENT_OR_FILE_URI_EVENT_REPORTED = 933;
  ATOM_APPLICATION_GRAMMATICAL_INFLECTION_CHANGED = 584;
  ATOM_SYSTEM_GRAMMATICAL_INFLECTION_CHANGED = 816;
  ATOM_BATTERY_HEALTH = 10220;
  ATOM_HDMI_EARC_STATUS_REPORTED = 701;
  ATOM_HDMI_SOUNDBAR_MODE_STATUS_REPORTED = 724;
  ATOM_HEALTH_CONNECT_API_CALLED = 616;
  ATOM_HEALTH_CONNECT_USAGE_STATS = 617;
  ATOM_HEALTH_CONNECT_STORAGE_STATS = 618;
  ATOM_HEALTH_CONNECT_API_INVOKED = 643;
  ATOM_EXERCISE_ROUTE_API_CALLED = 654;
  ATOM_HEALTH_CONNECT_EXPORT_INVOKED = 907;
  ATOM_HEALTH_CONNECT_IMPORT_INVOKED = 918;
  ATOM_HEALTH_CONNECT_EXPORT_IMPORT_STATS_REPORTED = 919;
  ATOM_HEALTH_CONNECT_UI_IMPRESSION = 623;
  ATOM_HEALTH_CONNECT_UI_INTERACTION = 624;
  ATOM_HEALTH_CONNECT_APP_OPENED_REPORTED = 625;
  ATOM_HOTWORD_EGRESS_SIZE_ATOM_REPORTED = 761;
  ATOM_IKE_SESSION_TERMINATED = 678;
  ATOM_IKE_LIVENESS_CHECK_SESSION_VALIDATED = 760;
  ATOM_NEGOTIATED_SECURITY_ASSOCIATION = 821;
  ATOM_KEYBOARD_CONFIGURED = 682;
  ATOM_KEYBOARD_SYSTEMS_EVENT_REPORTED = 683;
  ATOM_INPUTDEVICE_USAGE_REPORTED = 686;
  ATOM_INPUT_EVENT_LATENCY_REPORTED = 932;
  ATOM_TOUCHPAD_USAGE = 10191;
  ATOM_KERNEL_OOM_KILL_OCCURRED = 754;
  ATOM_EMERGENCY_STATE_CHANGED = 633;
  ATOM_CHRE_SIGNIFICANT_MOTION_STATE_CHANGED = 868;
  ATOM_POPULATION_DENSITY_PROVIDER_LOADING_REPORTED = 1002;
  ATOM_DENSITY_BASED_COARSE_LOCATIONS_USAGE_REPORTED = 1003;
  ATOM_DENSITY_BASED_COARSE_LOCATIONS_PROVIDER_QUERY_REPORTED = 1004;
  ATOM_MEDIA_CODEC_RECLAIM_REQUEST_COMPLETED = 600;
  ATOM_MEDIA_CODEC_STARTED = 641;
  ATOM_MEDIA_CODEC_STOPPED = 642;
  ATOM_MEDIA_CODEC_RENDERED = 684;
  ATOM_MEDIA_EDITING_ENDED_REPORTED = 798;
  ATOM_MTE_STATE = 10181;
  ATOM_MICROXR_DEVICE_BOOT_COMPLETE_REPORTED = 901;
  ATOM_NFC_OBSERVE_MODE_STATE_CHANGED = 855;
  ATOM_NFC_FIELD_CHANGED = 856;
  ATOM_NFC_POLLING_LOOP_NOTIFICATION_REPORTED = 857;
  ATOM_NFC_PROPRIETARY_CAPABILITIES_REPORTED = 858;
  ATOM_ONDEVICEPERSONALIZATION_API_CALLED = 711;
  ATOM_COMPONENT_STATE_CHANGED_REPORTED = 863;
  ATOM_PDF_LOAD_REPORTED = 859;
  ATOM_PDF_API_USAGE_REPORTED = 860;
  ATOM_PDF_SEARCH_REPORTED = 861;
  ATOM_PRESSURE_STALL_INFORMATION = 10229;
  ATOM_PERMISSION_RATIONALE_DIALOG_VIEWED = 645;
  ATOM_PERMISSION_RATIONALE_DIALOG_ACTION_REPORTED = 646;
  ATOM_APP_DATA_SHARING_UPDATES_NOTIFICATION_INTERACTION = 647;
  ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_VIEWED = 648;
  ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_ACTION_REPORTED = 649;
  ATOM_ENHANCED_CONFIRMATION_DIALOG_RESULT_REPORTED = 827;
  ATOM_ENHANCED_CONFIRMATION_RESTRICTION_CLEARED = 828;
  ATOM_PHOTOPICKER_SESSION_INFO_REPORTED = 886;
  ATOM_PHOTOPICKER_API_INFO_REPORTED = 887;
  ATOM_PHOTOPICKER_UI_EVENT_LOGGED = 888;
  ATOM_PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED = 889;
  ATOM_PHOTOPICKER_PREVIEW_INFO_LOGGED = 890;
  ATOM_PHOTOPICKER_MENU_INTERACTION_LOGGED = 891;
  ATOM_PHOTOPICKER_BANNER_INTERACTION_LOGGED = 892;
  ATOM_PHOTOPICKER_MEDIA_LIBRARY_INFO_LOGGED = 893;
  ATOM_PHOTOPICKER_PAGE_INFO_LOGGED = 894;
  ATOM_PHOTOPICKER_MEDIA_GRID_SYNC_INFO_REPORTED = 895;
  ATOM_PHOTOPICKER_ALBUM_SYNC_INFO_REPORTED = 896;
  ATOM_PHOTOPICKER_SEARCH_INFO_REPORTED = 897;
  ATOM_SEARCH_DATA_EXTRACTION_DETAILS_REPORTED = 898;
  ATOM_EMBEDDED_PHOTOPICKER_INFO_REPORTED = 899;
  ATOM_ATOM_9999 = 9999;
  ATOM_ATOM_99999 = 99999;
  ATOM_SCREEN_OFF_REPORTED = 776;
  ATOM_SCREEN_TIMEOUT_OVERRIDE_REPORTED = 836;
  ATOM_SCREEN_INTERACTIVE_SESSION_REPORTED = 837;
  ATOM_SCREEN_DIM_REPORTED = 867;
  ATOM_MEDIA_PROVIDER_DATABASE_ROLLBACK_REPORTED = 784;
  ATOM_BACKUP_SETUP_STATUS_REPORTED = 785;
  ATOM_RANGING_SESSION_CONFIGURED = 993;
  ATOM_RANGING_SESSION_STARTED = 994;
  ATOM_RANGING_SESSION_CLOSED = 995;
  ATOM_RANGING_TECHNOLOGY_STARTED = 996;
  ATOM_RANGING_TECHNOLOGY_STOPPED = 997;
  ATOM_RKPD_POOL_STATS = 664;
  ATOM_RKPD_CLIENT_OPERATION = 665;
  ATOM_SANDBOX_API_CALLED = 488;
  ATOM_SANDBOX_ACTIVITY_EVENT_OCCURRED = 735;
  ATOM_SDK_SANDBOX_RESTRICTED_ACCESS_IN_SESSION = 796;
  ATOM_SANDBOX_SDK_STORAGE = 10159;
  ATOM_SELINUX_AUDIT_LOG = 799;
  ATOM_SETTINGS_SPA_REPORTED = 622;
  ATOM_TEST_EXTENSION_ATOM_REPORTED = 660;
  ATOM_TEST_RESTRICTED_ATOM_REPORTED = 672;
  ATOM_STATS_SOCKET_LOSS_REPORTED = 752;
  ATOM_LOCKSCREEN_SHORTCUT_SELECTED = 611;
  ATOM_LOCKSCREEN_SHORTCUT_TRIGGERED = 612;
  ATOM_LAUNCHER_IMPRESSION_EVENT_V2 = 716;
  ATOM_DISPLAY_SWITCH_LATENCY_TRACKED = 753;
  ATOM_NOTIFICATION_LISTENER_SERVICE = 829;
  ATOM_NAV_HANDLE_TOUCH_POINTS = 869;
  ATOM_COMMUNAL_HUB_WIDGET_EVENT_REPORTED = 908;
  ATOM_COMMUNAL_HUB_SNAPSHOT = 10226;
  ATOM_EMERGENCY_NUMBER_DIALED = 637;
  ATOM_CALL_STATS = 10221;
  ATOM_CALL_AUDIO_ROUTE_STATS = 10222;
  ATOM_TELECOM_API_STATS = 10223;
  ATOM_TELECOM_ERROR_STATS = 10224;
  ATOM_CELLULAR_RADIO_POWER_STATE_CHANGED = 713;
  ATOM_EMERGENCY_NUMBERS_INFO = 10180;
  ATOM_DATA_NETWORK_VALIDATION = 10207;
  ATOM_DATA_RAT_STATE_CHANGED = 854;
  ATOM_CONNECTED_CHANNEL_CHANGED = 882;
  ATOM_IWLAN_UNDERLYING_NETWORK_VALIDATION_RESULT_REPORTED = 923;
  ATOM_QUALIFIED_RAT_LIST_CHANGED = 634;
  ATOM_QNS_IMS_CALL_DROP_STATS = 635;
  ATOM_QNS_FALLBACK_RESTRICTION_CHANGED = 636;
  ATOM_QNS_RAT_PREFERENCE_MISMATCH_INFO = 10177;
  ATOM_QNS_HANDOVER_TIME_MILLIS = 10178;
  ATOM_QNS_HANDOVER_PINGPONG = 10179;
  ATOM_SATELLITE_CONTROLLER = 10182;
  ATOM_SATELLITE_SESSION = 10183;
  ATOM_SATELLITE_INCOMING_DATAGRAM = 10184;
  ATOM_SATELLITE_OUTGOING_DATAGRAM = 10185;
  ATOM_SATELLITE_PROVISION = 10186;
  ATOM_SATELLITE_SOS_MESSAGE_RECOMMENDER = 10187;
  ATOM_CARRIER_ROAMING_SATELLITE_SESSION = 10211;
  ATOM_CARRIER_ROAMING_SATELLITE_CONTROLLER_STATS = 10212;
  ATOM_CONTROLLER_STATS_PER_PACKAGE = 10213;
  ATOM_SATELLITE_ENTITLEMENT = 10214;
  ATOM_SATELLITE_CONFIG_UPDATER = 10215;
  ATOM_SATELLITE_ACCESS_CONTROLLER = 10219;
  ATOM_CELLULAR_IDENTIFIER_DISCLOSED = 800;
  ATOM_THREADNETWORK_TELEMETRY_DATA_REPORTED = 738;
  ATOM_THREADNETWORK_TOPO_ENTRY_REPEATED = 739;
  ATOM_THREADNETWORK_DEVICE_INFO_REPORTED = 740;
  ATOM_BOOT_INTEGRITY_INFO_REPORTED = 775;
  ATOM_TV_LOW_POWER_STANDBY_POLICY = 679;
  ATOM_EXTERNAL_TV_INPUT_EVENT = 717;
  ATOM_TEST_UPROBESTATS_ATOM_REPORTED = 915;
  ATOM_UWB_ACTIVITY_INFO = 10188;
  ATOM_MEDIATOR_UPDATED = 721;
  ATOM_SYSPROXY_BLUETOOTH_BYTES_TRANSFER = 10196;
  ATOM_SYSPROXY_CONNECTION_UPDATED = 786;
  ATOM_WEAR_COMPANION_CONNECTION_STATE = 921;
  ATOM_MEDIA_ACTION_REPORTED = 608;
  ATOM_MEDIA_CONTROLS_LAUNCHED = 609;
  ATOM_MEDIA_SESSION_STATE_CHANGED = 677;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_API_LATENCY = 757;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_SASS_DEVICE_UNAVAILABLE = 758;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FASTPAIR_API_TIMEOUT = 759;
  ATOM_WEAR_MODE_STATE_CHANGED = 715;
  ATOM_RENDERER_INITIALIZED = 736;
  ATOM_SCHEMA_VERSION_RECEIVED = 737;
  ATOM_LAYOUT_INSPECTED = 741;
  ATOM_LAYOUT_EXPRESSION_INSPECTED = 742;
  ATOM_LAYOUT_ANIMATIONS_INSPECTED = 743;
  ATOM_MATERIAL_COMPONENTS_INSPECTED = 744;
  ATOM_TILE_REQUESTED = 745;
  ATOM_STATE_RESPONSE_RECEIVED = 746;
  ATOM_TILE_RESPONSE_RECEIVED = 747;
  ATOM_INFLATION_FINISHED = 748;
  ATOM_INFLATION_FAILED = 749;
  ATOM_IGNORED_INFLATION_FAILURES_REPORTED = 750;
  ATOM_DRAWABLE_RENDERED = 751;
  ATOM_WEAR_TIME_SYNC_REQUESTED = 911;
  ATOM_WEAR_TIME_UPDATE_STARTED = 912;
  ATOM_WEAR_TIME_SYNC_ATTEMPT_COMPLETED = 913;
  ATOM_WEAR_TIME_CHANGED = 914;
  ATOM_WEAR_ADAPTIVE_SUSPEND_STATS_REPORTED = 619;
  ATOM_WEAR_POWER_ANOMALY_SERVICE_OPERATIONAL_STATS_REPORTED = 620;
  ATOM_WEAR_POWER_ANOMALY_SERVICE_EVENT_STATS_REPORTED = 621;
  ATOM_WS_WEAR_TIME_SESSION = 610;
  ATOM_WS_INCOMING_CALL_ACTION_REPORTED = 626;
  ATOM_WS_CALL_DISCONNECTION_REPORTED = 627;
  ATOM_WS_CALL_DURATION_REPORTED = 628;
  ATOM_WS_CALL_USER_EXPERIENCE_LATENCY_REPORTED = 629;
  ATOM_WS_CALL_INTERACTION_REPORTED = 630;
  ATOM_WS_ON_BODY_STATE_CHANGED = 787;
  ATOM_WS_WATCH_FACE_RESTRICTED_COMPLICATIONS_IMPACTED = 802;
  ATOM_WS_WATCH_FACE_DEFAULT_RESTRICTED_COMPLICATIONS_REMOVED = 803;
  ATOM_WS_COMPLICATIONS_IMPACTED_NOTIFICATION_EVENT_REPORTED = 804;
  ATOM_WS_REMOTE_EVENT_USAGE_REPORTED = 920;
  ATOM_WS_BUGREPORT_REQUESTED = 936;
  ATOM_WS_BUGREPORT_TRIGGERED = 937;
  ATOM_WS_BUGREPORT_FINISHED = 938;
  ATOM_WS_BUGREPORT_RESULT_RECEIVED = 939;
  ATOM_WS_STANDALONE_MODE_SNAPSHOT = 10197;
  ATOM_WS_FAVORITE_WATCH_FACE_SNAPSHOT = 10206;
  ATOM_WS_PHOTOS_WATCH_FACE_FEATURE_SNAPSHOT = 10225;
  ATOM_WS_WATCH_FACE_CUSTOMIZATION_SNAPSHOT = 10227;
  ATOM_WEAR_POWER_MENU_OPENED = 731;
  ATOM_WEAR_ASSISTANT_OPENED = 755;
  ATOM_FIRST_OVERLAY_STATE_CHANGED = 917;
  ATOM_WIFI_AWARE_NDP_REPORTED = 638;
  ATOM_WIFI_AWARE_ATTACH_REPORTED = 639;
  ATOM_WIFI_SELF_RECOVERY_TRIGGERED = 661;
  ATOM_SOFT_AP_STARTED = 680;
  ATOM_SOFT_AP_STOPPED = 681;
  ATOM_WIFI_LOCK_RELEASED = 687;
  ATOM_WIFI_LOCK_DEACTIVATED = 688;
  ATOM_WIFI_CONFIG_SAVED = 689;
  ATOM_WIFI_AWARE_RESOURCE_USING_CHANGED = 690;
  ATOM_WIFI_AWARE_HAL_API_CALLED = 691;
  ATOM_WIFI_LOCAL_ONLY_REQUEST_RECEIVED = 692;
  ATOM_WIFI_LOCAL_ONLY_REQUEST_SCAN_TRIGGERED = 693;
  ATOM_WIFI_THREAD_TASK_EXECUTED = 694;
  ATOM_WIFI_STATE_CHANGED = 700;
  ATOM_PNO_SCAN_STARTED = 719;
  ATOM_PNO_SCAN_STOPPED = 720;
  ATOM_WIFI_IS_UNUSABLE_REPORTED = 722;
  ATOM_WIFI_AP_CAPABILITIES_REPORTED = 723;
  ATOM_SOFT_AP_STATE_CHANGED = 805;
  ATOM_SCORER_PREDICTION_RESULT_REPORTED = 884;
  ATOM_WIFI_AWARE_CAPABILITIES = 10190;
  ATOM_WIFI_MODULE_INFO = 10193;
  ATOM_WIFI_SETTING_INFO = 10194;
  ATOM_WIFI_COMPLEX_SETTING_INFO = 10195;
  ATOM_WIFI_CONFIGURED_NETWORK_INFO = 10198;
}
// End of protos/perfetto/config/statsd/atom_ids.proto

// Begin of protos/perfetto/config/statsd/statsd_tracing_config.proto

// This file is named 'statsd_tracing_config.proto' rather than
// 'statsd_config.proto' (which would be more consistent with the other
// config protos) so it doesn't show up and confuse folks looking for
// the existing statsd_config.proto for configuring statsd itself.
// Same for the config proto itself.
message StatsdTracingConfig {
  // This is for the common case of the atom id being known in the enum AtomId.
  repeated AtomId push_atom_id = 1;

  // Escape hatch for Atom IDs that are not yet in the AtomId enum
  // (e.g. non-upstream atoms that don't exist in AOSP).
  repeated int32 raw_push_atom_id = 2;
  repeated StatsdPullAtomConfig pull_config = 3;
}

message StatsdPullAtomConfig {
  repeated AtomId pull_atom_id = 1;
  repeated int32 raw_pull_atom_id = 2;

  optional int32 pull_frequency_ms = 3;
  repeated string packages = 4;
}

// End of protos/perfetto/config/statsd/statsd_tracing_config.proto

// Begin of protos/perfetto/common/sys_stats_counters.proto

// When editing entries here remember also to update "sys_stats_counters.h" with
// the corresponding string definitions for the actual /proc files parser.

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0;
  MEMINFO_MEM_TOTAL = 1;
  MEMINFO_MEM_FREE = 2;
  MEMINFO_MEM_AVAILABLE = 3;
  MEMINFO_BUFFERS = 4;
  MEMINFO_CACHED = 5;
  MEMINFO_SWAP_CACHED = 6;
  MEMINFO_ACTIVE = 7;
  MEMINFO_INACTIVE = 8;
  MEMINFO_ACTIVE_ANON = 9;
  MEMINFO_INACTIVE_ANON = 10;
  MEMINFO_ACTIVE_FILE = 11;
  MEMINFO_INACTIVE_FILE = 12;
  MEMINFO_UNEVICTABLE = 13;
  MEMINFO_MLOCKED = 14;
  MEMINFO_SWAP_TOTAL = 15;
  MEMINFO_SWAP_FREE = 16;
  MEMINFO_DIRTY = 17;
  MEMINFO_WRITEBACK = 18;
  MEMINFO_ANON_PAGES = 19;
  MEMINFO_MAPPED = 20;
  MEMINFO_SHMEM = 21;
  MEMINFO_SLAB = 22;
  MEMINFO_SLAB_RECLAIMABLE = 23;
  MEMINFO_SLAB_UNRECLAIMABLE = 24;
  MEMINFO_KERNEL_STACK = 25;
  MEMINFO_PAGE_TABLES = 26;
  MEMINFO_COMMIT_LIMIT = 27;
  MEMINFO_COMMITED_AS = 28;
  MEMINFO_VMALLOC_TOTAL = 29;
  MEMINFO_VMALLOC_USED = 30;
  MEMINFO_VMALLOC_CHUNK = 31;
  MEMINFO_CMA_TOTAL = 32;
  MEMINFO_CMA_FREE = 33;
  MEMINFO_GPU = 34;
  MEMINFO_ZRAM = 35;
  MEMINFO_MISC = 36;
  MEMINFO_ION_HEAP = 37;
  MEMINFO_ION_HEAP_POOL = 38;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0;
  VMSTAT_NR_FREE_PAGES = 1;
  VMSTAT_NR_ALLOC_BATCH = 2;
  VMSTAT_NR_INACTIVE_ANON = 3;
  VMSTAT_NR_ACTIVE_ANON = 4;
  VMSTAT_NR_INACTIVE_FILE = 5;
  VMSTAT_NR_ACTIVE_FILE = 6;
  VMSTAT_NR_UNEVICTABLE = 7;
  VMSTAT_NR_MLOCK = 8;
  VMSTAT_NR_ANON_PAGES = 9;
  VMSTAT_NR_MAPPED = 10;
  VMSTAT_NR_FILE_PAGES = 11;
  VMSTAT_NR_DIRTY = 12;
  VMSTAT_NR_WRITEBACK = 13;
  VMSTAT_NR_SLAB_RECLAIMABLE = 14;
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;
  VMSTAT_NR_PAGE_TABLE_PAGES = 16;
  VMSTAT_NR_KERNEL_STACK = 17;
  VMSTAT_NR_OVERHEAD = 18;
  VMSTAT_NR_UNSTABLE = 19;
  VMSTAT_NR_BOUNCE = 20;
  VMSTAT_NR_VMSCAN_WRITE = 21;
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  VMSTAT_NR_WRITEBACK_TEMP = 23;
  VMSTAT_NR_ISOLATED_ANON = 24;
  VMSTAT_NR_ISOLATED_FILE = 25;
  VMSTAT_NR_SHMEM = 26;
  VMSTAT_NR_DIRTIED = 27;
  VMSTAT_NR_WRITTEN = 28;
  VMSTAT_NR_PAGES_SCANNED = 29;
  VMSTAT_WORKINGSET_REFAULT = 30;
  VMSTAT_WORKINGSET_ACTIVATE = 31;
  VMSTAT_WORKINGSET_NODERECLAIM = 32;
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  VMSTAT_NR_FREE_CMA = 34;
  VMSTAT_NR_SWAPCACHE = 35;
  VMSTAT_NR_DIRTY_THRESHOLD = 36;
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  VMSTAT_PGPGIN = 38;
  VMSTAT_PGPGOUT = 39;
  VMSTAT_PGPGOUTCLEAN = 40;
  VMSTAT_PSWPIN = 41;
  VMSTAT_PSWPOUT = 42;
  VMSTAT_PGALLOC_DMA = 43;
  VMSTAT_PGALLOC_NORMAL = 44;
  VMSTAT_PGALLOC_MOVABLE = 45;
  VMSTAT_PGFREE = 46;
  VMSTAT_PGACTIVATE = 47;
  VMSTAT_PGDEACTIVATE = 48;
  VMSTAT_PGFAULT = 49;
  VMSTAT_PGMAJFAULT = 50;
  VMSTAT_PGREFILL_DMA = 51;
  VMSTAT_PGREFILL_NORMAL = 52;
  VMSTAT_PGREFILL_MOVABLE = 53;
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54;
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;
  VMSTAT_PGSTEAL_DIRECT_DMA = 57;
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;
  VMSTAT_PGSCAN_KSWAPD_DMA = 60;
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;
  VMSTAT_PGSCAN_DIRECT_DMA = 63;
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64;
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;
  VMSTAT_PGINODESTEAL = 67;
  VMSTAT_SLABS_SCANNED = 68;
  VMSTAT_KSWAPD_INODESTEAL = 69;
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  VMSTAT_PAGEOUTRUN = 72;
  VMSTAT_ALLOCSTALL = 73;
  VMSTAT_PGROTATED = 74;
  VMSTAT_DROP_PAGECACHE = 75;
  VMSTAT_DROP_SLAB = 76;
  VMSTAT_PGMIGRATE_SUCCESS = 77;
  VMSTAT_PGMIGRATE_FAIL = 78;
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79;
  VMSTAT_COMPACT_FREE_SCANNED = 80;
  VMSTAT_COMPACT_ISOLATED = 81;
  VMSTAT_COMPACT_STALL = 82;
  VMSTAT_COMPACT_FAIL = 83;
  VMSTAT_COMPACT_SUCCESS = 84;
  VMSTAT_COMPACT_DAEMON_WAKE = 85;
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86;
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;
  VMSTAT_NR_ZSPAGES = 93;
  VMSTAT_NR_ION_HEAP = 94;
  VMSTAT_NR_GPU_HEAP = 95;
  VMSTAT_ALLOCSTALL_DMA = 96;
  VMSTAT_ALLOCSTALL_MOVABLE = 97;
  VMSTAT_ALLOCSTALL_NORMAL = 98;
  VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99;
  VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100;
  VMSTAT_NR_FASTRPC = 101;
  VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102;
  VMSTAT_NR_ION_HEAP_POOL = 103;
  VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104;
  VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105;
  VMSTAT_NR_SHMEM_HUGEPAGES = 106;
  VMSTAT_NR_SHMEM_PMDMAPPED = 107;
  VMSTAT_NR_UNRECLAIMABLE_PAGES = 108;
  VMSTAT_NR_ZONE_ACTIVE_ANON = 109;
  VMSTAT_NR_ZONE_ACTIVE_FILE = 110;
  VMSTAT_NR_ZONE_INACTIVE_ANON = 111;
  VMSTAT_NR_ZONE_INACTIVE_FILE = 112;
  VMSTAT_NR_ZONE_UNEVICTABLE = 113;
  VMSTAT_NR_ZONE_WRITE_PENDING = 114;
  VMSTAT_OOM_KILL = 115;
  VMSTAT_PGLAZYFREE = 116;
  VMSTAT_PGLAZYFREED = 117;
  VMSTAT_PGREFILL = 118;
  VMSTAT_PGSCAN_DIRECT = 119;
  VMSTAT_PGSCAN_KSWAPD = 120;
  VMSTAT_PGSKIP_DMA = 121;
  VMSTAT_PGSKIP_MOVABLE = 122;
  VMSTAT_PGSKIP_NORMAL = 123;
  VMSTAT_PGSTEAL_DIRECT = 124;
  VMSTAT_PGSTEAL_KSWAPD = 125;
  VMSTAT_SWAP_RA = 126;
  VMSTAT_SWAP_RA_HIT = 127;
  VMSTAT_WORKINGSET_RESTORE = 128;
  VMSTAT_ALLOCSTALL_DEVICE = 129;
  VMSTAT_ALLOCSTALL_DMA32 = 130;
  VMSTAT_BALLOON_DEFLATE = 131;
  VMSTAT_BALLOON_INFLATE = 132;
  VMSTAT_BALLOON_MIGRATE = 133;
  VMSTAT_CMA_ALLOC_FAIL = 134;
  VMSTAT_CMA_ALLOC_SUCCESS = 135;
  VMSTAT_NR_FILE_HUGEPAGES = 136;
  VMSTAT_NR_FILE_PMDMAPPED = 137;
  VMSTAT_NR_FOLL_PIN_ACQUIRED = 138;
  VMSTAT_NR_FOLL_PIN_RELEASED = 139;
  VMSTAT_NR_SEC_PAGE_TABLE_PAGES = 140;
  VMSTAT_NR_SHADOW_CALL_STACK = 141;
  VMSTAT_NR_SWAPCACHED = 142;
  VMSTAT_NR_THROTTLED_WRITTEN = 143;
  VMSTAT_PGALLOC_DEVICE = 144;
  VMSTAT_PGALLOC_DMA32 = 145;
  VMSTAT_PGDEMOTE_DIRECT = 146;
  VMSTAT_PGDEMOTE_KSWAPD = 147;
  VMSTAT_PGREUSE = 148;
  VMSTAT_PGSCAN_ANON = 149;
  VMSTAT_PGSCAN_FILE = 150;
  VMSTAT_PGSKIP_DEVICE = 151;
  VMSTAT_PGSKIP_DMA32 = 152;
  VMSTAT_PGSTEAL_ANON = 153;
  VMSTAT_PGSTEAL_FILE = 154;
  VMSTAT_THP_COLLAPSE_ALLOC = 155;
  VMSTAT_THP_COLLAPSE_ALLOC_FAILED = 156;
  VMSTAT_THP_DEFERRED_SPLIT_PAGE = 157;
  VMSTAT_THP_FAULT_ALLOC = 158;
  VMSTAT_THP_FAULT_FALLBACK = 159;
  VMSTAT_THP_FAULT_FALLBACK_CHARGE = 160;
  VMSTAT_THP_FILE_ALLOC = 161;
  VMSTAT_THP_FILE_FALLBACK = 162;
  VMSTAT_THP_FILE_FALLBACK_CHARGE = 163;
  VMSTAT_THP_FILE_MAPPED = 164;
  VMSTAT_THP_MIGRATION_FAIL = 165;
  VMSTAT_THP_MIGRATION_SPLIT = 166;
  VMSTAT_THP_MIGRATION_SUCCESS = 167;
  VMSTAT_THP_SCAN_EXCEED_NONE_PTE = 168;
  VMSTAT_THP_SCAN_EXCEED_SHARE_PTE = 169;
  VMSTAT_THP_SCAN_EXCEED_SWAP_PTE = 170;
  VMSTAT_THP_SPLIT_PAGE = 171;
  VMSTAT_THP_SPLIT_PAGE_FAILED = 172;
  VMSTAT_THP_SPLIT_PMD = 173;
  VMSTAT_THP_SWPOUT = 174;
  VMSTAT_THP_SWPOUT_FALLBACK = 175;
  VMSTAT_THP_ZERO_PAGE_ALLOC = 176;
  VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED = 177;
  VMSTAT_VMA_LOCK_ABORT = 178;
  VMSTAT_VMA_LOCK_MISS = 179;
  VMSTAT_VMA_LOCK_RETRY = 180;
  VMSTAT_VMA_LOCK_SUCCESS = 181;
  VMSTAT_WORKINGSET_ACTIVATE_ANON = 182;
  VMSTAT_WORKINGSET_ACTIVATE_FILE = 183;
  VMSTAT_WORKINGSET_NODES = 184;
  VMSTAT_WORKINGSET_REFAULT_ANON = 185;
  VMSTAT_WORKINGSET_REFAULT_FILE = 186;
  VMSTAT_WORKINGSET_RESTORE_ANON = 187;
  VMSTAT_WORKINGSET_RESTORE_FILE = 188;
}

// End of protos/perfetto/common/sys_stats_counters.proto

// Begin of protos/perfetto/config/sys_stats/sys_stats_config.proto

// This file defines the configuration for the Linux /proc poller data source,
// which injects counters in the trace.
// Counters that are needed in the trace must be explicitly listed in the
// *_counters fields. This is to avoid spamming the trace with all counters
// at all times.
// The sampling rate is configurable. All polling rates (*_period_ms) need
// to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
message SysStatsConfig {
  // Polls /proc/meminfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
  optional uint32 meminfo_period_ms = 1;

  // If empty all known counters are reported. Otherwise, only the counters
  // specified below are reported.
  repeated MeminfoCounters meminfo_counters = 2;

  // Polls /proc/vmstat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
  optional uint32 vmstat_period_ms = 3;
  repeated VmstatCounters vmstat_counters = 4;

  // Pols /proc/stat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
  optional uint32 stat_period_ms = 5;
  enum StatCounters {
    STAT_UNSPECIFIED = 0;
    STAT_CPU_TIMES = 1;
    STAT_IRQ_COUNTS = 2;
    STAT_SOFTIRQ_COUNTS = 3;
    STAT_FORK_COUNT = 4;
  }
  repeated StatCounters stat_counters = 6;

  // Polls /sys/devfreq/*/curfreq every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // This option can be used to record unchanging values.
  // Updates from frequency changes can come from ftrace/set_clock_rate.
  optional uint32 devfreq_period_ms = 7;

  // Polls /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq every X ms.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpufreq_period_ms = 8;

  // Polls /proc/buddyinfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 buddyinfo_period_ms = 9;

  // Polls /proc/diskstats every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 diskstat_period_ms = 10;

  // Polls /proc/pressure/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 psi_period_ms = 11;

  // Polls /sys/class/thermal/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 thermal_period_ms = 12;

  // Polls /sys/devices/system/cpu/cpu*/cpuidle/state* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpuidle_period_ms = 13;

  // Polls device-specific GPU frequency info every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 gpufreq_period_ms = 14;
}

// End of protos/perfetto/config/sys_stats/sys_stats_config.proto

// Begin of protos/perfetto/config/system_info/system_info_config.proto

// This data-source does a one-off recording of system information when
// the trace starts.
// Currently this includes:
// - Values of
// /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies This
// datasource has no configuration options at present.
message SystemInfoConfig {}

// End of protos/perfetto/config/system_info/system_info_config.proto

// Begin of protos/perfetto/config/test_config.proto

// The configuration for a fake producer used in tests.
message TestConfig {
  message DummyFields {
    optional uint32 field_uint32 = 1;
    optional int32 field_int32 = 2;
    optional uint64 field_uint64 = 3;
    optional int64 field_int64 = 4;
    optional fixed64 field_fixed64 = 5;
    optional sfixed64 field_sfixed64 = 6;
    optional fixed32 field_fixed32 = 7;
    optional sfixed32 field_sfixed32 = 8;
    optional double field_double = 9;
    optional float field_float = 10;
    optional sint64 field_sint64 = 11;
    optional sint32 field_sint32 = 12;
    optional string field_string = 13;
    optional bytes field_bytes = 14;
  }

  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;

  optional DummyFields dummy_fields = 6;
}

// End of protos/perfetto/config/test_config.proto

// Begin of protos/perfetto/config/track_event/track_event_config.proto

message TrackEventConfig {
  // The following fields define the set of enabled trace categories. Each list
  // item is a glob.
  //
  // To determine if category is enabled, it is checked against the filters in
  // the following order:
  //
  //   1. Exact matches in enabled categories.
  //   2. Exact matches in enabled tags.
  //   3. Exact matches in disabled categories.
  //   4. Exact matches in disabled tags.
  //   5. Pattern matches in enabled categories.
  //   6. Pattern matches in enabled tags.
  //   7. Pattern matches in disabled categories.
  //   8. Pattern matches in disabled tags.
  //
  // If none of the steps produced a match:
  //  - In the C++ SDK (`perfetto::Category`), categories are enabled by
  //  default.
  //  - In the C SDK (`PerfettoTeCategory`), categories are disabled by default.
  //
  // Examples:
  //
  //  - To enable all non-slow/debug categories:
  //
  //       enabled_categories: "*"
  //
  //  - To enable specific categories:
  //
  //       disabled_categories: "*"
  //       enabled_categories: "my_category"
  //       enabled_categories: "my_category2"
  //
  //  - To enable only categories with a specific tag:
  //
  //       disabled_tags: "*"
  //       enabled_tags: "my_tag"
  //

  // Default: []
  repeated string disabled_categories = 1;

  // Default: []
  repeated string enabled_categories = 2;

  // Default: ["slow", "debug"]
  repeated string disabled_tags = 3;

  // Default: []
  repeated string enabled_tags = 4;

  // Default: false (i.e. enabled by default)
  optional bool disable_incremental_timestamps = 5;

  // Allows to specify a custom unit different than the default (ns).
  // Also affects thread timestamps if enable_thread_time_sampling = true.
  // A multiplier of 1000 means that a timestamp = 3 should be interpreted as
  // 3000 ns = 3 us.
  // Default: 1 (if unset, it should be read as 1).
  optional uint64 timestamp_unit_multiplier = 6;

  // Default: false (i.e. debug_annotations is NOT filtered out by default)
  // When true, any debug annotations provided as arguments to the
  // TRACE_EVENT macros are not written into the trace. Typed arguments will
  // still be emitted even if set to true.
  optional bool filter_debug_annotations = 7;

  // Default : false (i.e. disabled)
  // When true, the SDK samples and emits the current thread time counter value
  // for each event on the current thread's track. This value represents the
  // total CPU time consumed by that thread since its creation. Note that if a
  // thread is not scheduled by OS for some duration, that time won't be
  // included in thread_time.
  // Learn more : "CLOCK_THREAD_CPUTIME_ID" flag at
  // https://linux.die.net/man/3/clock_gettime
  optional bool enable_thread_time_sampling = 8;

  // Default: false (i.e. dynamic event names are NOT filtered out by default)
  // When true, event_names wrapped in perfetto::DynamicString will be filtered
  // out.
  optional bool filter_dynamic_event_names = 9;
}

// End of protos/perfetto/config/track_event/track_event_config.proto

// Begin of protos/perfetto/config/data_source_config.proto

// The configuration that is passed to each data source when starting tracing.
// Next id: 138
message DataSourceConfig {
  enum SessionInitiator {
    SESSION_INITIATOR_UNSPECIFIED = 0;
    // This trace was initiated from a trusted system app has DUMP and
    // USAGE_STATS permission. This system app is expected to not expose the
    // trace to the user of the device.
    // This is determined by checking the UID initiating the trace.
    SESSION_INITIATOR_TRUSTED_SYSTEM = 1;
  };
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // If true, |trace_duration_ms| should count also time in suspend. This
  // is propagated from TraceConfig.prefer_suspend_clock_for_duration.
  optional bool prefer_suspend_clock_for_duration = 122;

  // Set by the service to indicate how long it waits after StopDataSource.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 stop_timeout_ms = 7;

  // Set by the service to indicate whether this tracing session has extra
  // guardrails.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional bool enable_extra_guardrails = 6;

  // Set by the service to indicate which user initiated this trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional SessionInitiator session_initiator = 8;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint64 tracing_session_id = 4;

  enum BufferExhaustedPolicy {
    // The data source will use its default buffer exhausted policy, specified
    // by the code when the data source is registered.
    BUFFER_EXHAUSTED_UNSPECIFIED = 0;
    // The data source will drop packets when there's no space in the shared
    // memory buffer.
    BUFFER_EXHAUSTED_DROP = 1;
    // The data source will wait when there's no space in the shared memory
    // buffer. If there's still not space, after a few seconds, the whole
    // producer process will be aborted.
    BUFFER_EXHAUSTED_STALL_THEN_ABORT = 2;
    // The data source will wait when there's no space in the shared memory
    // buffer.  If there's still not space, after a few seconds, the data source
    // will drop packets.
    BUFFER_EXHAUSTED_STALL_THEN_DROP = 3;
  };
  // How to behave when the producer runs out of space in the shared memory
  // buffer. This is only honored by some data sources (in the SDK, the data
  // sources registered with a configurable buffer exhausted policy).
  optional BufferExhaustedPolicy buffer_exhausted_policy = 9;

  // Keep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  // All data source config fields must be marked as [lazy=true]. This prevents
  // the proto-to-cpp generator from recursing into those when generating the
  // cpp classes and polluting tracing/core with data-source-specific classes.
  // Instead they are treated as opaque strings containing raw proto bytes.

  // Data source name: linux.ftrace
  optional FtraceConfig ftrace_config = 100 [lazy = true];
  // Data source name: linux.inode_file_map
  optional InodeFileConfig inode_file_config = 102 [lazy = true];
  // Data source name: linux.process_stats
  optional ProcessStatsConfig process_stats_config = 103 [lazy = true];
  // Data source name: linux.sys_stats
  optional SysStatsConfig sys_stats_config = 104 [lazy = true];
  // Data source name: android.heapprofd
  // Introduced in Android 10.
  optional HeapprofdConfig heapprofd_config = 105 [lazy = true];
  // Data source name: android.java_hprof
  // Introduced in Android 11.
  optional JavaHprofConfig java_hprof_config = 110 [lazy = true];
  // Data source name: android.power
  optional AndroidPowerConfig android_power_config = 106 [lazy = true];
  // Data source name: android.log
  optional AndroidLogConfig android_log_config = 107 [lazy = true];
  // Data source name: gpu.counters
  optional GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  // Data source name: android.game_interventions
  optional AndroidGameInterventionListConfig
      android_game_intervention_list_config = 116 [lazy = true];
  // Data source name: android.packages_list
  optional PackagesListConfig packages_list_config = 109 [lazy = true];
  // Data source name: linux.perf
  optional PerfEventConfig perf_event_config = 111 [lazy = true];
  // Data source name: vulkan.memory_tracker
  optional VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];
  // Data source name: track_event
  optional TrackEventConfig track_event_config = 113 [lazy = true];
  // Data source name: android.polled_state
  optional AndroidPolledStateConfig android_polled_state_config = 114
      [lazy = true];
  // Data source name: android.system_property
  optional AndroidSystemPropertyConfig android_system_property_config = 118
      [lazy = true];
  // Data source name: android.statsd
  optional StatsdTracingConfig statsd_tracing_config = 117 [lazy = true];
  // Data source name: linux.system_info
  optional SystemInfoConfig system_info_config = 119;
  // Data source name: linux.frozen_ftrace
  optional FrozenFtraceConfig frozen_ftrace_config = 136 [lazy = true];

  // Chrome is special as it doesn't use the perfetto IPC layer. We want to
  // avoid proto serialization and de-serialization there because that would
  // just add extra hops on top of the Mojo ser/des. Instead we auto-generate a
  // C++ class for it so it can pass around plain C++ objets.
  optional ChromeConfig chrome_config = 101;

  // Data source name: code.v8.dev
  optional V8Config v8_config = 127 [lazy = true];

  // If an interceptor is specified here, packets for this data source will be
  // rerouted to the interceptor instead of the main trace buffer. This can be
  // used, for example, to write trace data into ETW or for logging trace points
  // to the console.
  //
  // Note that interceptors are only supported by data sources registered
  // through the Perfetto SDK API. Data sources that don't use that API (e.g.,
  // traced_probes) may not support interception.
  optional InterceptorConfig interceptor_config = 115;

  // Data source name: android.network_packets.
  // Introduced in Android 14 (U).
  optional NetworkPacketTraceConfig network_packet_trace_config = 120
      [lazy = true];

  // Data source name: android.surfaceflinger.layers
  optional SurfaceFlingerLayersConfig surfaceflinger_layers_config = 121
      [lazy = true];

  // Data source name: android.surfaceflinger.transactions
  optional SurfaceFlingerTransactionsConfig surfaceflinger_transactions_config =
      123 [lazy = true];

  // Data source name: android.sdk_sysprop_guard
  // Introduced in Android 14 (U) QPR1.
  optional AndroidSdkSyspropGuardConfig android_sdk_sysprop_guard_config = 124
      [lazy = true];

  // Data source name: windows.etw
  optional EtwConfig etw_config = 125 [lazy = true];

  // Data source name: android.protolog
  optional ProtoLogConfig protolog_config = 126 [lazy = true];

  // Data source name: android.input.inputevent
  optional AndroidInputEventConfig android_input_event_config = 128
      [lazy = true];

  // Data source name: android.pixel.modem
  optional PixelModemConfig pixel_modem_config = 129 [lazy = true];

  // Data source name: android.windowmanager
  optional WindowManagerConfig windowmanager_config = 130 [lazy = true];

  // Data source name: org.chromium.system_metrics
  optional ChromiumSystemMetricsConfig chromium_system_metrics = 131
      [lazy = true];

  // Data source name: android.kernel_wakelocks
  optional KernelWakelocksConfig kernel_wakelocks_config = 132 [lazy = true];

  // Data source name: gpu.renderstages
  optional GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];

  // Data source name: org.chromium.histogram_samples
  optional ChromiumHistogramSamplesConfig chromium_histogram_samples = 134
      [lazy = true];

  // Data source name: android.app_wakelocks
  optional AppWakelocksConfig app_wakelocks_config = 135 [lazy = true];

  // Data source name: android.cpu_per_uid
  optional CpuPerUidConfig cpu_per_uid_config = 137 [lazy = true];

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing = 1001;

  // Was |for_testing|. Caused more problems then found.
  reserved 268435455;
}

// End of protos/perfetto/config/data_source_config.proto

// Begin of protos/perfetto/config/trace_config.proto

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 40.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    // |page_size|, now deprecated.
    reserved 2;

    // |optimize_for|, now deprecated.
    reserved 3;

    enum FillPolicy {
      UNSPECIFIED = 0;

      // Default behavior. The buffer operates as a conventional ring buffer.
      // If the writer is faster than the reader (or if the reader reads only
      // after tracing is stopped) newly written packets will overwrite old
      // packets.
      RING_BUFFER = 1;

      // Behaves like RING_BUFFER as long as there is space in the buffer or
      // the reader catches up with the writer. As soon as the writer hits
      // an unread chunk, it stops accepting new data in the buffer.
      DISCARD = 2;
    }
    optional FillPolicy fill_policy = 4;

    // When true the buffer is moved (rather than copied) onto the cloned
    // session, and an empty buffer of the same size is allocated in the source
    // tracing session. This feature will likely get deprecated in the future.
    // It been introduced mainly to support the surfaceflinger snapshot dump
    // for bugreports, where SF can dumps O(400MB) into the bugreport trace. In
    // that case we don't want to retain another in-memory copy of the buffer.
    optional bool transfer_on_clone = 5;

    // Used in conjunction with transfer_on_clone. When true the buffer is
    // cleared before issuing the Flush(reason=kTraceClone). This is to ensure
    // that if the data source took too long to write the data in a previous
    // clone-related flush, we don't end up with a mixture of leftovers from
    // the previous write and new data.
    optional bool clear_before_clone = 6;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional protos.DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and either |producer_name_filter| or |producer_name_regex_filter| is set,
    // the data source is enabled only for producers whose names match any of
    // the filters.
    // |producer_name_filter| has to be an exact match, while
    // |producer_name_regex_filter| is a regular expression.
    // This allows to enable a data source only for specific processes.
    // The "repeated" fields have OR semantics: specifying a filter ["foo",
    // "bar"] will enable data sources on both "foo" and "bar" (if they exist).
    repeated string producer_name_filter = 2;
    repeated string producer_name_regex_filter = 3;
  }
  repeated DataSource data_sources = 2;

  // Config for disabling builtin data sources in the tracing service.
  message BuiltinDataSource {
    // Disable emitting clock timestamps into the trace.
    optional bool disable_clock_snapshotting = 1;

    // Disable echoing the original trace config in the trace.
    optional bool disable_trace_config = 2;

    // Disable emitting system info (build fingerprint, cpuinfo, etc).
    optional bool disable_system_info = 3;

    // Disable emitting events for data-source state changes (e.g. the marker
    // for all data sources having ACKed the start of the trace).
    optional bool disable_service_events = 4;

    // The authoritative clock domain for the trace. Defaults to BOOTTIME. See
    // also ClockSnapshot's primary_trace_clock. The configured value is written
    // into the trace as part of the ClockSnapshots emitted by the service.
    // Trace processor will attempt to translate packet/event timestamps from
    // various data sources (and their chosen clock domains) to this domain
    // during import. Added in Android R.
    optional BuiltinClock primary_trace_clock = 5;

    // Time interval in between snapshotting of sync markers, clock snapshots,
    // stats, and other periodic service-emitted events. Note that the service
    // only keeps track of the first and the most recent snapshot until
    // ReadBuffers() is called.
    optional uint32 snapshot_interval_ms = 6;

    // Hints to the service that a suspend-aware (i.e. counting time in suspend)
    // clock should be used for periodic snapshots of service-emitted events.
    // This means, if a snapshot *should* have happened during suspend, it will
    // happen immediately after the device resumes.
    //
    // Choosing a clock like this is done on best-effort basis; not all
    // platforms (e.g. Windows) expose a clock which can be used for periodic
    // tasks counting suspend. If such a clock is not available, the service
    // falls back to the best-available alternative.
    //
    // Introduced in Android S.
    // TODO(lalitm): deprecate this in T and make this the default if nothing
    // crashes in S.
    optional bool prefer_suspend_clock_for_snapshot = 7;

    // Disables the reporting of per-trace-writer histograms in TraceStats.
    optional bool disable_chunk_usage_histograms = 8;
  }
  optional BuiltinDataSource builtin_data_sources = 20;

  // If specified, the trace will be stopped |duration_ms| after starting.
  // This does *not* count the time the system is suspended, so we will run
  // for duration_ms of system activity, not wall time.
  //
  // However in case of traces with triggers, see
  // TriggerConfig.trigger_timeout_ms instead.
  optional uint32 duration_ms = 3;

  // If true, tries to use CLOCK_BOOTTIME for duration_ms rather than
  // CLOCK_MONOTONIC (which doesn't count time in suspend). Supported only on
  // Linux/Android, no-op on other platforms. This is used when dealing with
  // long (e.g. 24h) traces, where suspend can inflate them to weeks of
  // wall-time, making them more likely to hit device reboots (and hence loss).
  // This option also changes consistently the semantic of
  // TriggerConfig.stop_delay_ms.
  optional bool prefer_suspend_clock_for_duration = 36;

  // This is set when --dropbox is passed to the Perfetto command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
    // The identifier of the subscription which triggered this trace.
    optional int64 triggering_subscription_id = 4;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true && |output_path| is empty, the EnableTracing() request must
  // provide a file descriptor. The service will then periodically read packets
  // out of the trace buffer and store it into the passed file.
  // If |output_path| is not empty no fd should be passed, the service
  // will create a new file and write into that (see comment below).
  optional bool write_into_file = 8;

  // This must point to a non-existing file. If the file exists the service
  // will NOT overwrite and will fail instead as a security precaution.
  // On Android, when this is used with the system traced, the path must be
  // within /data/misc/perfetto-traces/ or the trace will fail.
  // This option has been introduced in Android R. Before R write_into_file
  // can be used only with the "pass a file descriptor over IPC" mode.
  optional string output_path = 29;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // Perfetto.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    // On R-, this override only affected userdebug builds. Since S, it also
    // affects user builds.
    // In 24Q3+ (V+), this override is a noop because upload guardrail logic
    // was removed from Perfetto.
    optional uint64 max_upload_per_day_bytes = 1 [deprecated = true];

    // Overrides the guardrail for maximum trace buffer size.
    // Available on U+
    optional uint32 max_tracing_buffer_size_kb = 2;
  }
  optional GuardrailOverrides guardrail_overrides = 11;

  // When true, data sources are not started until an explicit call to
  // StartTracing() on the consumer port. This is to support early
  // initialization and fast trace triggering. This can be used only when the
  // Consumer explicitly triggers the StartTracing() method.
  // This should not be used in a remote trace config via statsd, doing so will
  // result in a hung trace session.
  optional bool deferred_start = 12;

  // When set, it periodically issues a Flush() to all data source, forcing them
  // to commit their data into the tracing service. This can be used for
  // quasi-real-time streaming mode and to guarantee some partial ordering of
  // events in the trace in windows of X ms.
  optional uint32 flush_period_ms = 13;

  // Wait for this long for producers to acknowledge flush requests.
  // Default 5s.
  optional uint32 flush_timeout_ms = 14;

  // Wait for this long for producers to acknowledge stop requests.
  // Default 5s.
  optional uint32 data_source_stop_timeout_ms = 23;

  // |disable_clock_snapshotting| moved.
  reserved 15;

  // Android-only. If set, sends an intent to the Traceur system app when the
  // trace ends to notify it about the trace readiness.
  optional bool notify_traceur = 16;

  // This field was introduced in Android S.
  // Android-only. If set to a value > 0, marks the trace session as a candidate
  // for being attached to a bugreport. This field effectively acts as a z-index
  // for bugreports. When Android's dumpstate runs perfetto
  // --save-for-bugreport, traced will pick the tracing session with the highest
  // score (score <= 0 is ignored) and:
  // On Android S, T:  will steal its contents, save the trace into
  //     a known path and stop prematurely.
  // On Android U+: will create a read-only snapshot and save that into a known
  //     path, without stoppin the original tracing session.
  // When this field is set the tracing session becomes eligible to be cloned
  // by other UIDs.
  optional int32 bugreport_score = 30;

  // When set, defines name of the file that will be saved under
  // /data/misc/perfetto-traces/bugreport/ when using --save-all-for-bugreport.
  // If omitted, traces will be named systrace.pftrace, systrace_1.pftrace, etc,
  // starting from the highest `bugreport_score`.
  // Introduced in v42 / Android V.
  optional string bugreport_filename = 38;

  // Triggers allow producers to start or stop the tracing session when an event
  // occurs.
  //
  // For example if we are tracing probabilistically, most traces will be
  // uninteresting. Triggers allow us to keep only the interesting ones such as
  // those traces during which the device temperature reached a certain
  // threshold. In this case the producer can activate a trigger to keep
  // (STOP_TRACING) the trace, otherwise it can also begin a trace
  // (START_TRACING) because it knows something is about to happen.
  message TriggerConfig {
    enum TriggerMode {
      UNSPECIFIED = 0;

      // When this mode is chosen, data sources are not started until one of the
      // |triggers| are received. This supports early initialization and fast
      // starting of the tracing system. On triggering, the session will then
      // record for |stop_delay_ms|. However if no trigger is seen
      // after |trigger_timeout_ms| the session will be stopped and no data will
      // be returned.
      START_TRACING = 1;

      // When this mode is chosen, the session will be started via the normal
      // EnableTracing() & StartTracing(). If no trigger is ever seen
      // the session will be stopped after |trigger_timeout_ms| and no data will
      // be returned. However if triggered the trace will stop after
      // |stop_delay_ms| and any data in the buffer will be returned to the
      // consumer.
      STOP_TRACING = 2;

      // 3 was taken by CLONE_SNAPSHOT but that has been moved to 4.
      // The early implementation of CLONE_SNAPSHOT had various bugs
      // (b/290798988, b/290799105) and made it into Android U. The number
      // change is to make sure nobody rolls out a config that hits the broken
      // behaviour.
      reserved 3;

      // When this mode is chosen, this causes a snapshot of the current tracing
      // session to be created after |stop_delay_ms| while the current tracing
      // session continues undisturbed (% an extra flush). This mode can be
      // used only when the tracing session is handled by the "perfetto" cmdline
      // client (which is true in 90% of cases). Part of the business logic
      // necessary for this behavior, and ensuing file handling, lives in
      // perfetto_cmd.cc . On other consumers, this causes only a notification
      // of the trigger through a CloneTriggerHit ObservableEvent. The custom
      // consumer is supposed to call CloneSession() itself after the event.
      // Use use_clone_snapshot_if_available=true when targeting older versions
      // of perfetto.
      CLONE_SNAPSHOT = 4;

      // NOTE: CLONE_SNAPSHOT should be used only when we targeting Android V+
      // (15+) / Perfetto v38+. A bug in older versions of the tracing service
      // might cause indefinitely long tracing sessions (see b/274931668).
    }
    optional TriggerMode trigger_mode = 1;

    // This flag is really a workaround for b/274931668. This is needed only
    // when deploying configs to different versions of the tracing service.
    // When this is set to true this has the same effect of setting trigger_mode
    // to CLONE_SNAPSHOT on newer versions of the service. This boolean has been
    // introduced to allow to have configs that use CLONE_SNAPSHOT on newer
    // versions of Android and fall back to STOP_TRACING on older versions where
    // CLONE_SNAPSHOT did not exist.
    // When using this flag, trigger_mode must be set to STOP_TRACING.
    optional bool use_clone_snapshot_if_available = 5;

    // DEPRECATED, was use_clone_snapshot_if_available in U. See the comment
    // around CLONE_SNAPSHOT.
    reserved 4;

    message Trigger {
      // The producer must specify this name to activate the trigger.
      optional string name = 1;

      // An std::regex that will match the producer that can activate this
      // trigger. This is optional. If unset any producers can activate this
      // trigger.
      optional string producer_name_regex = 2;

      // After a trigger is received either in START_TRACING or STOP_TRACING
      // mode then the trace will end |stop_delay_ms| after triggering.
      // In CLONE_SNAPSHOT mode, this is the delay between the trigger and the
      // snapshot.
      // If |prefer_suspend_clock_for_duration| is set, the duration will be
      // based on wall-clock, counting also time in suspend.
      optional uint32 stop_delay_ms = 3;

      // Limits the number of traces this trigger can start/stop in a rolling
      // 24 hour window. If this field is unset or zero, no limit is applied and
      // activiation of this trigger *always* starts/stops the trace.
      optional uint32 max_per_24_h = 4;

      // A value between 0 and 1 which encodes the probability of skipping a
      // trigger with this name. This is useful for reducing the probability
      // of high-frequency triggers from dominating trace finaization. If this
      // field is unset or zero, the trigger will *never* be skipped. If this
      // field is greater than or equal to 1, this trigger will *always* be
      // skipped i.e. it will be as if this trigger was never included in the
      // first place.
      // This probability check is applied *before* any other limits. For
      // example, if |max_per_24_h| is also set, first we will check if the
      // probability bar is met and only then will we check the |max_per_24_h|
      // limit.
      optional double skip_probability = 5;
    }
    // A list of triggers which are related to this configuration. If ANY
    // trigger is seen then an action will be performed based on |trigger_mode|.
    repeated Trigger triggers = 2;

    // Required and must be positive if a TriggerConfig is specified. This is
    // how long this TraceConfig should wait for a trigger to arrive. After this
    // period of time if no trigger is seen the TracingSession will be cleaned
    // up.
    optional uint32 trigger_timeout_ms = 3;
  }
  optional TriggerConfig trigger_config = 17;

  // When this is non-empty the perfetto command line tool will ignore the rest
  // of this TraceConfig and instead connect to the perfetto service as a
  // producer and send these triggers, potentially stopping or starting traces
  // that were previous configured to use a TriggerConfig.
  repeated string activate_triggers = 18;

  // Configuration for trace contents that reference earlier trace data. For
  // example, a data source might intern strings, and emit packets containing
  // {interned id : string} pairs. Future packets from that data source can then
  // use the interned ids instead of duplicating the raw string contents. The
  // trace parser will then need to use that interning table to fully interpret
  // the rest of the trace.
  message IncrementalStateConfig {
    // If nonzero, notify eligible data sources to clear their incremental state
    // periodically, with the given period. The notification is sent only to
    // data sources that have |handles_incremental_state_clear| set in their
    // DataSourceDescriptor. The notification requests that the data source
    // stops referring to past trace contents. This is particularly useful when
    // tracing in ring buffer mode, where it is not exceptional to overwrite old
    // trace data.
    //
    // Warning: this time-based global clearing is likely to be removed in the
    // future, to be replaced with a smarter way of sending the notifications
    // only when necessary.
    optional uint32 clear_period_ms = 1;
  }
  optional IncrementalStateConfig incremental_state_config = 21;

  // No longer needed as we unconditionally allow tracing on user builds.
  optional bool allow_user_build_tracing = 19 [deprecated = true];

  // If set the tracing service will ensure there is at most one tracing session
  // with this key.
  optional string unique_session_name = 22;

  // Compress trace with the given method. Best effort.
  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0;
    COMPRESSION_TYPE_DEFLATE = 1;
  }
  optional CompressionType compression_type = 24;

  // DEPRECATED, was compress_from_cli.
  reserved 37;

  // Android-only. Not for general use. If set, saves the trace into an
  // incident. This field is read by perfetto_cmd, rather than the tracing
  // service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message IncidentReportConfig {
    // In this message, either:
    //  * all of |destination_package|, |destination_class| and |privacy_level|
    //    must be set.
    //  * |skip_incidentd| must be explicitly set to true.

    optional string destination_package = 1;
    optional string destination_class = 2;
    // Level of filtering in the requested incident. See |Destination| in
    // frameworks/base/core/proto/android/privacy.proto.
    optional int32 privacy_level = 3;

    // If true, then skips saving the trace to incidentd.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want traces to go to incidentd even when they
    // usually would (e.g. configs deployed using statsd but only used for
    // inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |incident_report_config|, is prevent accidents where
    // |incident_report_config| is omitted by mistake.
    optional bool skip_incidentd = 5;

    // If true, do not write the trace into dropbox (i.e. incident only).
    // Otherwise, write to both dropbox and incident.
    // TODO(lalitm): remove this field as we no longer use Dropbox.
    optional bool skip_dropbox = 4 [deprecated = true];
  }
  optional IncidentReportConfig incident_report_config = 25;

  enum StatsdLogging {
    STATSD_LOGGING_UNSPECIFIED = 0;
    STATSD_LOGGING_ENABLED = 1;
    STATSD_LOGGING_DISABLED = 2;
  }

  // Android-only. Not for general use. If specified, sets the logging to statsd
  // of guardrails and checkpoints in the tracing service. perfetto_cmd sets
  // this to enabled (if not explicitly set in the config) when specifying
  // --upload.
  optional StatsdLogging statsd_logging = 31;

  // DEPRECATED. Was trace_uuid, use trace_uuid_msb and trace_uuid_lsb instead.
  reserved 26;

  // An identifier clients can use to tie this trace to other logging.
  // DEPRECATED as per v32. See TracePacket.trace_uuid for the authoritative
  // Trace UUID. If this field is set, the tracing service will respect the
  // requested UUID (i.e. TracePacket.trace_uuid == this field) but only if
  // gap-less snapshotting is not used.
  optional int64 trace_uuid_msb = 27 [deprecated = true];
  optional int64 trace_uuid_lsb = 28 [deprecated = true];

  // When set applies a post-filter to the trace contents using the filter
  // provided. The filter is applied at ReadBuffers() time and works both in the
  // case of IPC readback and write_into_file. This filter can be generated
  // using `tools/proto_filter -s schema.proto -F filter_out.bytes` or
  // `-T filter_out.escaped_string` (for .pbtx). See go/trace-filtering for
  // design.
  //
  // Introduced in Android S, but it was broken (b/195065199). Reintroduced in
  // Android T with a different field number. Updated in Android U with a new
  // bytecode version which supports string filtering.
  message TraceFilter {
    // =========================
    // Filter bytecode.
    // =========================

    // The bytecode as implemented in Android T.
    optional bytes bytecode = 1;

    // The bytecode as implemented in Android U. Adds support for string
    // filtering.
    optional bytes bytecode_v2 = 2;

    // =========================
    // String filtering
    // =========================

    // The principles and terminology of string filtering is heavily inspired by
    // iptables. A "rule" decide how strings should be filtered. Each rule
    // contains a "policy" which indicates the algorithm to use for filtering.
    // A "chain" is a list of rules which will be sequentially checked against
    // each string.
    //
    // The first rule which applies to the string terminates filtering for that
    // string. If no rules apply, the string is left unchanged.

    // A policy specifies which algorithm should be used for filtering the
    // string.
    enum StringFilterPolicy {
      SFP_UNSPECIFIED = 0;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, all matching groups are "redacted" (i.e. replaced with a
      // constant string) and filtering is terminated (i.e. no further rules are
      // checked). If it doesn't match, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_MATCH_REDACT_GROUPS = 1;

      // Like |SFP_MATCH_REDACT_GROUPS| but tries to do some pre-work before
      // checking the regex. Specifically, it tries to parse the string field as
      // an atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_REDACT_GROUPS = 2;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, filtering is terminated (i.e. no further rules are checked).
      // If it doesn't match, the string is left unchanged and the next rule in
      // chain is considered.
      SFP_MATCH_BREAK = 3;

      // Like |SFP_MATCH_BREAK| but tries to do some pre-work before checking
      // the regex. Specifically, it tries to parse the string field as an
      // atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_BREAK = 4;

      // Tries to repeatedly search (i.e. find substrings of) the string field
      // with |regex_pattern|. For each match, redacts any matching groups (i.e.
      // replaced with a constant string). Once there are no further matches,
      // filtering is terminated (i.e. no further rules are checked).
      //
      // Note that this is policy is a "search" policy not a "match" policy
      // unlike the above policies:
      //  * Match policies require matching the full string i.e. there is an
      //    implicit leading `^` and trailing `$`.
      //  * Search policies perform repeated partial matching of the string
      //    e.g.
      //      - String: `foo=aaa,bar=123,foo=bbb,baz=456`
      //      - Pattern: `foo=(\d+)`
      //      - Output: `foo=P6O,bar=123,foo=P6O,baz=456`
      //    where P6O is the redaction string
      //
      // All of this is only performed after some pre-work where we try to parse
      // the string field as an atrace tracepoint and check if the post-tgid
      // field starts with |atrace_post_tgid_starts_with|.
      //
      // If there are no partial matches, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS = 5;
    }

    // A rule specifies how strings should be filtered.
    message StringFilterRule {
      // The policy (i.e. algorithm) dictating how strings matching this rule
      // should be handled.
      optional StringFilterPolicy policy = 1;

      // The regex pattern used to match against each string.
      optional string regex_pattern = 2;

      // The string which should appear after the tgid in atrace tracepoint
      // strings.
      optional string atrace_payload_starts_with = 3;
    }

    // A chain is a list of rules which string will be sequentially checked
    // against.
    message StringFilterChain {
      repeated StringFilterRule rules = 1;
    }
    optional StringFilterChain string_filter_chain = 3;
  }
  // old field number for trace_filter
  reserved 32;
  optional TraceFilter trace_filter = 33;

  // Android-only. Not for general use. If set, reports the trace to the
  // Android framework. This field is read by perfetto_cmd, rather than the
  // tracing service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message AndroidReportConfig {
    // In this message, either:
    //  * |reporter_service_package| and |reporter_service_class| must be set.
    //  * |skip_reporting| must be explicitly set to true.

    optional string reporter_service_package = 1;
    optional string reporter_service_class = 2;

    // If true, then skips reporting the trace to Android framework.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want to report traces to the framework even
    // when they usually would (e.g. configs deployed using statsd but only
    // used for inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |framework_report_config|, is prevent accidents where
    // |framework_report_config| is omitted by mistake.
    optional bool skip_report = 3;

    // If true, will direct the Android framework to read the data in trace
    // file and pass it to the reporter class over a pipe instead of passing
    // the file descriptor directly.
    //
    // This flag is needed because the Android test framework does not
    // currently support priv-app helper apps (in terms of SELinux) and we
    // really don't want to add an allow rule for untrusted_app to receive
    // trace fds.
    //
    // Because of this, we instead will direct the framework to create a new
    // pipe and pass this to the reporter process instead. As the pipe is
    // created by the framework, we won't have any problems with SELinux
    // (system_server is already allowed to pass pipe fds, even
    // to untrusted apps).
    //
    // As the name suggests this option *MUST* only be used for testing.
    // Note that the framework will reject (and drop) files which are too
    // large both for simplicity and to be minimize the amount of data we
    // pass to a non-priv app (note that the framework will still check
    // manifest permissions even though SELinux permissions are worked around).
    optional bool use_pipe_in_framework_for_testing = 4;
  }
  optional AndroidReportConfig android_report_config = 34;

  // If set, delays the start of tracing by a random duration. The duration is
  // chosen from a uniform distribution between the specified minimum and
  // maximum.
  // Note: this delay is implemented by perfetto_cmd *not* by traced so will
  // not work if you communicate with traced directly over the consumer API.
  // Introduced in Android T.
  message CmdTraceStartDelay {
    optional uint32 min_delay_ms = 1;
    optional uint32 max_delay_ms = 2;
  }
  optional CmdTraceStartDelay cmd_trace_start_delay = 35;

  // When non-empty, ensures that for a each semaphore named `name at most
  // `max_other_session_count`` *other* sessions (whose value is taken of the
  // minimum of all values specified by this config or any already-running
  // session) can be be running.
  //
  // If a semaphore "acquisition" fails, EnableTracing will return an error
  // and the tracing session will not be started (or elgible to start in
  // the case of deferred sessions).
  //
  // This is easiest to explain with an example. Suppose the tracing service has
  // the following active tracing sessions:
  //   S1 = [{name=foo, max_other_session_count=2},
  //         {name=bar, max_other_session_count=0}]
  //   S2 = [{name=foo, max_other_session_count=1},
  //         {name=baz, max_other_session_count=1}]
  //
  // Then, for a new session, the following would be the expected behaviour of
  // EnableSession given the state of `session_semaphores`.
  //   Q: session_semaphores = []
  //   A: Allowed because it does not specify any semaphores. Will be allowed
  //      no matter the state of any other tracing session.
  //   Q: session_semaphores = [{name=baz, max_other_session_count=1}]
  //   A: Allowed because both S2 and this config specify
  //      max_other_session_count=1 for baz.
  //   Q: session_semaphores = [{name=foo, max_other_session_count=3}]
  //   A: Denied because S2 specified max_other_session_count=1 for foo and S1
  //      takes that slot.
  //   Q: session_semaphores = [{name=bar, max_other_session_count=0}]
  //   A: Denied because S1 takes the the slot specified by both S1 and
  //      this config.
  //
  // Introduced in 24Q3 (Android V).
  message SessionSemaphore {
    // The name of the semaphore. Acts as a unique identifier across all
    // tracing sessions (including the one being started).
    optional string name = 1;

    // The maximum number of *other* sesssions which specify the same semaphore
    // which can be active. The minimum of this value across all tracing
    // sessions and the value specified by the config is used when deciding
    // whether the tracing session can be started.
    optional uint64 max_other_session_count = 2;
  }
  repeated SessionSemaphore session_semaphores = 39;
}

// End of protos/perfetto/config/trace_config.proto
