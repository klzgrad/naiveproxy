// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

option go_package = "github.com/google/perfetto/perfetto_proto";

// Begin of protos/perfetto/common/ftrace_descriptor.proto

message FtraceDescriptor {
  message AtraceCategory {
    optional string name = 1;
    optional string description = 2;
  }

  // Report the available atrace categories.
  //
  // Used by Traceur via `perfetto --query`.
  repeated AtraceCategory atrace_categories = 1;
}

// End of protos/perfetto/common/ftrace_descriptor.proto

// Begin of protos/perfetto/common/gpu_counter_descriptor.proto

// Description of GPU counters.
// This message is sent by a GPU counter producer to specify the counters
// available in the hardware.
message GpuCounterDescriptor {
  // Logical groups for a counter.  This is used in the UI to present the
  // related counters together.
  enum GpuCounterGroup {
    UNCLASSIFIED = 0;
    SYSTEM = 1;
    VERTICES = 2;
    FRAGMENTS = 3;
    PRIMITIVES = 4;
    // Includes counters relating to caching and bandwidth.
    MEMORY = 5;
    COMPUTE = 6;
    RAY_TRACING = 7;
  }

  message GpuCounterSpec {
    optional uint32 counter_id = 1;
    optional string name = 2;
    optional string description = 3;
    // MeasureUnit unit (deprecated)
    reserved 4;
    oneof peak_value {
      int64 int_peak_value = 5;
      double double_peak_value = 6;
    }
    repeated MeasureUnit numerator_units = 7;
    repeated MeasureUnit denominator_units = 8;
    optional bool select_by_default = 9;
    repeated GpuCounterGroup groups = 10;
  }
  repeated GpuCounterSpec specs = 1;

  // Allow producer to group counters into block to represent counter islands.
  // A capacity may be specified to indicate the number of counters that can be
  // enable simultaneously in that block.
  message GpuCounterBlock {
    // required. Unique ID for the counter group.
    optional uint32 block_id = 1;
    // optional. Number of counters supported by the block. No limit if unset.
    optional uint32 block_capacity = 2;
    // optional. Name of block.
    optional string name = 3;
    // optional. Description for the block.
    optional string description = 4;
    // list of counters that are part of the block.
    repeated uint32 counter_ids = 5;
  }
  repeated GpuCounterBlock blocks = 2;

  // optional.  Minimum sampling period supported by the producer in
  // nanoseconds.
  optional uint64 min_sampling_period_ns = 3;

  // optional.  Maximum sampling period supported by the producer in
  // nanoseconds.
  optional uint64 max_sampling_period_ns = 4;

  // optional.  The producer supports counter sampling by instrumenting the
  // command buffer.
  optional bool supports_instrumented_sampling = 5;

  // next id: 41
  enum MeasureUnit {
    NONE = 0;

    BIT = 1;
    KILOBIT = 2;
    MEGABIT = 3;
    GIGABIT = 4;
    TERABIT = 5;
    PETABIT = 6;

    BYTE = 7;
    KILOBYTE = 8;
    MEGABYTE = 9;
    GIGABYTE = 10;
    TERABYTE = 11;
    PETABYTE = 12;

    HERTZ = 13;
    KILOHERTZ = 14;
    MEGAHERTZ = 15;
    GIGAHERTZ = 16;
    TERAHERTZ = 17;
    PETAHERTZ = 18;

    NANOSECOND = 19;
    MICROSECOND = 20;
    MILLISECOND = 21;
    SECOND = 22;
    MINUTE = 23;
    HOUR = 24;

    VERTEX = 25;
    PIXEL = 26;
    TRIANGLE = 27;
    PRIMITIVE = 38;
    FRAGMENT = 39;

    MILLIWATT = 28;
    WATT = 29;
    KILOWATT = 30;

    JOULE = 31;
    VOLT = 32;
    AMPERE = 33;

    CELSIUS = 34;
    FAHRENHEIT = 35;
    KELVIN = 36;

    // Values should be out of 100.
    PERCENT = 37;

    INSTRUCTION = 40;
  }
}

// End of protos/perfetto/common/gpu_counter_descriptor.proto

// Begin of protos/perfetto/common/track_event_descriptor.proto

message TrackEventCategory {
  optional string name = 1;
  optional string description = 2;
  repeated string tags = 3;
}

message TrackEventDescriptor {
  repeated TrackEventCategory available_categories = 1;
}

// End of protos/perfetto/common/track_event_descriptor.proto

// Begin of protos/perfetto/common/data_source_descriptor.proto

// This message is sent from Producer(s) to the tracing Service when registering
// to advertise their capabilities. It describes the structure of tracing
// protos that will be produced by the data source and the supported filters.
message DataSourceDescriptor {
  // e.g., "linux.ftrace", "chromium.tracing"
  optional string name = 1;

  // When non-zero, this is a unique ID within the scope of the Producer for
  // this data source (it is NOT globally unique). This is useful to
  // differentiate between data sources with matching names when calling
  // UpdateDataSource(). This field has been introduced in November 2021
  // (v22, Android T) and is not supported on older versions.
  optional uint64 id = 7;

  // When true the data source is expected to ack the stop request through the
  // NotifyDataSourceStopped() IPC. This field has been introduced after
  // Android P in Jul 2018 and is not supported on older versions.
  optional bool will_notify_on_stop = 2;

  // When true the data source is expected to ack the start request through the
  // NotifyDataSourceStarted() IPC. This field has been introduced after
  // Android P in March 2019 and is not supported on older versions.
  optional bool will_notify_on_start = 3;

  // If true, opt into receiving the ClearIncrementalState() IPC. This should be
  // set if the data source writes packets that refer to previous trace
  // contents, and knows how to stop referring to the already-emitted data.
  optional bool handles_incremental_state_clear = 4;

  // If true, indicates that the data source does nothing upon Flush. This
  // allows the service to reduce the flush-related IPC traffic and better deal
  // with frozen producers (see go/perfetto-frozen). This is usually the case
  // for data sources like 'track_event' that don't have access to the various
  // thread task runners to post a flush task and rely purely on server-side
  // scraping.
  // Introduced in v39 / Android V.
  optional bool no_flush = 9;

  // Optional specification about available GPU counters.
  optional GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];

  optional TrackEventDescriptor track_event_descriptor = 6 [lazy = true];

  optional FtraceDescriptor ftrace_descriptor = 8 [lazy = true];
}

// End of protos/perfetto/common/data_source_descriptor.proto

// Begin of protos/perfetto/common/tracing_service_state.proto

// Reports the state of the tracing service. Used to gather details about the
// data sources connected.
// See ConsumerPort::QueryServiceState().
message TracingServiceState {
  // Describes a producer process.
  message Producer {
    // Unique ID of the producer (monotonic counter).
    optional int32 id = 1;

    // Typically matches the process name.
    optional string name = 2;

    // Unix pid of the remote process. Supported only on Linux-based systems.
    // Introduced in v24 / Android T.
    optional int32 pid = 5;

    // Unix uid of the remote process.
    optional int32 uid = 3;

    // The version of the client library used by the producer.
    // This is a human readable string with and its format varies depending on
    // the build system and the repo (standalone vs AOSP).
    // This is intended for human debugging only.
    optional string sdk_version = 4;

    // Returns true if the process appears to be frozen (Android only).
    // Introduced in Perfetto V49 / Android 24Q4.
    optional bool frozen = 6;
  }

  // Describes a data source registered by a producer. Data sources are listed
  // regardless of the fact that they are being used or not.
  message DataSource {
    // Descriptor passed by the data source when calling RegisterDataSource().
    optional DataSourceDescriptor ds_descriptor = 1;

    // ID of the producer, as per Producer.id.
    optional int32 producer_id = 2;
  }

  message TracingSession {
    // The TracingSessionID.
    optional uint64 id = 1;

    // The Unix uid of the consumer that started the session.
    // This is meaningful only if the caller is root. In all other cases only
    // tracing sessions that match the caller UID will be displayed.
    optional int32 consumer_uid = 2;

    // Internal state of the tracing session.
    // These strings are FYI only and subjected to change.
    optional string state = 3;

    // The unique_session_name as set in the trace config (might be empty).
    optional string unique_session_name = 4;

    // The number and size of each buffer.
    repeated uint32 buffer_size_kb = 5;

    // Duration, as specified in the TraceConfig.duration_ms.
    optional uint32 duration_ms = 6;

    // Number of data sources involved in the session.
    optional uint32 num_data_sources = 7;

    // Time when the session was started, in the CLOCK_REALTIME domain.
    // Available only on Linux-based systems.
    optional int64 start_realtime_ns = 8;

    // The fields below have been introduced in v42.

    // The bugreport_score, as set in TraceConfig.bugreport_score.
    optional int32 bugreport_score = 9;

    // As per TraceConfig.bugreport_filename.
    optional string bugreport_filename = 10;

    // If true, the session is in the STARTED state. If false the session is in
    // any other state (see `state` field).
    optional bool is_started = 11;
  }

  // Lists all the producers connected.
  repeated Producer producers = 1;

  // Lists the data sources available.
  repeated DataSource data_sources = 2;

  // Lists the tracing sessions active AND owned by a consumer that has the same
  // UID of the caller (or all of them if the caller is root).
  // Introduced in v24 / Android T.
  repeated TracingSession tracing_sessions = 6;

  // This is always set to true from v24 and beyond. This flag is only used to
  // tell the difference between: (1) talking to a recent service which happens
  // to have no tracing session active; (2) talking to an older version of the
  // service which will never report any tracing session.
  optional bool supports_tracing_sessions = 7;

  // Total number of tracing sessions.
  optional int32 num_sessions = 3;

  // Number of tracing sessions in the started state. Always <= num_sessions.
  optional int32 num_sessions_started = 4;

  // The version of traced (the same returned by `traced --version`).
  // This is a human readable string with and its format varies depending on
  // the build system and the repo (standalone vs AOSP).
  // This is intended for human debugging only.
  optional string tracing_service_version = 5;
}

// End of protos/perfetto/common/tracing_service_state.proto

// Begin of protos/perfetto/common/builtin_clock.proto

enum BuiltinClock {
  BUILTIN_CLOCK_UNKNOWN = 0;
  BUILTIN_CLOCK_REALTIME = 1;
  BUILTIN_CLOCK_REALTIME_COARSE = 2;
  BUILTIN_CLOCK_MONOTONIC = 3;
  BUILTIN_CLOCK_MONOTONIC_COARSE = 4;
  BUILTIN_CLOCK_MONOTONIC_RAW = 5;
  BUILTIN_CLOCK_BOOTTIME = 6;
  BUILTIN_CLOCK_TSC = 9;
  BUILTIN_CLOCK_PERF = 10;
  BUILTIN_CLOCK_MAX_ID = 63;

  reserved 7, 8;
}

// End of protos/perfetto/common/builtin_clock.proto

// Begin of protos/perfetto/config/android/android_game_intervention_list_config.proto

// Data source that lists game modes and game interventions of games
// on an Android device.
message AndroidGameInterventionListConfig {
  // If not empty, emit info about only the following list of package names
  // (exact match, no regex). Otherwise, emit info about all packages.
  repeated string package_name_filter = 1;
}

// End of protos/perfetto/config/android/android_game_intervention_list_config.proto

// Begin of protos/perfetto/config/android/android_input_event_config.proto

// Custom configuration for the "android.input.inputevent" data source.
//
// NOTE: Input traces can only be taken on debuggable (userdebug/eng) builds!
//
// Next ID: 5
message AndroidInputEventConfig {
  // Trace modes are tracing presets that are included in the system.
  enum TraceMode {
    // Preset mode for maximal tracing.
    // WARNING: This will bypass all privacy measures on debuggable builds, and
    // will record all
    //          input events processed by the system, regardless of the context
    //          in which they were processed. It should only be used for tracing
    //          on a local device or for tests. It should NEVER be used for
    //          field tracing.
    TRACE_MODE_TRACE_ALL = 0;
    // Use the tracing rules defined in this config to specify what events to
    // trace.
    TRACE_MODE_USE_RULES = 1;
  }

  // The tracing mode to use. If unspecified, it will default to
  // TRACE_MODE_USE_RULES.
  optional TraceMode mode = 1;

  // The level of tracing that should be applied to an event.
  enum TraceLevel {
    // Do not trace the input event.
    TRACE_LEVEL_NONE = 0;
    // Trace the event as a redacted event, where certain sensitive fields are
    // omitted from the trace, including the coordinates of pointer events and
    // the key/scan codes of key events.
    TRACE_LEVEL_REDACTED = 1;
    // Trace the complete event.
    TRACE_LEVEL_COMPLETE = 2;
  }

  // A rule that specifies the TraceLevel for an event based on matching
  // conditions. All matchers in the rule are optional. To trigger this rule, an
  // event must match all of its specified matchers (i.e. the matchers function
  // like a series of conditions connected by a logical 'AND' operator). A rule
  // with no specified matchers will match all events. Next ID: 6
  message TraceRule {
    // The trace level to be used for events that trigger this rule.
    // If unspecified, TRACE_LEVEL_NONE will be used by default.
    optional TraceLevel trace_level = 1;

    // --- Optional Matchers ---

    // Package matchers
    //
    // Respectively matches if all or any of the target apps for this event are
    // contained in the specified list of package names.
    //
    // Intended usage:
    //   - Use match_all_packages to selectively allow tracing for the listed
    //   packages.
    //   - Use match_any_packages to selectively deny tracing for certain
    //   packages.
    //
    // WARNING: Great care must be taken when designing rules for field tracing!
    //          This is because each event is almost always sent to more than
    //          one app.
    //              For example, when allowing tracing for a package that has a
    //              spy window
    //          over the display (e.g. SystemUI) using match_any_packages,
    //          essentially all input will be recorded on that display. This is
    //          because the events will be sent to the spy as well as the
    //          foreground app, and regardless of what the foreground app is,
    //          the event will end up being traced.
    //              Alternatively, when attempting to block tracing for specific
    //              packages using
    //          match_all_packages, no events will likely be blocked. This is
    //          because the event will also be sent to other apps (such as, but
    //          not limited to, ones with spy windows), so the matcher will not
    //          match unless all other targets are also listed under the
    //          match_all_packages list.
    repeated string match_all_packages = 2;
    repeated string match_any_packages = 3;

    // Matches if the event is secure, which means that at least one of the
    // targets of this event is using the window flag FLAG_SECURE.
    optional bool match_secure = 4;

    // Matches if there was an active IME connection while this event was being
    // processed.
    optional bool match_ime_connection_active = 5;
  }

  // The list of rules to use to determine the trace level of events.
  // Each event will be traced using the TraceLevel of the first rule that it
  // triggers from this list. The rules are evaluated in the order in which they
  // are specified. If an event does not match any of the rules,
  // TRACE_LEVEL_NONE will be used by default.
  repeated TraceRule rules = 2;

  // --- Control flags ---

  // Trace input events processed by the system as they are being dispatched
  // to application windows. All trace rules will apply.
  //   - If this flag is used without enabling trace_dispatcher_window_dispatch,
  //   it will
  //     trace InputDispatcher's inbound events (which does not include events
  //     synthesized within InputDispatcher) that match the rules.
  //   - If used with trace_dispatcher_window_dispatch, all inbound and outbound
  //   events
  //     matching the rules, including all events synthesized within
  //     InputDispatcher, will be traced.
  optional bool trace_dispatcher_input_events = 3;

  // Trace details about which windows the system is sending each input event
  // to. All trace rules will apply.
  optional bool trace_dispatcher_window_dispatch = 4;
}

// End of protos/perfetto/config/android/android_input_event_config.proto

// Begin of protos/perfetto/common/android_log_constants.proto

// Values from NDK's android/log.h.
enum AndroidLogId {
  // MAIN.
  LID_DEFAULT = 0;

  LID_RADIO = 1;
  LID_EVENTS = 2;
  LID_SYSTEM = 3;
  LID_CRASH = 4;
  LID_STATS = 5;
  LID_SECURITY = 6;
  LID_KERNEL = 7;
}

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0;

  // _DEFAULT, but should never be seen in logs.
  PRIO_UNUSED = 1;

  PRIO_VERBOSE = 2;
  PRIO_DEBUG = 3;
  PRIO_INFO = 4;
  PRIO_WARN = 5;
  PRIO_ERROR = 6;
  PRIO_FATAL = 7;
}

// End of protos/perfetto/common/android_log_constants.proto

// Begin of protos/perfetto/config/android/android_log_config.proto

message AndroidLogConfig {
  repeated AndroidLogId log_ids = 1;

  // Was |poll_ms|, deprecated.
  reserved 2;

  // If set ignores all log messages whose prio is < the given value.
  optional AndroidLogPriority min_prio = 3;

  // If non-empty ignores all log messages whose tag doesn't match one of the
  // specified values.
  repeated string filter_tags = 4;
}

// End of protos/perfetto/config/android/android_log_config.proto

// Begin of protos/perfetto/config/android/android_polled_state_config.proto

// Data source that polls for display state. This should only be used for
// backward-compatibility; AndroidSystemPropertyConfig should be preferred.
message AndroidPolledStateConfig {
  // Frequency of polling. If absent the state will be recorded once, at the
  // start of the trace.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/android_polled_state_config.proto

// Begin of protos/perfetto/config/android/android_sdk_sysprop_guard_config.proto

// Data source that controls the system properties used to guard initialization
// of track_event producers (i.e. Skia) in apps using HWUI, and certain
// processes like SurfaceFlinger.
//
// This data source only tells Skia to initialized the Perfetto SDK and start
// routing data to the Track Event system instead of ATrace. For those events
// to actually show up in a trace, the track_event data source must be used as
// well. The Perfetto SDK cannot be de-initialized, so some long-lived apps and
// processes may need to be restarted for Skia to revert to using ATrace if
// Track Events are no longer desired.
//
// In addition to switching Skia to use Perfetto's track_event data source,
// this "guard" also controls Skia's "broad tracing", which removes Skia's
// internal tracing constraints and allows the track_event config to specify
// which categories should be traced. Filtering to the "skia.always" category
// *tag* in a track_event config can be used to re-enable the standard
// constraints typically used with ATrace.
//
// Data source name: android.sdk_sysprop_guard
// Introduced in Android 14 (U) QPR1.
// Next id: 4
message AndroidSdkSyspropGuardConfig {
  // If true, configures SurfaceFlinger to initialize Skia's Perfetto
  // integration with the track_event data source in RenderEngine.
  // If false or omitted, the simpler ATrace fallback is used.
  //
  // NOTE: once enabled, Skia will only revert to ATrace if SurfaceFlinger is
  // restarted.
  //
  // Specifically this sets the following system properties:
  //   - debug.tracing.ctl.renderengine.skia_tracing_enabled
  //   - debug.tracing.ctl.renderengine.skia_use_perfetto_track_events
  //
  // Does not affect actual track_event data *collection*, which must be
  // configured separately.
  optional bool surfaceflinger_skia_track_events = 1;

  // If true, configures HWUI apps to initialize Skia's Perfetto integration
  // with the track_event data source. hwui_package_name_filter
  // can be used to control which apps are affected.
  // If false or omitted, the simpler ATrace fallback is used.
  //
  // NOTE: once enabled, Skia will only revert to ATrace if the app is
  // restarted.
  //
  // ATTENTION: affects ALL HWUI APPS if hwui_package_name_filter is not set!
  // If filtering is NOT set, this controls these GLOBAL system properties:
  //   - debug.tracing.ctl.hwui.skia_tracing_enabled
  //   - debug.tracing.ctl.hwui.skia_use_perfetto_track_events
  // If filtering IS set, this controls these APP-SPECIFIC system properties,
  // for each package listed in the filter:
  //   - debug.tracing.ctl.hwui.skia_tracing_enabled.<package.name>
  //   - debug.tracing.ctl.hwui.skia_use_perfetto_track_events.<package.name>
  //
  // Does not affect actual track_event data *collection*, which must be
  // configured separately.
  optional bool hwui_skia_track_events = 2;

  // If non-empty, hwui_skia_track_events applies to only the packages listed.
  // Otherwise, hwui_skia_track_events applies globally to all HWUI apps.
  repeated string hwui_package_name_filter = 3;
}

// End of protos/perfetto/config/android/android_sdk_sysprop_guard_config.proto

// Begin of protos/perfetto/config/android/android_system_property_config.proto

// Data source that polls for system properties.
message AndroidSystemPropertyConfig {
  // Frequency of polling. If absent the state will be recorded once, at the
  // start of the trace.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 poll_ms = 1;

  // Properties to poll. All property names must start with "debug.tracing.".
  repeated string property_name = 2;
}

// End of protos/perfetto/config/android/android_system_property_config.proto

// Begin of protos/perfetto/config/android/app_wakelock_config.proto

// Configuration for the android.app_wakelocks data source.
message AppWakelocksConfig {
  // Specifies the delay (in milliseconds) after which the data source will
  // attempt to write events. Writing less frequently reduces the trace size by
  // making better use of the packed arrays and reducing the total number of
  // TracePackets needed (which each have dozens of bytes of overhead). The
  // suggested delay is 5000ms.
  optional int32 write_delay_ms = 1;

  // When set, wakelocks held for less than this amount of time are filtered
  // from the resulting trace. Note: duration is computed by matching wakelocks
  // with identical attributes, not by tracking the underlying objects. The
  // threshold should be < the trace's flush_period_ms.
  optional int32 filter_duration_below_ms = 2;

  // When true, the owner_pid is dropped from the resulting output, reducing the
  // size of the interning tables.
  optional bool drop_owner_pid = 3;
}

// End of protos/perfetto/config/android/app_wakelock_config.proto

// Begin of protos/perfetto/config/android/cpu_per_uid_config.proto

// Data source that records CPU per UID data.
message CpuPerUidConfig {
  // Record at this frequency.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/cpu_per_uid_config.proto

// Begin of protos/perfetto/config/android/kernel_wakelocks_config.proto

// Data source that records kernel (and native) wakelock data.
message KernelWakelocksConfig {
  // Record at this frequency.
  optional uint32 poll_ms = 1;
}

// End of protos/perfetto/config/android/kernel_wakelocks_config.proto

// Begin of protos/perfetto/config/android/network_trace_config.proto

// Network tracing data source that records details on all packets sent or
// received by the network.
message NetworkPacketTraceConfig {
  // Polling frequency in milliseconds. Network tracing writes to a fixed size
  // ring buffer. The polling interval should be such that the ring buffer is
  // unlikely to fill in that interval (or that filling is an acceptable risk).
  // The minimum polling rate is 100ms (values below this are ignored).
  // Introduced in Android 14 (U).
  optional uint32 poll_ms = 1;

  // The aggregation_threshold is the number of packets at which an event will
  // switch from per-packet details to aggregate details. For example, a value
  // of 50 means that if a particular event (grouped by the unique combinations
  // of metadata fields: {interface, direction, uid, etc}) has fewer than 50
  // packets, the exact timestamp and length are recorded for each packet. If
  // there were 50 or more packets in an event, it would only record the total
  // duration, packets, and length. A value of zero or unspecified will always
  /// record per-packet details. A value of 1 always records aggregate details.
  optional uint32 aggregation_threshold = 2;

  // Specifies the maximum number of packet contexts to intern at a time. This
  // prevents the interning table from growing too large and controls whether
  // interning is enabled or disabled (a value of zero disables interning and
  // is the default). When a data sources interning table reaches this amount,
  // packet contexts will be inlined into NetworkPacketEvents.
  optional uint32 intern_limit = 3;

  // The following fields specify whether certain fields should be dropped from
  // the output. Dropping fields improves normalization results, reduces the
  // size of the interning table, and slightly reduces event size.
  optional bool drop_local_port = 4;
  optional bool drop_remote_port = 5;
  optional bool drop_tcp_flags = 6;
}

// End of protos/perfetto/config/android/network_trace_config.proto

// Begin of protos/perfetto/config/android/packages_list_config.proto

// Data source that lists details (such as version code) about packages on an
// Android device.
message PackagesListConfig {
  // If not empty, emit info about only the following list of package names
  // (exact match, no regex). Otherwise, emit info about all packages.
  repeated string package_name_filter = 1;

  // If present and non-zero, the data source will periodically poll for CPU
  // use by packages and only emit results for those that it sees. If absent,
  // the data source will emit results for all packages at startup. The package
  // name filter applies either way.
  optional uint32 only_write_on_cpu_use_every_ms = 2;
}

// End of protos/perfetto/config/android/packages_list_config.proto

// Begin of protos/perfetto/config/android/pixel_modem_config.proto

// Data source that records events from the modem.
message PixelModemConfig {
  // Event group to record, as defined by the modem.
  enum EventGroup {
    EVENT_GROUP_UNKNOWN = 0;

    // Events suitable for low bandwidth tracing only.
    EVENT_GROUP_LOW_BANDWIDTH = 1;

    // Events suitable for high and low bandwidth tracing.
    EVENT_GROUP_HIGH_AND_LOW_BANDWIDTH = 2;
  }

  optional EventGroup event_group = 1;

  // If set, record only events with these hashes.
  repeated int64 pigweed_hash_allow_list = 2;

  // If set and allow_list is not set, deny events with these hashes.
  repeated int64 pigweed_hash_deny_list = 3;
}

// End of protos/perfetto/config/android/pixel_modem_config.proto

// Begin of protos/perfetto/common/protolog_common.proto

enum ProtoLogLevel {
  PROTOLOG_LEVEL_UNDEFINED = 0;
  PROTOLOG_LEVEL_DEBUG = 1;
  PROTOLOG_LEVEL_VERBOSE = 2;
  PROTOLOG_LEVEL_INFO = 3;
  PROTOLOG_LEVEL_WARN = 4;
  PROTOLOG_LEVEL_ERROR = 5;
  PROTOLOG_LEVEL_WTF = 6;
}
// End of protos/perfetto/common/protolog_common.proto

// Begin of protos/perfetto/config/android/protolog_config.proto

// Custom configuration for the "android.protolog" data source.
// ProtoLog is a logging mechanism that is intented to be more efficient than
// logcat. This configures what logs to capture in the tracing instance.
message ProtoLogConfig {
  enum TracingMode {
    // When using the DEFAULT tracing mode, only log groups and levels specified
    // in the group_overrides are traced.
    DEFAULT = 0;
    // When using the ENABLE_ALL tracing mode, all log groups and levels are
    // traced, unless specified in the group_overrides.
    ENABLE_ALL = 1;
  }

  // Specified the configurations for each of the logging groups. If none is
  // specified for a group the defaults will be used.
  repeated ProtoLogGroup group_overrides = 1;
  // Specified what tracing mode to use for the tracing instance.
  optional TracingMode tracing_mode = 2;
  // If set, any message with log level higher than this level (inclusive) will
  // be traced. Group overrides take precedence over this value.
  optional ProtoLogLevel default_log_from_level = 3;
}

message ProtoLogGroup {
  // The ProtoLog group name this configuration entry applies to.
  optional string group_name = 1;
  // Specify the level from which to start capturing protologs.
  // e.g. if ProtoLogLevel.WARN is specified only warning, errors and fatal log
  // message will be traced.
  optional ProtoLogLevel log_from = 2;
  // When set to true we will collect the stacktrace for each protolog message
  // in this group that we are tracing.
  optional bool collect_stacktrace = 3;
}

// End of protos/perfetto/config/android/protolog_config.proto

// Begin of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Custom configuration for the "android.surfaceflinger.layers" data source.
message SurfaceFlingerLayersConfig {
  enum Mode {
    MODE_UNSPECIFIED = 0;

    // Trace layers snapshots. A snapshot is taken every time a layers change
    // occurs.
    MODE_ACTIVE = 1;

    // Generate layers snapshots from the transactions kept in the
    // SurfaceFlinger's internal ring buffer.
    // The layers snapshots generation occurs when this data source is flushed.
    MODE_GENERATED = 2;

    // Trace a single layers snapshot.
    MODE_DUMP = 3;

    // Default mode (applied by SurfaceFlinger if no mode is specified).
    // Same as MODE_GENERATED, but triggers the layers snapshots generation only
    // when a bugreport is taken.
    MODE_GENERATED_BUGREPORT_ONLY = 4;
  }
  optional Mode mode = 1;

  enum TraceFlag {
    TRACE_FLAG_UNSPECIFIED = 0;
    TRACE_FLAG_INPUT = 0x02;
    TRACE_FLAG_COMPOSITION = 0x04;
    TRACE_FLAG_EXTRA = 0x08;
    TRACE_FLAG_HWC = 0x10;
    TRACE_FLAG_BUFFERS = 0x20;
    TRACE_FLAG_VIRTUAL_DISPLAYS = 0x40;

    // INPUT | COMPOSITION | EXTRA
    TRACE_FLAG_ALL = 0x0e;
  }
  repeated TraceFlag trace_flags = 2;
}

// End of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Begin of protos/perfetto/config/android/surfaceflinger_transactions_config.proto

// Custom configuration for the "android.surfaceflinger.transactions" data
// source.
message SurfaceFlingerTransactionsConfig {
  enum Mode {
    MODE_UNSPECIFIED = 0;

    // Default mode (applied by SurfaceFlinger if no mode is specified).
    // SurfaceFlinger writes its internal ring buffer of transactions every time
    // the data source is flushed. The ring buffer contains the SurfaceFlinger's
    // initial state and the latest transactions.
    MODE_CONTINUOUS = 1;

    // SurfaceFlinger writes the initial state and then each incoming
    // transaction until the data source is stopped.
    MODE_ACTIVE = 2;
  }
  optional Mode mode = 1;
}

// End of protos/perfetto/config/android/surfaceflinger_transactions_config.proto

// Begin of protos/perfetto/config/android/user_list_config.proto

// Data source that lists details (such as version code) about users on an
// Android device.
message UserListConfig {
  // If not empty, emit info about only the following list of user types
  // (exact match, no regex). Otherwise, emit info about all users.
  repeated string user_type_filter = 1;
}

// End of protos/perfetto/config/android/user_list_config.proto

// Begin of protos/perfetto/config/android/windowmanager_config.proto

// Custom configuration for the "android.windowmanager" data source.
message WindowManagerConfig {
  enum LogFrequency {
    LOG_FREQUENCY_UNSPECIFIED = 0;

    // Trace state snapshots when a frame is committed.
    LOG_FREQUENCY_FRAME = 1;

    // Trace state snapshots every time a transaction is committed.
    LOG_FREQUENCY_TRANSACTION = 2;

    // Trace single state snapshots when the data source is started.
    LOG_FREQUENCY_SINGLE_DUMP = 3;
  }
  optional LogFrequency log_frequency = 1;

  enum LogLevel {
    LOG_LEVEL_UNSPECIFIED = 0;

    // Logs all elements with maximum amount of information.
    LOG_LEVEL_VERBOSE = 1;

    // Logs all elements but doesn't write all configuration data.
    LOG_LEVEL_DEBUG = 2;

    // Logs only visible elements, with the minimum amount of performance
    // overhead
    LOG_LEVEL_CRITICAL = 3;
  }
  optional LogLevel log_level = 2;
}

// End of protos/perfetto/config/android/windowmanager_config.proto

// Begin of protos/perfetto/config/chrome/chrome_config.proto

message ChromeConfig {
  optional string trace_config = 1;

  // When enabled, the data source should only fill in fields in the output that
  // are not potentially privacy sensitive.
  optional bool privacy_filtering_enabled = 2;

  // Instead of emitting binary protobuf, convert the trace data to the legacy
  // JSON format. Note that the trace data will still be returned as a series of
  // TracePackets, but the embedded data will be JSON instead of serialized
  // protobuf.
  optional bool convert_to_legacy_json = 3;

  // Priority of the tracing session client. A higher priority session may
  // preempt a lower priority one in configurations where concurrent sessions
  // aren't supported.
  enum ClientPriority {
    UNKNOWN = 0;
    BACKGROUND = 1;
    USER_INITIATED = 2;
  }
  optional ClientPriority client_priority = 4;

  // Applicable only when using legacy JSON format.
  // If |json_agent_label_filter| is not empty, only data pertaining to
  // the specified tracing agent label (e.g. "traceEvents") will be returned.
  optional string json_agent_label_filter = 5;

  //  When enabled, event names should not contain package names.
  optional bool event_package_name_filter_enabled = 6;
}

// End of protos/perfetto/config/chrome/chrome_config.proto

// Begin of protos/perfetto/config/chrome/histogram_samples.proto

message ChromiumHistogramSamplesConfig {
  // Records when a value within the specified bounds [min_value, max_value] is
  // emitted into a Chrome histogram.
  message HistogramSample {
    optional string histogram_name = 1;
    optional int64 min_value = 2;
    optional int64 max_value = 3;
  }
  // List of histograms to record. If no histogram is specified, all histograms
  // are recorded.
  repeated HistogramSample histograms = 1;

  // Default: false (i.e. histogram names are NOT filtered out by default)
  // When true, histogram_name will be filtered out.
  optional bool filter_histogram_names = 2;
}

// End of protos/perfetto/config/chrome/histogram_samples.proto

// Begin of protos/perfetto/config/chrome/system_metrics.proto

message ChromiumSystemMetricsConfig {
  // Samples counters every X ms.
  optional uint32 sampling_interval_ms = 1;
}

// End of protos/perfetto/config/chrome/system_metrics.proto

// Begin of protos/perfetto/config/chrome/v8_config.proto

message V8Config {
  // Whether to log the actual content of scripts (e.g. content of the JS file
  // that was compiled to generate code).
  // ATTENTION: This could considerably increase the size of the resuling trace
  //            file.
  optional bool log_script_sources = 1;
  // Whether to log the generated code for jitted functions (machine code or
  // bytecode).
  // ATTENTION: This could considerably increase the size of the resuling trace
  //            file.
  optional bool log_instructions = 2;
}

// End of protos/perfetto/config/chrome/v8_config.proto

// Begin of protos/perfetto/config/etw/etw_config.proto

// Proto definition based on the struct _EVENT_TRACE_PROPERTIES definition
// See: https://learn.microsoft.com/en-us/windows/win32/api/evntrace/
// ns-evntrace-event_trace_properties
message EtwConfig {
  // The KernelFlag represent list of kernel flags that we are intrested in.
  // To get a more extensive list run 'xperf -providers k'.
  enum KernelFlag {
    CSWITCH = 0;
    DISPATCHER = 1;
  }

  // The kernel_flags determines the flags that will be used by the etw tracing
  // session. These kernel flags have been built to expose the useful events
  // captured from the kernel mode only.
  repeated KernelFlag kernel_flags = 1;

  // See the list of keywords for for individual providers.
  // https://learn.microsoft.com/en-us/windows/win32/etw/system-providers

  // Provides events relating to the scheduler.
  repeated string scheduler_provider_events = 2;
  // Provides events relating to the memory manager.
  repeated string memory_provider_events = 3;
  // Provides events relating to file I/O.
  repeated string file_provider_events = 4;
}

// End of protos/perfetto/config/etw/etw_config.proto

// Begin of protos/perfetto/config/ftrace/frozen_ftrace_config.proto

message FrozenFtraceConfig {
  // The instance name which stores the previous boot ftrace data. Required.
  optional string instance_name = 1;
}

// End of protos/perfetto/config/ftrace/frozen_ftrace_config.proto

// Begin of protos/perfetto/config/ftrace/ftrace_config.proto

// Next id: 38
message FtraceConfig {
  // Ftrace events to record, example: "sched/sched_switch".
  repeated string ftrace_events = 1;

  // Android-specific event categories:
  repeated string atrace_categories = 2;
  repeated string atrace_apps = 3;
  // Some processes can emit data through atrace or through the perfetto SDK via
  // the "track_event" data source. For these categories, the SDK will be
  // preferred, if possible, for this config.
  repeated string atrace_categories_prefer_sdk = 28;
  // If true, do *not* add in extra ftrace events when |atrace_categories| are
  // set. This skips the legacy "atrace" behaviour of adding hardcoded ftrace
  // events for convenience (and the vendor-specific events on top).
  // Introduced in: perfetto v52.
  optional bool atrace_userspace_only = 34;

  // Size of each per-cpu kernel ftrace ring buffer.
  // Not guaranteed if there are multiple concurrent tracing sessions, as the
  // buffers cannot be resized without pausing recording in the kernel.
  optional uint32 buffer_size_kb = 10;

  // If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
  // implementation to choose a bigger buffer size.
  //
  // Most configs for perfetto v43+ should simply leave both fields unset.
  //
  // If you need a config compatible with a range of perfetto builds and you
  // used to set a non-default buffer_size_kb, consider setting both fields.
  // Example:
  //   buffer_size_kb: 4096
  //   buffer_size_lower_bound: true
  // On older builds, the per-cpu buffers will be exactly 4 MB.
  // On v43+, buffers will be at least 4 MB.
  // In both cases, neither is guaranteed if there are other concurrent
  // perfetto ftrace sessions, as the buffers cannot be resized without pausing
  // the recording in the kernel.
  // Introduced in: perfetto v43.
  optional bool buffer_size_lower_bound = 27;

  // If set, specifies how often the tracing daemon reads from the kernel ring
  // buffer. Not guaranteed if there are multiple concurrent tracing sessions.
  // Leave unset unless you're fine-tuning a local config.
  optional uint32 drain_period_ms = 11;

  // If set, the tracing daemon will read kernel ring buffers as soon as
  // they're filled past this percentage of occupancy. In other words, a value
  // of 50 means that a read pass is triggered as soon as any per-cpu buffer is
  // half-full. Not guaranteed if there are multiple concurrent tracing
  // sessions.
  // Currently does nothing on Linux kernels below v6.9.
  // Introduced in: perfetto v48.
  optional uint32 drain_buffer_percent = 29;

  // Configuration for compact encoding of scheduler events. When enabled (and
  // recording the relevant ftrace events), specific high-volume events are
  // encoded in a denser format than normal.
  message CompactSchedConfig {
    // If true, and sched_switch or sched_waking ftrace events are enabled,
    // record those events in the compact format.
    //
    // If the field is unset, the default is:
    // * perfetto v42.0+: enabled
    // * before: disabled
    optional bool enabled = 1;
  }
  optional CompactSchedConfig compact_sched = 12;

  // Optional filter for "ftrace/print" events.
  //
  // The filter consists of multiple rules. As soon as a rule matches (the rules
  // are processed in order), its `allow` field will be used as the outcome: if
  // `allow` is true, the event will be included in the trace, otherwise it will
  // be discarded. If an event does not match any rule, it will be allowed by
  // default (a rule with an empty prefix and allow=false, disallows everything
  // by default).
  message PrintFilter {
    message Rule {
      // Matches an atrace message of the form:
      // <type>|pid|<prefix>...
      message AtraceMessage {
        optional string type = 1;
        optional string prefix = 2;
      }
      oneof match {
        // This rule matches if `prefix` matches exactly with the beginning of
        // the "ftrace/print" "buf" field.
        string prefix = 1;
        // This rule matches if the "buf" field contains an atrace-style print
        // message as specified in `atrace_msg`.
        AtraceMessage atrace_msg = 3;
      }
      optional bool allow = 2;
    }
    repeated Rule rules = 1;
  }
  optional PrintFilter print_filter = 22;

  // Enables symbol name resolution against /proc/kallsyms.
  // It requires that either traced_probes is running as root or that
  // kptr_restrict has been manually lowered.
  // It does not disclose KASLR, symbol addresses are mangled.
  optional bool symbolize_ksyms = 13;

  // When symbolize_ksyms=true, determines whether the traced_probes daemon
  // should keep the symbol map in memory (and reuse it for future tracing
  // sessions) or clear it (saving memory) and re-create it on each tracing
  // session (wasting cpu and wall time).
  // The tradeoff is roughly:
  //  KSYMS_RETAIN: pay a fixed ~1.2 MB cost after the first trace.
  //  KSYMS_CLEANUP_ON_STOP: pay a ~300-500ms cost when starting each trace.
  // Default behavior: KSYMS_CLEANUP_ON_STOP.
  enum KsymsMemPolicy {
    KSYMS_UNSPECIFIED = 0;
    KSYMS_CLEANUP_ON_STOP = 1;
    KSYMS_RETAIN = 2;
  }
  optional KsymsMemPolicy ksyms_mem_policy = 17;

  // When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
  // this option causes traced_probes to enable the "kmem/rss_stat_throttled"
  // event instead if present, and fall back to "kmem/rss_stat" if not present.
  // The historical context for this is the following:
  // - Up to Android S (12), the rss_stat was internally throttled in its
  //   kernel implementation.
  // - A change introduced in the kernels after S has introduced a new
  //   "rss_stat_throttled" making the original "rss_stat" event unthrottled
  //   (hence very spammy).
  // - Not all Android T/13 devices will receive a new kernel though, hence we
  //   need to deal with both cases.
  // For more context: go/rss-stat-throttled.
  optional bool throttle_rss_stat = 15;

  // If true, use self-describing proto messages when writing events not known
  // at compile time (aka generic events). Each event bundle will have a set of
  // serialised proto descriptors for events within that bundle.
  //
  // Default if unset:
  // * v53+: true
  // * before v53: false
  //
  // Added in: perfetto v50.
  optional bool denser_generic_event_encoding = 32;

  // If true, avoid enabling events that aren't statically known by
  // traced_probes. Otherwise, the default is to emit such events as
  // GenericFtraceEvent protos.
  // Prefer to keep this flag at its default. This was added for Android
  // tracing, where atrace categories and/or atrace HAL requested events can
  // expand to events that aren't of interest to the tracing user.
  // Introduced in: Android T.
  optional bool disable_generic_events = 16;

  // The subset of syscalls to record. To record all syscalls, leave this unset
  // and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
  // * before perfetto v43, requires the config to also enable
  //   raw_syscalls/sys_{enter,exit}.
  // * perfetto v43+ does the right thing if you set only this field.
  // Example: ["sys_read", "sys_open"].
  // Introduced in: Android U.
  repeated string syscall_events = 18;

  // If true, enable the "function_graph" kernel tracer that emits events
  // whenever a kernel function is entered and exited
  // (funcgraph_entry/funcgraph_exit).
  // Notes on use:
  // * Requires |symbolize_ksyms| for function name resolution.
  // * Use |function_filters| or |function_graph_roots| to constrain the traced
  //   set of functions, otherwise the event bandwidth will be too high for
  //   practical use.
  // * The data source might be rejected if there is already a concurrent
  //   ftrace data source that does not use function graph itself, as we do not
  //   support switching kernel tracers mid-trace.
  // * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
  //   enabled if "cat /sys/kernel/tracing/available_tracers" includes
  //   "function_graph".
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  optional bool enable_function_graph = 19;

  // Constrains the set of functions traced when |enable_function_graph| is
  // true. Supports globs, e.g. "sched*". You can specify multiple filters,
  // in which case all matching functions will be traced. See kernel
  // documentation on ftrace "set_ftrace_filter" file for more details.
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  repeated string function_filters = 20;

  // If |enable_function_graph| is true, trace this set of functions *and* all
  // of its callees. Supports globs. Can be set together with
  // |function_filters|, in which case only callees matching the filter will be
  // traced. If setting both, you most likely want all roots to also be
  // included in |function_filters|.
  // Android:
  // * Available only on debuggable builds.
  // * Introduced in: Android U.
  repeated string function_graph_roots = 21;

  // If |enable_function_graph| is true, only trace the specified
  // number of calls down the stack. Sets the max_graph_depth value
  // in sys/kernel/tracing/
  //
  // Only respected for the first tracing session that enables
  // function_graph tracing.
  //
  // Introduced in: perfetto v51.
  // Supported on: Android 25Q3+.
  optional uint32 function_graph_max_depth = 33;

  message KprobeEvent {
    enum KprobeType {
      KPROBE_TYPE_UNKNOWN = 0;
      KPROBE_TYPE_KPROBE = 1;
      KPROBE_TYPE_KRETPROBE = 2;
      KPROBE_TYPE_BOTH = 3;
    }
    // Kernel function name to attach to, for example "fuse_file_write_iter"
    optional string probe = 1;
    optional KprobeType type = 2;
  }
  // Ftrace events to record, specific for kprobes and kretprobes
  repeated KprobeEvent kprobe_events = 30;

  // If true, does not clear kernel ftrace buffers when starting the trace.
  // This makes sense only if this is the first ftrace data source instance
  // created after the daemon has been started. Can be useful for gathering boot
  // traces, if ftrace has been separately configured (e.g. via kernel
  // commandline).
  // NB: when configuring the pre-perfetto ftrace, prefer to set
  // "/sys/kernel/tracing/trace_clock" to "boot" if your trace will contain
  // anything besides ftrace. Otherwise timestamps might be skewed.
  optional bool preserve_ftrace_buffer = 23;

  // If true, overrides the default timestamp clock and uses a raw hardware
  // based monotonic clock for getting timestamps.
  // * Introduced in: Android U.
  optional bool use_monotonic_raw_clock = 24;

  // If |instance_name| is not empty, then attempt to use that tracefs instance
  // for event recording. Normally, this means
  // `/sys/kernel/tracing/instances/$instance_name`.
  //
  // Names "hyp" and "hypervisor" are reserved.
  //
  // The instance must already exist, the tracing daemon *will not* create it
  // for you as it typically doesn't have such permissions.
  // Only a subset of features is guaranteed to work with non-default instances,
  // at the time of writing:
  //  * ftrace_events
  //  * buffer_size_kb
  optional string instance_name = 25;

  // For perfetto developer use. If true and on a debuggable android build,
  // serialise raw tracing pages that the implementation cannot parse.
  optional bool debug_ftrace_abi = 31;

  // =================================================
  // Exclusive single-tenant features: HERE BE DRAGONS
  // =================================================
  // The features below are considered "advanced" and require an exclusive
  // tracing session (as of Android 25Q3+ and Perfetto v52).
  //
  // These features directly manipulate the kernel's global ftrace state and
  // are incompatible with concurrent ftrace sessions. They are only enabled
  // if included in the *first* ftrace data source configured. Subsequent
  // ftrace data sources (even those not using advanced features) will be
  // rejected while a session with these features is active.
  //
  // To run the session in exclusive mode, see:
  // https://perfetto.dev/docs/learning-more/android#exclusive-tracing-sessions.

  // Filter ftrace events by Thread ID (TID).
  // This writes the TIDs to `/sys/kernel/tracing/set_event_pid`.
  //
  // Note: this is an exclusive feature, see:
  // https://perfetto.dev/docs/learning-more/android#exclusive-tracing-sessions.
  //
  // Introduced in: perfetto v52.
  // Supported on: Android 25Q3+.
  repeated uint32 tids_to_trace = 35;

  // Tracefs options to set directly in the tracefs instance. This is a very
  // niche feature since almost all of the options deal with formatting textual
  // output (the /trace file), which perfetto doesn't use.
  //
  // The options with a known use-case:
  // * event-fork: when using `tids_to_trace` above, the kernel will
  //   automatically add newly spawned descendant threads to the set of TIDs.
  //
  // Full list of options is available at
  // https://docs.kernel.org/trace/ftrace.html#trace-options.
  //
  // Note: this is an exclusive feature, see:
  // https://perfetto.dev/docs/learning-more/android#exclusive-tracing-sessions.
  //
  // Introduced in: perfetto v52.
  // Supported on: Android 25Q3+.
  message TracefsOption {
    enum State {
      STATE_UNKNOWN = 0;
      STATE_ENABLED = 1;
      STATE_DISABLED = 2;
    }
    // The name of the tracefs option as found in tracefs/trace_options (without
    // the "no" prefix).
    optional string name = 1;
    optional State state = 2;
  }
  repeated TracefsOption tracefs_options = 36;

  // This mask restricts tracing to a specific set of CPUs using a
  // comma-separated hex mask. Each hex number (up to 8 digits) represents a
  // 32-bit chunk of the CPU mask.
  //
  // The chunks are ordered from high CPUs to low CPUs (left to right):
  //  - Rightmost chunk: CPUs 0-31
  //  - 2nd chunk from right: CPUs 32-63
  //  - ...and so on.
  //
  // Example (assuming NR_CPUS=128, requiring 4 chunks):
  // The full mask would be in the format: "chunk3,chunk2,chunk1,chunk0"
  // where chunk3 maps to CPUs 96-127, chunk2 to 64-95, chunk1 to 32-63, and
  // chunk0 to 0-31.
  //  - "ffffffff,0,0,0": Enables CPUs 96-127 only.
  //  - "f,ff": Enables CPUs 0-7 (from "ff") and CPUs 32-35 (from "f").
  //
  // Note: This is an exclusive feature, see:
  // https://perfetto.dev/docs/learning-more/android#exclusive-tracing-sessions.
  //
  // Introduced in: perfetto v52.
  // Supported on: Android 25Q3+.
  optional string tracing_cpumask = 37;

  // No-op in perfetto v28+. Name preserved because of existing references in
  // textproto configs.
  optional bool initialize_ksyms_synchronously_for_testing = 14
      [deprecated = true];

  // Previously drain_buffer_percent, perfetto v43-v47.
  reserved 26;
}

// End of protos/perfetto/config/ftrace/ftrace_config.proto

// Begin of protos/perfetto/config/gpu/gpu_counter_config.proto

message GpuCounterConfig {
  // Desired sampling interval for counters.
  optional uint64 counter_period_ns = 1;

  // List of counters to be sampled. Counter IDs correspond to the ones
  // described in GpuCounterSpec in the data source descriptor.
  repeated uint32 counter_ids = 2;

  // Sample counters by instrumenting command buffers.
  optional bool instrumented_sampling = 3;

  // Fix gpu clock rate during trace session.
  optional bool fix_gpu_clock = 4;
}

// End of protos/perfetto/config/gpu/gpu_counter_config.proto

// Begin of protos/perfetto/config/gpu/gpu_renderstages_config.proto

message GpuRenderStagesConfig {
  // Enable to separate the color and depth/stencil load and store stages
  // into a separate stages. If disabled, the depth/stencil load and store
  // stages will be combined.  Disabled by default. This option has no effect if
  // Low Overhead mode is enabled.
  optional bool full_loadstore = 1;

  // Use the low overhead mode for traces. In this mode render stages are
  // combined into a single workload stage. This provides less granular data but
  // induces minimal GPU overhead. Disabled by default.
  optional bool low_overhead = 2;

  // Trace metrics to capture for each render stage
  repeated string trace_metrics = 3;
}

// End of protos/perfetto/config/gpu/gpu_renderstages_config.proto

// Begin of protos/perfetto/config/gpu/vulkan_memory_config.proto

message VulkanMemoryConfig {
  // Tracking driver memory usage events
  optional bool track_driver_memory_usage = 1;

  // Tracking device memory usage events
  optional bool track_device_memory_usage = 2;
}

// End of protos/perfetto/config/gpu/vulkan_memory_config.proto

// Begin of protos/perfetto/config/inode_file/inode_file_config.proto

// WARNING: unmaintained and deprecated. Likely won't work at all on modern
// systems.
message InodeFileConfig {
  message MountPointMappingEntry {
    optional string mountpoint = 1;
    repeated string scan_roots = 2;
  }

  // How long to pause between batches.
  optional uint32 scan_interval_ms = 1;

  // How long to wait before the first scan in order to accumulate inodes.
  optional uint32 scan_delay_ms = 2;

  // How many inodes to scan in one batch.
  optional uint32 scan_batch_size = 3;

  // Do not scan for inodes not found in the static map.
  optional bool do_not_scan = 4;

  // If non-empty, only scan inodes corresponding to block devices named in
  // this list.
  repeated string scan_mount_points = 5;

  // When encountering an inode belonging to a block device corresponding
  // to one of the mount points in this map, scan its scan_roots instead.
  repeated MountPointMappingEntry mount_point_mapping = 6;
}

// End of protos/perfetto/config/inode_file/inode_file_config.proto

// Begin of protos/perfetto/config/interceptors/console_config.proto

message ConsoleConfig {
  enum Output {
    OUTPUT_UNSPECIFIED = 0;
    OUTPUT_STDOUT = 1;
    OUTPUT_STDERR = 2;
  }
  optional Output output = 1;
  optional bool enable_colors = 2;
}

// End of protos/perfetto/config/interceptors/console_config.proto

// Begin of protos/perfetto/config/interceptor_config.proto

// Configuration for trace packet interception. Used for diverting trace data to
// non-Perfetto sources (e.g., logging to the console, ETW) when using the
// Perfetto SDK.
message InterceptorConfig {
  // Matches the name given to RegisterInterceptor().
  optional string name = 1;

  optional ConsoleConfig console_config = 100;
}

// End of protos/perfetto/config/interceptor_config.proto

// Begin of protos/perfetto/config/power/android_power_config.proto

message AndroidPowerConfig {
  enum BatteryCounters {
    BATTERY_COUNTER_UNSPECIFIED = 0;

    // Coulomb counter.
    BATTERY_COUNTER_CHARGE = 1;

    // Charge (%).
    BATTERY_COUNTER_CAPACITY_PERCENT = 2;

    // Instantaneous current.
    BATTERY_COUNTER_CURRENT = 3;

    // Avg current.
    BATTERY_COUNTER_CURRENT_AVG = 4;

    // Instantaneous voltage.
    BATTERY_COUNTER_VOLTAGE = 5;
  }
  optional uint32 battery_poll_ms = 1;
  repeated BatteryCounters battery_counters = 2;

  // Where available enables per-power-rail measurements.
  optional bool collect_power_rails = 3;

  // Provides a breakdown of energy estimation for various subsystem (e.g. GPU).
  // Available from Android S.
  optional bool collect_energy_estimation_breakdown = 4;

  // Provides a breakdown of time in state for various subsystems.
  // Available from Android U.
  optional bool collect_entity_state_residency = 5;
}

// End of protos/perfetto/config/power/android_power_config.proto

// Begin of protos/perfetto/config/priority_boost/priority_boost_config.proto

// Configuration that allows to boost the priority of the 'traced' or
// 'traced_probs' processes, by changing the scheduler configuration.
// Only supported on Linux and Android the boosted process must have
// 'CAP_SYS_NICE' capability.
message PriorityBoostConfig {
  enum BoostPolicy {
    POLICY_UNSPECIFIED = 0;
    // The default policy (e.g., CFS on Linux). Priority range: [0; 20]
    // priority is interpreted as -(nice), i.e., 1 is slightly higher prio
    // than default 0, 20 is the highest priority.
    // Note: this is the opposite semantic of the cmdline nice, and is done for
    // consistency with POLICY_SCHED_FIFO, so higher number == higher prio.
    POLICY_SCHED_OTHER = 1;
    // The Real-time policy, Priority range: [1; 99]
    POLICY_SCHED_FIFO = 2;
  };
  optional BoostPolicy policy = 1;
  optional uint32 priority = 2;
}
// End of protos/perfetto/config/priority_boost/priority_boost_config.proto

// Begin of protos/perfetto/config/process_stats/process_stats_config.proto

// Config for polling process-related information from /proc/pid/status and
// related files on Linux.
//
// Data source name: "linux.process_stats".
message ProcessStatsConfig {
  enum Quirks {
    QUIRKS_UNSPECIFIED = 0;

    // This has been deprecated and ignored as per 2018-05-01. Full scan at
    // startup is now disabled by default and can be re-enabled using the
    // |scan_all_processes_on_start| arg.
    DISABLE_INITIAL_DUMP = 1 [deprecated = true];

    // If set, disables the special interaction with "linux.ftrace" data source,
    // where the process stats rescrapes any thread id seen in the ftrace
    // stream.
    DISABLE_ON_DEMAND = 2;
  }
  repeated Quirks quirks = 1;

  // If enabled all processes will be scanned and dumped when the trace starts.
  optional bool scan_all_processes_on_start = 2;

  // If enabled thread names are also recoded (this is redundant if sched_switch
  // is enabled).
  optional bool record_thread_names = 3;

  // If > 0 samples counters (see process_stats.proto) from
  // /proc/pid/status and oom_score_adj every X ms.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 proc_stats_poll_ms = 4;

  // id 5 never used

  // Explicit caching period during which the polling won't re-emit identical
  // counter values. This is required to be either = 0 or a multiple of
  // |proc_stats_poll_ms| (default: |proc_stats_poll_ms|). Non-multiples will be
  // rounded down to the nearest multiple.
  optional uint32 proc_stats_cache_ttl_ms = 6;

  // If true and |proc_stats_poll_ms| is set, sample memory stats from
  // /proc/pid/smaps_rollup.
  //
  // Android: does NOT work with the system daemons by default, as it requires
  // running the recording process (traced_probes or tracebox) as root. It is
  // possible to avoid the root requirement, but the exact steps depend on the
  // Linux distibution. The proc file requires passing a PTRACE_MODE_READ
  // check, and might be further covered by the procfs "hidepid" mount option.
  optional bool scan_smaps_rollup = 10;

  // If true: process descriptions will include process age (starttime in
  // /proc/pid/stat).
  // Introduced in: perfetto v44.
  optional bool record_process_age = 11;

  // If true and |proc_stats_poll_ms| is set, process stats will include time
  // spent running in user/kernel mode (utime/stime in /proc/pid/stat).
  // Introduced in: perfetto v44.
  optional bool record_process_runtime = 12;

  // If true obtain per-process dmabuf resident set size from
  // /proc/pid/dmabuf_rss.
  // This feature is not in upstream linux, and is available only on some
  // Android kernels.
  optional bool record_process_dmabuf_rss = 13;

  // WARNING: unmaintained and deprecated. If true this will resolve file
  // descriptors for each process so these can be mapped to their actual device
  // or file. Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled
  // or new fds opened after initially scanning a process will not be
  // recognized.
  optional bool resolve_process_fds = 9;

  // record_thread_time_in_state
  reserved 7;
  // thread_time_in_state_cache_size
  reserved 8;
}

// End of protos/perfetto/config/process_stats/process_stats_config.proto

// Begin of protos/perfetto/config/profiling/heapprofd_config.proto

// Configuration for go/heapprofd.
// Next id: 28
message HeapprofdConfig {
  message ContinuousDumpConfig {
    // ms to wait before first dump.
    optional uint32 dump_phase_ms = 5;
    // ms to wait between following dumps.
    optional uint32 dump_interval_ms = 6;
  }

  // Sampling rate for all heaps not specified via heap_sampling_intervals.
  //
  // These are:
  // * All heaps if heap_sampling_intervals is empty.
  // * Those profiled due to all_heaps and not named in heaps if
  //   heap_sampling_intervals is not empty.
  // * The implicit libc.malloc heap if heaps is empty.
  //
  // Set to 1 for perfect accuracy.
  // Otherwise, sample every sample_interval_bytes on average.
  //
  // See
  // https://perfetto.dev/docs/data-sources/native-heap-profiler#sampling-interval
  // for more details.
  //
  // BUGS
  // Before Android 12, setting this to 0 would crash the target process.
  //
  // N.B. This must be explicitly set to a non-zero value for all heaps (with
  // this field or with heap_sampling_intervals), otherwise the producer will
  // not start.
  optional uint64 sampling_interval_bytes = 1;

  // If less than the given numbers of bytes are left free in the shared
  // memory buffer, increase sampling interval by a factor of two.
  // Adaptive sampling is disabled when set to 0.
  optional uint64 adaptive_sampling_shmem_threshold = 24;
  // Stop doubling the sampling_interval once the sampling interval has reached
  // this value.
  optional uint64 adaptive_sampling_max_sampling_interval_bytes = 25;

  // E.g. surfaceflinger, com.android.phone
  // This input is normalized in the following way: if it contains slashes,
  // everything up to the last slash is discarded. If it contains "@",
  // everything after the first @ is discared.
  // E.g. /system/bin/surfaceflinger@1.0 normalizes to surfaceflinger.
  // This transformation is also applied to the processes' command lines when
  // matching.
  repeated string process_cmdline = 2;

  // For watermark based triggering or local debugging.
  repeated uint64 pid = 4;

  // Only profile target if it was installed by one of the packages given.
  // Special values are:
  // * @system: installed on the system partition
  // * @product: installed on the product partition
  // * @null: sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 26;

  // Which heaps to sample, e.g. "libc.malloc". If left empty, only samples
  // "malloc".
  //
  // Introduced in Android 12.
  repeated string heaps = 20;

  // Which heaps not to sample, e.g. "libc.malloc". This is useful when used in
  // combination with all_heaps;
  //
  // Introduced in Android 12.
  repeated string exclude_heaps = 27;

  optional bool stream_allocations = 23;

  // If given, needs to be the same length as heaps and gives the sampling
  // interval for the respective entry in heaps.
  //
  // Otherwise, sampling_interval_bytes is used.
  //
  // It is recommended to set sampling_interval_bytes to a reasonable default
  // value when using this, as a value of 0 for sampling_interval_bytes will
  // crash the target process before Android 12.
  //
  // Introduced in Android 12.
  //
  // All values must be non-zero or the producer will not start.
  repeated uint64 heap_sampling_intervals = 22;

  // Sample all heaps registered by target process. Introduced in Android 12.
  optional bool all_heaps = 21;

  // Profile all processes eligible for profiling on the system.
  // See
  // https://perfetto.dev/docs/data-sources/native-heap-profiler#heapprofd-targets
  // for which processes are eligible.
  //
  // On unmodified userdebug builds, this will lead to system crashes. Zygote
  // will crash when trying to launch a new process as it will have an
  // unexpected open socket to heapprofd.
  //
  // heapprofd will likely be overloaded by the amount of data for low
  // sampling intervals.
  optional bool all = 5;

  // Do not profile processes whose anon RSS + swap < given value.
  // Introduced in Android 11.
  optional uint32 min_anonymous_memory_kb = 15;

  // Stop profile if heapprofd memory usage goes beyond the given value.
  // Introduced in Android 11.
  optional uint32 max_heapprofd_memory_kb = 16;

  // Stop profile if heapprofd CPU time since start of this data-source
  // goes beyond given value.
  // Introduced in Android 11.
  optional uint64 max_heapprofd_cpu_secs = 17;

  // Do not emit function names for mappings starting with this prefix.
  // E.g. /system to not emit symbols for any system libraries.
  repeated string skip_symbol_prefix = 7;

  // Dump at a predefined interval.
  optional ContinuousDumpConfig continuous_dump_config = 6;

  // Size of the shared memory buffer between the profiled processes and
  // heapprofd. Defaults to 8 MiB. If larger than 500 MiB, truncated to 500
  // MiB.
  //
  // Needs to be:
  // * at least 8192,
  // * a power of two,
  // * a multiple of 4096.
  optional uint64 shmem_size_bytes = 8;

  // When the shmem buffer is full, block the client instead of ending the
  // trace. Use with caution as this will significantly slow down the target
  // process.
  optional bool block_client = 9;

  // If set, stop the trace session after blocking the client for this
  // timeout. Needs to be larger than 100 us, otherwise no retries are done.
  // Introduced in Android 11.
  optional uint32 block_client_timeout_us = 14;

  // Do not profile processes from startup, only match already running
  // processes.
  //
  // Can not be set at the same time as no_running.
  // Introduced in Android 11.
  optional bool no_startup = 10;

  // Do not profile running processes. Only match processes on startup.
  //
  // Can not be set at the same time as no_startup.
  // Introduced in Android 11.
  optional bool no_running = 11;

  // deprecated idle_allocations.
  reserved 12;

  // Cause heapprofd to emit a single dump at the end, showing the memory usage
  // at the point in time when the sampled heap usage of the process was at its
  // maximum. This causes ProfilePacket.HeapSample.self_max to be set, and
  // self_allocated and self_freed to not be set.
  // Introduced in Android 11.
  optional bool dump_at_max = 13;

  // FEATURE FLAGS. THERE BE DRAGONS.

  // Escape hatch if the session is being torn down because of a forked child
  // that shares memory space, but is not correctly identified as a vforked
  // child.
  // Introduced in Android 11.
  optional bool disable_fork_teardown = 18;

  // We try to automatically detect when a target applicatation vforks but then
  // does a memory allocation (or free). This auto-detection can be disabled
  // with this.
  // Introduced in Android 11.
  optional bool disable_vfork_detection = 19;
}

// End of protos/perfetto/config/profiling/heapprofd_config.proto

// Begin of protos/perfetto/config/profiling/java_hprof_config.proto

// Configuration for managed app heap graph snapshots.
message JavaHprofConfig {
  // If dump_interval_ms != 0, the following configuration is used.
  message ContinuousDumpConfig {
    // ms to wait before first continuous dump.
    // A dump is always created at the beginning of the trace.
    optional uint32 dump_phase_ms = 1;
    // ms to wait between following dumps.
    optional uint32 dump_interval_ms = 2;
    // If true, scans all the processes to find `process_cmdline` and filter by
    // `min_anonymous_memory_kb` only at data source start. Default on Android
    // S-.
    //
    // If false, rescans all the processes to find on every dump. Default on
    // Android T+.
    optional bool scan_pids_only_on_start = 3;
  }

  // Command line allowlist, matched against the /proc/<pid>/cmdline (not the
  // comm string). The semantics of this field were changed since its original
  // introduction.
  //
  // On Android T+ (13+), this field can specify a single wildcard (*), and
  // the profiler will attempt to match it in two possible ways:
  // * if the pattern starts with a '/', then it is matched against the first
  //   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
  //   "/bin/echo".
  // * otherwise the pattern is matched against the part of argv0
  //   corresponding to the binary name (this is unrelated to /proc/pid/exe).
  //   For example "echo" would match "/bin/echo".
  //
  // On Android S (12) and below, both this pattern and /proc/pid/cmdline get
  // normalized prior to an exact string comparison. Normalization is as
  // follows: (1) trim everything beyond the first null or "@" byte; (2) if
  // the string contains forward slashes, trim everything up to and including
  // the last one.
  //
  // Implementation note: in either case, at most 511 characters of cmdline
  // are considered.
  repeated string process_cmdline = 1;

  // For watermark based triggering or local debugging.
  repeated uint64 pid = 2;

  // Only profile target if it was installed by one of the packages given.
  // Special values are:
  // * @system: installed on the system partition
  // * @product: installed on the product partition
  // * @null: sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 7;

  // Dump at a predefined interval.
  optional ContinuousDumpConfig continuous_dump_config = 3;

  // Do not profile processes whose anon RSS + swap < given value.
  optional uint32 min_anonymous_memory_kb = 4;

  // Include the process' /proc/self/smaps.
  // This only shows maps that:
  // * start with /system
  // * start with /vendor
  // * start with /data/app
  // * contain "extracted in memory from Y", where Y matches any of the above
  optional bool dump_smaps = 5;

  // Exclude objects of the following types from the profile. This can be
  // useful if lots of uninteresting objects, e.g. "sun.misc.Cleaner".
  repeated string ignored_types = 6;
}

// End of protos/perfetto/config/profiling/java_hprof_config.proto

// Begin of protos/perfetto/common/perf_events.proto

message PerfEvents {
  // The primary event to count. If recording multiple events, this
  // counter is the "group leader".
  // Commented from the perspective of its use in |PerfEventConfig|.
  // Next id: 13
  message Timebase {
    // How often to snapshot the counter, along with any follower events and
    // any additional sampled data such as callstacks.
    //
    // This choice also controls how the readings are taken:
    // * With |frequency| or |period|, samples are taken by the kernel
    //   into a ring buffer. Analogous to `perf record`.
    // * With |poll_period_ms|, the userspace periodically snapshots
    //   the counters using the read syscall. Analogous to `perf stat -I`.
    // Prefer the sampling options unless you're recording PMUs whose
    // perf drivers only support the reading mode.
    //
    // If unset, an implementation-defined sampling default is used.
    oneof interval {
      // Per-cpu sampling frequency in Hz, as requested from the kernel. Not the
      // same as 1/period.
      // Details: the actual sampling will still be based on a period, but the
      // kernel will dynamically adjust it based on the observed event rate, to
      // approximate this frequency. Works best with steady-rate events like
      // timers.
      // Not guaranteed to be honored as the kernel can throttle the sampling
      // rate if it's too high.
      uint64 frequency = 2;

      // Per-cpu sampling will occur every |period| counts of |event|.
      // Prefer |frequency| by default, as it's easier to oversample with a
      // fixed period.
      // Not guaranteed to be honored as the kernel can throttle the sampling
      // rate if it's too high.
      uint64 period = 1;

      // Per-cpu values are read by the userspace every interval. If using this
      // mode, only follower events are supported. Options such as
      // |PerfEventConfig.CallstackSampling| are incompatible.
      // The period can't be guaranteed to be exact since the readings are taken
      // by userspace.
      uint32 poll_period_ms = 6;
    }

    // Counting event to use as the timebase.
    // If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
    // which is what you usually want.
    oneof event {
      Counter counter = 4;
      Tracepoint tracepoint = 3;
      RawEvent raw_event = 5;
    }

    // Optional modifiers for the event. Modelled after the perftool's
    // https://man7.org/linux/man-pages/man1/perf-list.1.html#EVENT_MODIFIERS
    // Currently supported: count scoping such as :u, :k, :uk, ...
    // Modifiers can differ between the timebase and followers.
    repeated EventModifier modifiers = 12;

    // If set, samples will be timestamped with the given clock.
    // If unset, the clock is chosen by the implementation.
    // For software events, prefer PERF_CLOCK_BOOTTIME. However it cannot be
    // used for hardware events (due to interrupt safety), for which the
    // recommendation is to use one of the monotonic clocks.
    optional PerfClock timestamp_clock = 11;

    // Optional arbitrary name for the event, to identify it in the parsed
    // trace. Does *not* affect the profiling itself. If unset, the trace
    // parser will choose a suitable name.
    optional string name = 10;
  }

  // Builtin counter names from the uapi header. Commented with their perf tool
  // aliases.
  // TODO(rsavitski): consider generating enums for cache events (should be
  // finite), and generally make this list as extensive as possible. Excluding
  // things like dynamic PMUs since those don't fit into a static enum.
  // Next id: 21
  enum Counter {
    UNKNOWN_COUNTER = 0;

    // cpu-clock
    SW_CPU_CLOCK = 1;
    // page-faults, faults
    SW_PAGE_FAULTS = 2;
    // task-clock
    SW_TASK_CLOCK = 3;
    // context-switches, cs
    SW_CONTEXT_SWITCHES = 4;
    // cpu-migrations, migrations
    SW_CPU_MIGRATIONS = 5;
    // minor-faults
    SW_PAGE_FAULTS_MIN = 6;
    // major-faults
    SW_PAGE_FAULTS_MAJ = 7;
    // alignment-faults
    SW_ALIGNMENT_FAULTS = 8;
    // emulation-faults
    SW_EMULATION_FAULTS = 9;
    // dummy
    SW_DUMMY = 20;

    // cpu-cycles, cycles
    HW_CPU_CYCLES = 10;
    // instructions
    HW_INSTRUCTIONS = 11;
    // cache-references
    HW_CACHE_REFERENCES = 12;
    // cache-misses
    HW_CACHE_MISSES = 13;
    // branch-instructions, branches
    HW_BRANCH_INSTRUCTIONS = 14;
    // branch-misses
    HW_BRANCH_MISSES = 15;
    // bus-cycles
    HW_BUS_CYCLES = 16;
    // stalled-cycles-frontend, idle-cycles-frontend
    HW_STALLED_CYCLES_FRONTEND = 17;
    // stalled-cycles-backend, idle-cycles-backend
    HW_STALLED_CYCLES_BACKEND = 18;
    // ref-cycles
    HW_REF_CPU_CYCLES = 19;
  }

  message Tracepoint {
    // Group and name for the tracepoint, acceptable forms:
    // * "sched/sched_switch"
    // * "sched:sched_switch"
    optional string name = 1;

    // Optional field-level filter for the tracepoint. Only events matching this
    // filter will be counted (and therefore contribute to the sampling period).
    // Example: "prev_pid >= 42 && next_pid == 0".
    // For full syntax, see kernel documentation on "Event filtering":
    // https://www.kernel.org/doc/Documentation/trace/events.txt
    optional string filter = 2;
  }

  // Syscall-level description of the event, propagated to the perf_event_attr
  // struct. Primarily for local use-cases, since the event availability and
  // encoding is hardware-specific.
  message RawEvent {
    optional uint32 type = 1;
    optional uint64 config = 2;
    optional uint64 config1 = 3;
    optional uint64 config2 = 4;
  }

  // Subset of clocks that is supported by perf timestamping.
  // CLOCK_TAI is excluded since it's not expected to be used in practice, but
  // would require additions to the trace clock synchronisation logic.
  enum PerfClock {
    UNKNOWN_PERF_CLOCK = 0;
    PERF_CLOCK_REALTIME = 1;
    PERF_CLOCK_MONOTONIC = 2;
    PERF_CLOCK_MONOTONIC_RAW = 3;
    PERF_CLOCK_BOOTTIME = 4;
  }

  enum EventModifier {
    UNKNOWN_EVENT_MODIFIER = 0;
    // count only while in userspace
    EVENT_MODIFIER_COUNT_USERSPACE = 1;
    // count only while in kernel
    EVENT_MODIFIER_COUNT_KERNEL = 2;
    // count only while in hypervisor
    EVENT_MODIFIER_COUNT_HYPERVISOR = 3;
  }
}

// Additional events associated with a leader.
// See https://man7.org/linux/man-pages/man1/perf-list.1.html#LEADER_SAMPLING
message FollowerEvent {
  oneof event {
    PerfEvents.Counter counter = 1;
    PerfEvents.Tracepoint tracepoint = 2;
    PerfEvents.RawEvent raw_event = 3;
  }
  // Modifiers can differ between the timebase and followers.
  repeated PerfEvents.EventModifier modifiers = 5;
  // Optional arbitrary name for the event, to identify it in the parsed
  // trace. Does *not* affect the profiling itself. If unset, the trace
  // parser will choose a suitable name.
  optional string name = 4;
}

// End of protos/perfetto/common/perf_events.proto

// Begin of protos/perfetto/config/profiling/perf_event_config.proto

// Configuration for the traced_perf profiler.
//
// Example config for basic cpu profiling:
//   perf_event_config {
//     timebase {
//       frequency: 80
//     }
//     callstack_sampling {
//       scope {
//         target_cmdline: "surfaceflinger"
//         target_cmdline: "system_server"
//       }
//       kernel_frames: true
//     }
//   }
//
// Next id: 21
message PerfEventConfig {
  // What event to sample on, and how often.
  // Defined in common/perf_events.proto.
  optional PerfEvents.Timebase timebase = 15;

  // Other events associated with the leader described in the timebase.
  repeated FollowerEvent followers = 19;

  // If set, the profiler will sample userspace processes' callstacks at the
  // interval specified by the |timebase|.
  // If unset, the profiler will record only the event counts.
  optional CallstackSampling callstack_sampling = 16;

  // List of cpu indices for counting. If empty, the default is all cpus.
  //
  // Note: this is not inside |callstack_sampling.scope| as it also applies to
  // counter-only traces. A future change will likely reorganise the options,
  // but this field will continue to be supported.
  //
  // Available since: perfetto v50.
  repeated uint32 target_cpu = 20;

  //
  // Kernel <-> userspace ring buffer options:
  //

  // How often the per-cpu ring buffers are read by the producer.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_read_period_ms = 8;

  // Size (in 4k pages) of each per-cpu ring buffer that is filled by the
  // kernel. If set, must be a power of two.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_pages = 3;

  //
  // Daemon's resource usage limits:
  //

  // Drop samples if the heap memory held by the samples in the unwinder queue
  // is above the given limit. This counts the memory across all concurrent data
  // sources (not just this one's), and there is no fairness guarantee - the
  // whole quota might be used up by a concurrent source.
  optional uint64 max_enqueued_footprint_kb = 17;

  // Stop the data source if traced_perf's combined {RssAnon + Swap} memory
  // footprint exceeds this value.
  optional uint32 max_daemon_memory_kb = 13;

  //
  // Niche options:
  //

  // Timeout for the remote /proc/<pid>/{maps,mem} file descriptors for a
  // sampled process. This is primarily for Android, where this lookup is
  // asynchronous. As long as the producer is waiting, the associated samples
  // will be kept enqueued (putting pressure on the capacity of the shared
  // unwinding queue). Once a lookup for a process expires, all associated
  // samples are discarded. However, if the lookup still succeeds after the
  // timeout, future samples will be handled normally.
  // If unset, an implementation-defined default is used.
  optional uint32 remote_descriptor_timeout_ms = 9;

  // Optional period for clearing state cached by the userspace unwinder. This
  // is a heavy operation that is only necessary for traces that target a wide
  // set of processes, and require the memory footprint to be reset
  // periodically. To effectively disable the cache clearing, set to a value
  // greater than your trace duration.
  //
  // Relevant only if |callstack_sampling.user_frames| is set to UNWIND_DWARF.
  //
  // If zero or unset:
  // * before perfetto v52: no cache clearing.
  // * perfetto v52+: implementation chooses an infrequent default.
  optional uint32 unwind_state_clear_period_ms = 10;

  // If set, only profile target if it was installed by a package with one of
  // these names. Special values:
  // * "@system": installed on the system partition
  // * "@product": installed on the product partition
  // * "@null": sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 18;

  //
  // Deprecated (superseded by options above):
  //
  // Do not set *any* of these fields in new configs.
  //

  // Note: legacy configs had to set |all_cpus| to true to pass parsing.
  // We rely on this to detect such configs.
  optional bool all_cpus = 1;
  optional uint32 sampling_frequency = 2;
  optional bool kernel_frames = 12;
  repeated int32 target_pid = 4;
  repeated string target_cmdline = 5;
  repeated int32 exclude_pid = 6;
  repeated string exclude_cmdline = 7;
  optional uint32 additional_cmdline_count = 11;
  // previously |tracepoint|
  reserved 14;

  //
  // Sub-messages (nested for generated code namespacing).
  //

  message CallstackSampling {
    // Defines a set of processes for which samples are retained/skipped. If
    // unset, all samples are kept, but beware that it will be very heavy on the
    // stack unwinder, which might start dropping samples due to overload.
    optional Scope scope = 1;

    // If true, callstacks will include the kernel-space frames. Such frames can
    // be identified by a magical "kernel" string as their mapping name.
    // Requires traced_perf to be running as root, or kptr_restrict to have been
    // manually unrestricted. On Android, the platform should do the right thing
    // on debug builds.
    // This does *not* disclose KASLR, as only the function names are emitted.
    optional bool kernel_frames = 2;

    // Whether to record and unwind userspace callstacks. If unset, defaults to
    // including userspace (UNWIND_DWARF) both for backwards compatibility and
    // as the most common default (this defaulting is only applicable if the
    // outer CallstackSampling message is explicitly set).
    optional UnwindMode user_frames = 3;
  }

  message Scope {
    // Process ID (TGID) allowlist. If this list is not empty, only matching
    // samples will be retained. If multiple allow/deny-lists are
    // specified by the config, then all of them are evaluated for each sampled
    // process.
    repeated int32 target_pid = 1;

    // Command line allowlist, matched against the /proc/<pid>/cmdline (not the
    // comm string). The semantics of this field were changed since its original
    // introduction.
    //
    // On Android T+ (13+), this field can specify a single wildcard (*), and
    // the profiler will attempt to match it in two possible ways:
    // * if the pattern starts with a '/', then it is matched against the first
    //   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
    //   "/bin/echo".
    // * otherwise the pattern is matched against the part of argv0
    //   corresponding to the binary name (this is unrelated to /proc/pid/exe).
    //   For example "echo" would match "/bin/echo".
    //
    // On Android S (12) and below, both this pattern and /proc/pid/cmdline get
    // normalized prior to an exact string comparison. Normalization is as
    // follows: (1) trim everything beyond the first null or "@" byte; (2) if
    // the string contains forward slashes, trim everything up to and including
    // the last one.
    //
    // Implementation note: in either case, at most 511 characters of cmdline
    // are considered.
    repeated string target_cmdline = 2;

    // List of excluded pids.
    repeated int32 exclude_pid = 3;

    // List of excluded cmdlines. See description of |target_cmdline| for how
    // this is handled.
    repeated string exclude_cmdline = 4;

    // Niche features for systemwide callstacks:

    // Number of additional command lines to sample. Only those which are
    // neither explicitly included nor excluded will be considered. Processes
    // are accepted on a first come, first served basis.
    optional uint32 additional_cmdline_count = 5;

    // If set to N, all encountered processes will be put into one of the N
    // possible bins, and only one randomly-chosen bin will be selected for
    // unwinding. The binning is simply "pid % N", under the assumption that
    // low-order bits of pids are roughly uniformly distributed. Other explicit
    // inclusions/exclusions in this |Scope| message are still respected.
    //
    // The profiler will report the chosen shard in PerfSampleDefaults, and the
    // values will be queryable in trace processor under the "stats" table as
    // "perf_process_shard_count" and "perf_chosen_process_shard".
    //
    // NB: all data sources in a config that set |process_shard_count| must set
    // it to the same value. The profiler will choose one bin for all those data
    // sources.
    optional uint32 process_shard_count = 6;
  }

  // Userspace unwinding mode. A possible future addition is kernel-unwound
  // callchains for frame pointer based systems.
  enum UnwindMode {
    UNWIND_UNKNOWN = 0;
    // Do not unwind userspace:
    UNWIND_SKIP = 1;
    // Use libunwindstack (default):
    UNWIND_DWARF = 2;
    // Use userspace frame pointer unwinder:
    UNWIND_FRAME_POINTER = 3;
  }
}

// End of protos/perfetto/config/profiling/perf_event_config.proto

// Begin of protos/perfetto/config/statsd/atom_ids.proto

// This enum is obtained by post-processing
// AOSP/frameworks/proto_logging/stats/atoms.proto through
// AOSP/external/perfetto/tools/update-statsd-descriptor, which extracts one
// enum value for each proto field defined in the upstream atoms.proto.
enum AtomId {
  ATOM_UNSPECIFIED = 0;
  ATOM_BLE_SCAN_STATE_CHANGED = 2;
  ATOM_PROCESS_STATE_CHANGED = 3;
  ATOM_BLE_SCAN_RESULT_RECEIVED = 4;
  ATOM_SENSOR_STATE_CHANGED = 5;
  ATOM_GPS_SCAN_STATE_CHANGED = 6;
  ATOM_SYNC_STATE_CHANGED = 7;
  ATOM_SCHEDULED_JOB_STATE_CHANGED = 8;
  ATOM_SCREEN_BRIGHTNESS_CHANGED = 9;
  ATOM_WAKELOCK_STATE_CHANGED = 10;
  ATOM_LONG_PARTIAL_WAKELOCK_STATE_CHANGED = 11;
  ATOM_MOBILE_RADIO_POWER_STATE_CHANGED = 12;
  ATOM_WIFI_RADIO_POWER_STATE_CHANGED = 13;
  ATOM_ACTIVITY_MANAGER_SLEEP_STATE_CHANGED = 14;
  ATOM_MEMORY_FACTOR_STATE_CHANGED = 15;
  ATOM_EXCESSIVE_CPU_USAGE_REPORTED = 16;
  ATOM_CACHED_KILL_REPORTED = 17;
  ATOM_PROCESS_MEMORY_STAT_REPORTED = 18;
  ATOM_LAUNCHER_EVENT = 19;
  ATOM_BATTERY_SAVER_MODE_STATE_CHANGED = 20;
  ATOM_DEVICE_IDLE_MODE_STATE_CHANGED = 21;
  ATOM_DEVICE_IDLING_MODE_STATE_CHANGED = 22;
  ATOM_AUDIO_STATE_CHANGED = 23;
  ATOM_MEDIA_CODEC_STATE_CHANGED = 24;
  ATOM_CAMERA_STATE_CHANGED = 25;
  ATOM_FLASHLIGHT_STATE_CHANGED = 26;
  ATOM_UID_PROCESS_STATE_CHANGED = 27;
  ATOM_PROCESS_LIFE_CYCLE_STATE_CHANGED = 28;
  ATOM_SCREEN_STATE_CHANGED = 29;
  ATOM_BATTERY_LEVEL_CHANGED = 30;
  ATOM_CHARGING_STATE_CHANGED = 31;
  ATOM_PLUGGED_STATE_CHANGED = 32;
  ATOM_INTERACTIVE_STATE_CHANGED = 33;
  ATOM_TOUCH_EVENT_REPORTED = 34;
  ATOM_WAKEUP_ALARM_OCCURRED = 35;
  ATOM_KERNEL_WAKEUP_REPORTED = 36;
  ATOM_WIFI_LOCK_STATE_CHANGED = 37;
  ATOM_WIFI_SIGNAL_STRENGTH_CHANGED = 38;
  ATOM_WIFI_SCAN_STATE_CHANGED = 39;
  ATOM_PHONE_SIGNAL_STRENGTH_CHANGED = 40;
  ATOM_SETTING_CHANGED = 41;
  ATOM_ACTIVITY_FOREGROUND_STATE_CHANGED = 42;
  ATOM_ISOLATED_UID_CHANGED = 43;
  ATOM_PACKET_WAKEUP_OCCURRED = 44;
  ATOM_WALL_CLOCK_TIME_SHIFTED = 45;
  ATOM_ANOMALY_DETECTED = 46;
  ATOM_APP_BREADCRUMB_REPORTED = 47;
  ATOM_APP_START_OCCURRED = 48;
  ATOM_APP_START_CANCELED = 49;
  ATOM_APP_START_FULLY_DRAWN = 50;
  ATOM_LMK_KILL_OCCURRED = 51;
  ATOM_PICTURE_IN_PICTURE_STATE_CHANGED = 52;
  ATOM_WIFI_MULTICAST_LOCK_STATE_CHANGED = 53;
  ATOM_APP_START_MEMORY_STATE_CAPTURED = 55;
  ATOM_SHUTDOWN_SEQUENCE_REPORTED = 56;
  ATOM_BOOT_SEQUENCE_REPORTED = 57;
  ATOM_OVERLAY_STATE_CHANGED = 59;
  ATOM_FOREGROUND_SERVICE_STATE_CHANGED = 60;
  ATOM_CALL_STATE_CHANGED = 61;
  ATOM_KEYGUARD_STATE_CHANGED = 62;
  ATOM_KEYGUARD_BOUNCER_STATE_CHANGED = 63;
  ATOM_KEYGUARD_BOUNCER_PASSWORD_ENTERED = 64;
  ATOM_APP_DIED = 65;
  ATOM_RESOURCE_CONFIGURATION_CHANGED = 66;
  ATOM_BLUETOOTH_ENABLED_STATE_CHANGED = 67;
  ATOM_BLUETOOTH_CONNECTION_STATE_CHANGED = 68;
  ATOM_GPS_SIGNAL_QUALITY_CHANGED = 69;
  ATOM_USB_CONNECTOR_STATE_CHANGED = 70;
  ATOM_SPEAKER_IMPEDANCE_REPORTED = 71;
  ATOM_HARDWARE_FAILED = 72;
  ATOM_PHYSICAL_DROP_DETECTED = 73;
  ATOM_CHARGE_CYCLES_REPORTED = 74;
  ATOM_MOBILE_CONNECTION_STATE_CHANGED = 75;
  ATOM_MOBILE_RADIO_TECHNOLOGY_CHANGED = 76;
  ATOM_USB_DEVICE_ATTACHED = 77;
  ATOM_APP_CRASH_OCCURRED = 78;
  ATOM_ANR_OCCURRED = 79;
  ATOM_WTF_OCCURRED = 80;
  ATOM_LOW_MEM_REPORTED = 81;
  ATOM_GENERIC_ATOM = 82;
  ATOM_VIBRATOR_STATE_CHANGED = 84;
  ATOM_DEFERRED_JOB_STATS_REPORTED = 85;
  ATOM_THERMAL_THROTTLING = 86;
  ATOM_BIOMETRIC_ACQUIRED = 87;
  ATOM_BIOMETRIC_AUTHENTICATED = 88;
  ATOM_BIOMETRIC_ERROR_OCCURRED = 89;
  ATOM_UI_EVENT_REPORTED = 90;
  ATOM_BATTERY_HEALTH_SNAPSHOT = 91;
  ATOM_SLOW_IO = 92;
  ATOM_BATTERY_CAUSED_SHUTDOWN = 93;
  ATOM_PHONE_SERVICE_STATE_CHANGED = 94;
  ATOM_PHONE_STATE_CHANGED = 95;
  ATOM_USER_RESTRICTION_CHANGED = 96;
  ATOM_SETTINGS_UI_CHANGED = 97;
  ATOM_CONNECTIVITY_STATE_CHANGED = 98;
  ATOM_SERVICE_STATE_CHANGED = 99;
  ATOM_SERVICE_LAUNCH_REPORTED = 100;
  ATOM_FLAG_FLIP_UPDATE_OCCURRED = 101;
  ATOM_BINARY_PUSH_STATE_CHANGED = 102;
  ATOM_DEVICE_POLICY_EVENT = 103;
  ATOM_DOCS_UI_FILE_OP_CANCELED = 104;
  ATOM_DOCS_UI_FILE_OP_COPY_MOVE_MODE_REPORTED = 105;
  ATOM_DOCS_UI_FILE_OP_FAILURE = 106;
  ATOM_DOCS_UI_PROVIDER_FILE_OP = 107;
  ATOM_DOCS_UI_INVALID_SCOPED_ACCESS_REQUEST = 108;
  ATOM_DOCS_UI_LAUNCH_REPORTED = 109;
  ATOM_DOCS_UI_ROOT_VISITED = 110;
  ATOM_DOCS_UI_STARTUP_MS = 111;
  ATOM_DOCS_UI_USER_ACTION_REPORTED = 112;
  ATOM_WIFI_ENABLED_STATE_CHANGED = 113;
  ATOM_WIFI_RUNNING_STATE_CHANGED = 114;
  ATOM_APP_COMPACTED = 115;
  ATOM_NETWORK_DNS_EVENT_REPORTED = 116;
  ATOM_DOCS_UI_PICKER_LAUNCHED_FROM_REPORTED = 117;
  ATOM_DOCS_UI_PICK_RESULT_REPORTED = 118;
  ATOM_DOCS_UI_SEARCH_MODE_REPORTED = 119;
  ATOM_DOCS_UI_SEARCH_TYPE_REPORTED = 120;
  ATOM_DATA_STALL_EVENT = 121;
  ATOM_RESCUE_PARTY_RESET_REPORTED = 122;
  ATOM_SIGNED_CONFIG_REPORTED = 123;
  ATOM_GNSS_NI_EVENT_REPORTED = 124;
  ATOM_BLUETOOTH_LINK_LAYER_CONNECTION_EVENT = 125;
  ATOM_BLUETOOTH_ACL_CONNECTION_STATE_CHANGED = 126;
  ATOM_BLUETOOTH_SCO_CONNECTION_STATE_CHANGED = 127;
  ATOM_APP_DOWNGRADED = 128;
  ATOM_APP_OPTIMIZED_AFTER_DOWNGRADED = 129;
  ATOM_LOW_STORAGE_STATE_CHANGED = 130;
  ATOM_GNSS_NFW_NOTIFICATION_REPORTED = 131;
  ATOM_GNSS_CONFIGURATION_REPORTED = 132;
  ATOM_USB_PORT_OVERHEAT_EVENT_REPORTED = 133;
  ATOM_NFC_ERROR_OCCURRED = 134;
  ATOM_NFC_STATE_CHANGED = 135;
  ATOM_NFC_BEAM_OCCURRED = 136;
  ATOM_NFC_CARDEMULATION_OCCURRED = 137;
  ATOM_NFC_TAG_OCCURRED = 138;
  ATOM_NFC_HCE_TRANSACTION_OCCURRED = 139;
  ATOM_SE_STATE_CHANGED = 140;
  ATOM_SE_OMAPI_REPORTED = 141;
  ATOM_BROADCAST_DISPATCH_LATENCY_REPORTED = 142;
  ATOM_ATTENTION_MANAGER_SERVICE_RESULT_REPORTED = 143;
  ATOM_ADB_CONNECTION_CHANGED = 144;
  ATOM_SPEECH_DSP_STAT_REPORTED = 145;
  ATOM_USB_CONTAMINANT_REPORTED = 146;
  ATOM_WATCHDOG_ROLLBACK_OCCURRED = 147;
  ATOM_BIOMETRIC_SYSTEM_HEALTH_ISSUE_DETECTED = 148;
  ATOM_BUBBLE_UI_CHANGED = 149;
  ATOM_SCHEDULED_JOB_CONSTRAINT_CHANGED = 150;
  ATOM_BLUETOOTH_ACTIVE_DEVICE_CHANGED = 151;
  ATOM_BLUETOOTH_A2DP_PLAYBACK_STATE_CHANGED = 152;
  ATOM_BLUETOOTH_A2DP_CODEC_CONFIG_CHANGED = 153;
  ATOM_BLUETOOTH_A2DP_CODEC_CAPABILITY_CHANGED = 154;
  ATOM_BLUETOOTH_A2DP_AUDIO_UNDERRUN_REPORTED = 155;
  ATOM_BLUETOOTH_A2DP_AUDIO_OVERRUN_REPORTED = 156;
  ATOM_BLUETOOTH_DEVICE_RSSI_REPORTED = 157;
  ATOM_BLUETOOTH_DEVICE_FAILED_CONTACT_COUNTER_REPORTED = 158;
  ATOM_BLUETOOTH_DEVICE_TX_POWER_LEVEL_REPORTED = 159;
  ATOM_BLUETOOTH_HCI_TIMEOUT_REPORTED = 160;
  ATOM_BLUETOOTH_QUALITY_REPORT_REPORTED = 161;
  ATOM_BLUETOOTH_DEVICE_INFO_REPORTED = 162;
  ATOM_BLUETOOTH_REMOTE_VERSION_INFO_REPORTED = 163;
  ATOM_BLUETOOTH_SDP_ATTRIBUTE_REPORTED = 164;
  ATOM_BLUETOOTH_BOND_STATE_CHANGED = 165;
  ATOM_BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED = 166;
  ATOM_BLUETOOTH_SMP_PAIRING_EVENT_REPORTED = 167;
  ATOM_SCREEN_TIMEOUT_EXTENSION_REPORTED = 168;
  ATOM_PROCESS_START_TIME = 169;
  ATOM_PERMISSION_GRANT_REQUEST_RESULT_REPORTED = 170;
  ATOM_BLUETOOTH_SOCKET_CONNECTION_STATE_CHANGED = 171;
  ATOM_DEVICE_IDENTIFIER_ACCESS_DENIED = 172;
  ATOM_BUBBLE_DEVELOPER_ERROR_REPORTED = 173;
  ATOM_ASSIST_GESTURE_STAGE_REPORTED = 174;
  ATOM_ASSIST_GESTURE_FEEDBACK_REPORTED = 175;
  ATOM_ASSIST_GESTURE_PROGRESS_REPORTED = 176;
  ATOM_TOUCH_GESTURE_CLASSIFIED = 177;
  ATOM_HIDDEN_API_USED = 178;
  ATOM_STYLE_UI_CHANGED = 179;
  ATOM_PRIVACY_INDICATORS_INTERACTED = 180;
  ATOM_APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED = 181;
  ATOM_NETWORK_STACK_REPORTED = 182;
  ATOM_APP_MOVED_STORAGE_REPORTED = 183;
  ATOM_BIOMETRIC_ENROLLED = 184;
  ATOM_SYSTEM_SERVER_WATCHDOG_OCCURRED = 185;
  ATOM_TOMB_STONE_OCCURRED = 186;
  ATOM_BLUETOOTH_CLASS_OF_DEVICE_REPORTED = 187;
  ATOM_INTELLIGENCE_EVENT_REPORTED = 188;
  ATOM_THERMAL_THROTTLING_SEVERITY_STATE_CHANGED = 189;
  ATOM_ROLE_REQUEST_RESULT_REPORTED = 190;
  ATOM_MEDIAMETRICS_AUDIOPOLICY_REPORTED = 191;
  ATOM_MEDIAMETRICS_AUDIORECORD_REPORTED = 192;
  ATOM_MEDIAMETRICS_AUDIOTHREAD_REPORTED = 193;
  ATOM_MEDIAMETRICS_AUDIOTRACK_REPORTED = 194;
  ATOM_MEDIAMETRICS_CODEC_REPORTED = 195;
  ATOM_MEDIAMETRICS_DRM_WIDEVINE_REPORTED = 196;
  ATOM_MEDIAMETRICS_EXTRACTOR_REPORTED = 197;
  ATOM_MEDIAMETRICS_MEDIADRM_REPORTED = 198;
  ATOM_MEDIAMETRICS_NUPLAYER_REPORTED = 199;
  ATOM_MEDIAMETRICS_RECORDER_REPORTED = 200;
  ATOM_MEDIAMETRICS_DRMMANAGER_REPORTED = 201;
  ATOM_CAR_POWER_STATE_CHANGED = 203;
  ATOM_GARAGE_MODE_INFO = 204;
  ATOM_TEST_ATOM_REPORTED = 205;
  ATOM_CONTENT_CAPTURE_CALLER_MISMATCH_REPORTED = 206;
  ATOM_CONTENT_CAPTURE_SERVICE_EVENTS = 207;
  ATOM_CONTENT_CAPTURE_SESSION_EVENTS = 208;
  ATOM_CONTENT_CAPTURE_FLUSHED = 209;
  ATOM_LOCATION_MANAGER_API_USAGE_REPORTED = 210;
  ATOM_REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED = 211;
  ATOM_RUNTIME_PERMISSIONS_UPGRADE_RESULT = 212;
  ATOM_GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS = 213;
  ATOM_LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION = 214;
  ATOM_APP_PERMISSION_FRAGMENT_ACTION_REPORTED = 215;
  ATOM_APP_PERMISSION_FRAGMENT_VIEWED = 216;
  ATOM_APP_PERMISSIONS_FRAGMENT_VIEWED = 217;
  ATOM_PERMISSION_APPS_FRAGMENT_VIEWED = 218;
  ATOM_TEXT_SELECTION_EVENT = 219;
  ATOM_TEXT_LINKIFY_EVENT = 220;
  ATOM_CONVERSATION_ACTIONS_EVENT = 221;
  ATOM_LANGUAGE_DETECTION_EVENT = 222;
  ATOM_EXCLUSION_RECT_STATE_CHANGED = 223;
  ATOM_BACK_GESTURE_REPORTED_REPORTED = 224;
  ATOM_UPDATE_ENGINE_UPDATE_ATTEMPT_REPORTED = 225;
  ATOM_UPDATE_ENGINE_SUCCESSFUL_UPDATE_REPORTED = 226;
  ATOM_CAMERA_ACTION_EVENT = 227;
  ATOM_APP_COMPATIBILITY_CHANGE_REPORTED = 228;
  ATOM_PERFETTO_UPLOADED = 229;
  ATOM_VMS_CLIENT_CONNECTION_STATE_CHANGED = 230;
  ATOM_MEDIA_PROVIDER_SCAN_OCCURRED = 233;
  ATOM_MEDIA_CONTENT_DELETED = 234;
  ATOM_MEDIA_PROVIDER_PERMISSION_REQUESTED = 235;
  ATOM_MEDIA_PROVIDER_SCHEMA_CHANGED = 236;
  ATOM_MEDIA_PROVIDER_IDLE_MAINTENANCE_FINISHED = 237;
  ATOM_REBOOT_ESCROW_RECOVERY_REPORTED = 238;
  ATOM_BOOT_TIME_EVENT_DURATION_REPORTED = 239;
  ATOM_BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED = 240;
  ATOM_BOOT_TIME_EVENT_UTC_TIME_REPORTED = 241;
  ATOM_BOOT_TIME_EVENT_ERROR_CODE_REPORTED = 242;
  ATOM_USERSPACE_REBOOT_REPORTED = 243;
  ATOM_NOTIFICATION_REPORTED = 244;
  ATOM_NOTIFICATION_PANEL_REPORTED = 245;
  ATOM_NOTIFICATION_CHANNEL_MODIFIED = 246;
  ATOM_INTEGRITY_CHECK_RESULT_REPORTED = 247;
  ATOM_INTEGRITY_RULES_PUSHED = 248;
  ATOM_CB_MESSAGE_REPORTED = 249;
  ATOM_CB_MESSAGE_ERROR = 250;
  ATOM_WIFI_HEALTH_STAT_REPORTED = 251;
  ATOM_WIFI_FAILURE_STAT_REPORTED = 252;
  ATOM_WIFI_CONNECTION_RESULT_REPORTED = 253;
  ATOM_APP_FREEZE_CHANGED = 254;
  ATOM_SNAPSHOT_MERGE_REPORTED = 255;
  ATOM_FOREGROUND_SERVICE_APP_OP_SESSION_ENDED = 256;
  ATOM_DISPLAY_JANK_REPORTED = 257;
  ATOM_APP_STANDBY_BUCKET_CHANGED = 258;
  ATOM_SHARESHEET_STARTED = 259;
  ATOM_RANKING_SELECTED = 260;
  ATOM_TVSETTINGS_UI_INTERACTED = 261;
  ATOM_LAUNCHER_SNAPSHOT = 262;
  ATOM_PACKAGE_INSTALLER_V2_REPORTED = 263;
  ATOM_USER_LIFECYCLE_JOURNEY_REPORTED = 264;
  ATOM_USER_LIFECYCLE_EVENT_OCCURRED = 265;
  ATOM_ACCESSIBILITY_SHORTCUT_REPORTED = 266;
  ATOM_ACCESSIBILITY_SERVICE_REPORTED = 267;
  ATOM_DOCS_UI_DRAG_AND_DROP_REPORTED = 268;
  ATOM_APP_USAGE_EVENT_OCCURRED = 269;
  ATOM_AUTO_REVOKE_NOTIFICATION_CLICKED = 270;
  ATOM_AUTO_REVOKE_FRAGMENT_APP_VIEWED = 271;
  ATOM_AUTO_REVOKED_APP_INTERACTION = 272;
  ATOM_APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION = 273;
  ATOM_EVS_USAGE_STATS_REPORTED = 274;
  ATOM_AUDIO_POWER_USAGE_DATA_REPORTED = 275;
  ATOM_TV_TUNER_STATE_CHANGED = 276;
  ATOM_MEDIAOUTPUT_OP_SWITCH_REPORTED = 277;
  ATOM_CB_MESSAGE_FILTERED = 278;
  ATOM_TV_TUNER_DVR_STATUS = 279;
  ATOM_TV_CAS_SESSION_OPEN_STATUS = 280;
  ATOM_ASSISTANT_INVOCATION_REPORTED = 281;
  ATOM_DISPLAY_WAKE_REPORTED = 282;
  ATOM_CAR_USER_HAL_MODIFY_USER_REQUEST_REPORTED = 283;
  ATOM_CAR_USER_HAL_MODIFY_USER_RESPONSE_REPORTED = 284;
  ATOM_CAR_USER_HAL_POST_SWITCH_RESPONSE_REPORTED = 285;
  ATOM_CAR_USER_HAL_INITIAL_USER_INFO_REQUEST_REPORTED = 286;
  ATOM_CAR_USER_HAL_INITIAL_USER_INFO_RESPONSE_REPORTED = 287;
  ATOM_CAR_USER_HAL_USER_ASSOCIATION_REQUEST_REPORTED = 288;
  ATOM_CAR_USER_HAL_SET_USER_ASSOCIATION_RESPONSE_REPORTED = 289;
  ATOM_NETWORK_IP_PROVISIONING_REPORTED = 290;
  ATOM_NETWORK_DHCP_RENEW_REPORTED = 291;
  ATOM_NETWORK_VALIDATION_REPORTED = 292;
  ATOM_NETWORK_STACK_QUIRK_REPORTED = 293;
  ATOM_MEDIAMETRICS_AUDIORECORDDEVICEUSAGE_REPORTED = 294;
  ATOM_MEDIAMETRICS_AUDIOTHREADDEVICEUSAGE_REPORTED = 295;
  ATOM_MEDIAMETRICS_AUDIOTRACKDEVICEUSAGE_REPORTED = 296;
  ATOM_MEDIAMETRICS_AUDIODEVICECONNECTION_REPORTED = 297;
  ATOM_BLOB_COMMITTED = 298;
  ATOM_BLOB_LEASED = 299;
  ATOM_BLOB_OPENED = 300;
  ATOM_CONTACTS_PROVIDER_STATUS_REPORTED = 301;
  ATOM_KEYSTORE_KEY_EVENT_REPORTED = 302;
  ATOM_NETWORK_TETHERING_REPORTED = 303;
  ATOM_IME_TOUCH_REPORTED = 304;
  ATOM_UI_INTERACTION_FRAME_INFO_REPORTED = 305;
  ATOM_UI_ACTION_LATENCY_REPORTED = 306;
  ATOM_WIFI_DISCONNECT_REPORTED = 307;
  ATOM_WIFI_CONNECTION_STATE_CHANGED = 308;
  ATOM_HDMI_CEC_ACTIVE_SOURCE_CHANGED = 309;
  ATOM_HDMI_CEC_MESSAGE_REPORTED = 310;
  ATOM_AIRPLANE_MODE = 311;
  ATOM_MODEM_RESTART = 312;
  ATOM_CARRIER_ID_MISMATCH_REPORTED = 313;
  ATOM_CARRIER_ID_TABLE_UPDATED = 314;
  ATOM_DATA_STALL_RECOVERY_REPORTED = 315;
  ATOM_MEDIAMETRICS_MEDIAPARSER_REPORTED = 316;
  ATOM_TLS_HANDSHAKE_REPORTED = 317;
  ATOM_TEXT_CLASSIFIER_API_USAGE_REPORTED = 318;
  ATOM_CAR_WATCHDOG_KILL_STATS_REPORTED = 319;
  ATOM_MEDIAMETRICS_PLAYBACK_REPORTED = 320;
  ATOM_MEDIA_NETWORK_INFO_CHANGED = 321;
  ATOM_MEDIA_PLAYBACK_STATE_CHANGED = 322;
  ATOM_MEDIA_PLAYBACK_ERROR_REPORTED = 323;
  ATOM_MEDIA_PLAYBACK_TRACK_CHANGED = 324;
  ATOM_WIFI_SCAN_REPORTED = 325;
  ATOM_WIFI_PNO_SCAN_REPORTED = 326;
  ATOM_TIF_TUNE_CHANGED = 327;
  ATOM_AUTO_ROTATE_REPORTED = 328;
  ATOM_PERFETTO_TRIGGER = 329;
  ATOM_TRANSCODING_DATA = 330;
  ATOM_IMS_SERVICE_ENTITLEMENT_UPDATED = 331;
  ATOM_DEVICE_ROTATED = 333;
  ATOM_SIM_SPECIFIC_SETTINGS_RESTORED = 334;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_REPORTED = 335;
  ATOM_PIN_STORAGE_EVENT = 336;
  ATOM_FACE_DOWN_REPORTED = 337;
  ATOM_BLUETOOTH_HAL_CRASH_REASON_REPORTED = 338;
  ATOM_REBOOT_ESCROW_PREPARATION_REPORTED = 339;
  ATOM_REBOOT_ESCROW_LSKF_CAPTURE_REPORTED = 340;
  ATOM_REBOOT_ESCROW_REBOOT_REPORTED = 341;
  ATOM_BINDER_LATENCY_REPORTED = 342;
  ATOM_MEDIAMETRICS_AAUDIOSTREAM_REPORTED = 343;
  ATOM_MEDIA_TRANSCODING_SESSION_ENDED = 344;
  ATOM_MAGNIFICATION_USAGE_REPORTED = 345;
  ATOM_MAGNIFICATION_MODE_WITH_IME_ON_REPORTED = 346;
  ATOM_APP_SEARCH_CALL_STATS_REPORTED = 347;
  ATOM_APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED = 348;
  ATOM_DEVICE_CONTROL_CHANGED = 349;
  ATOM_DEVICE_STATE_CHANGED = 350;
  ATOM_INPUTDEVICE_REGISTERED = 351;
  ATOM_SMARTSPACE_CARD_REPORTED = 352;
  ATOM_AUTH_PROMPT_AUTHENTICATE_INVOKED = 353;
  ATOM_AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED = 354;
  ATOM_AUTH_ENROLL_ACTION_INVOKED = 355;
  ATOM_AUTH_DEPRECATED_API_USED = 356;
  ATOM_UNATTENDED_REBOOT_OCCURRED = 357;
  ATOM_LONG_REBOOT_BLOCKING_REPORTED = 358;
  ATOM_LOCATION_TIME_ZONE_PROVIDER_STATE_CHANGED = 359;
  ATOM_FDTRACK_EVENT_OCCURRED = 364;
  ATOM_TIMEOUT_AUTO_EXTENDED_REPORTED = 365;
  ATOM_ALARM_BATCH_DELIVERED = 367;
  ATOM_ALARM_SCHEDULED = 368;
  ATOM_CAR_WATCHDOG_IO_OVERUSE_STATS_REPORTED = 369;
  ATOM_USER_LEVEL_HIBERNATION_STATE_CHANGED = 370;
  ATOM_APP_SEARCH_INITIALIZE_STATS_REPORTED = 371;
  ATOM_APP_SEARCH_QUERY_STATS_REPORTED = 372;
  ATOM_APP_PROCESS_DIED = 373;
  ATOM_NETWORK_IP_REACHABILITY_MONITOR_REPORTED = 374;
  ATOM_SLOW_INPUT_EVENT_REPORTED = 375;
  ATOM_ANR_OCCURRED_PROCESSING_STARTED = 376;
  ATOM_APP_SEARCH_REMOVE_STATS_REPORTED = 377;
  ATOM_MEDIA_CODEC_REPORTED = 378;
  ATOM_PERMISSION_USAGE_FRAGMENT_INTERACTION = 379;
  ATOM_PERMISSION_DETAILS_INTERACTION = 380;
  ATOM_PRIVACY_SENSOR_TOGGLE_INTERACTION = 381;
  ATOM_PRIVACY_TOGGLE_DIALOG_INTERACTION = 382;
  ATOM_APP_SEARCH_OPTIMIZE_STATS_REPORTED = 383;
  ATOM_NON_A11Y_TOOL_SERVICE_WARNING_REPORT = 384;
  ATOM_APP_COMPAT_STATE_CHANGED = 386;
  ATOM_SIZE_COMPAT_RESTART_BUTTON_EVENT_REPORTED = 387;
  ATOM_SPLITSCREEN_UI_CHANGED = 388;
  ATOM_NETWORK_DNS_HANDSHAKE_REPORTED = 389;
  ATOM_BLUETOOTH_CODE_PATH_COUNTER = 390;
  ATOM_BLUETOOTH_LE_BATCH_SCAN_REPORT_DELAY = 392;
  ATOM_ACCESSIBILITY_FLOATING_MENU_UI_CHANGED = 393;
  ATOM_NEURALNETWORKS_COMPILATION_COMPLETED = 394;
  ATOM_NEURALNETWORKS_EXECUTION_COMPLETED = 395;
  ATOM_NEURALNETWORKS_COMPILATION_FAILED = 396;
  ATOM_NEURALNETWORKS_EXECUTION_FAILED = 397;
  ATOM_CONTEXT_HUB_BOOTED = 398;
  ATOM_CONTEXT_HUB_RESTARTED = 399;
  ATOM_CONTEXT_HUB_LOADED_NANOAPP_SNAPSHOT_REPORTED = 400;
  ATOM_CHRE_CODE_DOWNLOAD_TRANSACTED = 401;
  ATOM_UWB_SESSION_INITED = 402;
  ATOM_UWB_SESSION_CLOSED = 403;
  ATOM_UWB_FIRST_RANGING_RECEIVED = 404;
  ATOM_UWB_RANGING_MEASUREMENT_RECEIVED = 405;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_SCHEDULED = 406;
  ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_COMPLETED = 407;
  ATOM_CLIPBOARD_CLEARED = 408;
  ATOM_VM_CREATION_REQUESTED = 409;
  ATOM_NEARBY_DEVICE_SCAN_STATE_CHANGED = 410;
  ATOM_APPLICATION_LOCALES_CHANGED = 412;
  ATOM_MEDIAMETRICS_AUDIOTRACKSTATUS_REPORTED = 413;
  ATOM_FOLD_STATE_DURATION_REPORTED = 414;
  ATOM_LOCATION_TIME_ZONE_PROVIDER_CONTROLLER_STATE_CHANGED = 415;
  ATOM_DISPLAY_HBM_STATE_CHANGED = 416;
  ATOM_DISPLAY_HBM_BRIGHTNESS_CHANGED = 417;
  ATOM_PERSISTENT_URI_PERMISSIONS_FLUSHED = 418;
  ATOM_EARLY_BOOT_COMP_OS_ARTIFACTS_CHECK_REPORTED = 419;
  ATOM_VBMETA_DIGEST_REPORTED = 420;
  ATOM_APEX_INFO_GATHERED = 421;
  ATOM_PVM_INFO_GATHERED = 422;
  ATOM_WEAR_SETTINGS_UI_INTERACTED = 423;
  ATOM_TRACING_SERVICE_REPORT_EVENT = 424;
  ATOM_MEDIAMETRICS_AUDIORECORDSTATUS_REPORTED = 425;
  ATOM_LAUNCHER_LATENCY = 426;
  ATOM_DROPBOX_ENTRY_DROPPED = 427;
  ATOM_WIFI_P2P_CONNECTION_REPORTED = 428;
  ATOM_GAME_STATE_CHANGED = 429;
  ATOM_HOTWORD_DETECTOR_CREATE_REQUESTED = 430;
  ATOM_HOTWORD_DETECTION_SERVICE_INIT_RESULT_REPORTED = 431;
  ATOM_HOTWORD_DETECTION_SERVICE_RESTARTED = 432;
  ATOM_HOTWORD_DETECTOR_KEYPHRASE_TRIGGERED = 433;
  ATOM_HOTWORD_DETECTOR_EVENTS = 434;
  ATOM_BOOT_COMPLETED_BROADCAST_COMPLETION_LATENCY_REPORTED = 437;
  ATOM_CONTACTS_INDEXER_UPDATE_STATS_REPORTED = 440;
  ATOM_APP_BACKGROUND_RESTRICTIONS_INFO = 441;
  ATOM_MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED = 442;
  ATOM_MMS_SMS_DATABASE_HELPER_ON_UPGRADE_FAILED = 443;
  ATOM_PERMISSION_REMINDER_NOTIFICATION_INTERACTED = 444;
  ATOM_RECENT_PERMISSION_DECISIONS_INTERACTED = 445;
  ATOM_GNSS_PSDS_DOWNLOAD_REPORTED = 446;
  ATOM_LE_AUDIO_CONNECTION_SESSION_REPORTED = 447;
  ATOM_LE_AUDIO_BROADCAST_SESSION_REPORTED = 448;
  ATOM_DREAM_UI_EVENT_REPORTED = 449;
  ATOM_TASK_MANAGER_EVENT_REPORTED = 450;
  ATOM_CDM_ASSOCIATION_ACTION = 451;
  ATOM_MAGNIFICATION_TRIPLE_TAP_AND_HOLD_ACTIVATED_SESSION_REPORTED = 452;
  ATOM_MAGNIFICATION_FOLLOW_TYPING_FOCUS_ACTIVATED_SESSION_REPORTED = 453;
  ATOM_ACCESSIBILITY_TEXT_READING_OPTIONS_CHANGED = 454;
  ATOM_WIFI_SETUP_FAILURE_CRASH_REPORTED = 455;
  ATOM_UWB_DEVICE_ERROR_REPORTED = 456;
  ATOM_ISOLATED_COMPILATION_SCHEDULED = 457;
  ATOM_ISOLATED_COMPILATION_ENDED = 458;
  ATOM_ONS_OPPORTUNISTIC_ESIM_PROVISIONING_COMPLETE = 459;
  ATOM_SYSTEM_SERVER_PRE_WATCHDOG_OCCURRED = 460;
  ATOM_TELEPHONY_ANOMALY_DETECTED = 461;
  ATOM_LETTERBOX_POSITION_CHANGED = 462;
  ATOM_REMOTE_KEY_PROVISIONING_ATTEMPT = 463;
  ATOM_REMOTE_KEY_PROVISIONING_NETWORK_INFO = 464;
  ATOM_REMOTE_KEY_PROVISIONING_TIMING = 465;
  ATOM_MEDIAOUTPUT_OP_INTERACTION_REPORT = 466;
  ATOM_SYNC_EXEMPTION_OCCURRED = 468;
  ATOM_AUTOFILL_PRESENTATION_EVENT_REPORTED = 469;
  ATOM_DOCK_STATE_CHANGED = 470;
  ATOM_SAFETY_SOURCE_STATE_COLLECTED = 471;
  ATOM_SAFETY_CENTER_SYSTEM_EVENT_REPORTED = 472;
  ATOM_SAFETY_CENTER_INTERACTION_REPORTED = 473;
  ATOM_SETTINGS_PROVIDER_SETTING_CHANGED = 474;
  ATOM_BROADCAST_DELIVERY_EVENT_REPORTED = 475;
  ATOM_SERVICE_REQUEST_EVENT_REPORTED = 476;
  ATOM_PROVIDER_ACQUISITION_EVENT_REPORTED = 477;
  ATOM_BLUETOOTH_DEVICE_NAME_REPORTED = 478;
  ATOM_CB_CONFIG_UPDATED = 479;
  ATOM_CB_MODULE_ERROR_REPORTED = 480;
  ATOM_CB_SERVICE_FEATURE_CHANGED = 481;
  ATOM_CB_RECEIVER_FEATURE_CHANGED = 482;
  ATOM_PRIVACY_SIGNAL_NOTIFICATION_INTERACTION = 484;
  ATOM_PRIVACY_SIGNAL_ISSUE_CARD_INTERACTION = 485;
  ATOM_PRIVACY_SIGNALS_JOB_FAILURE = 486;
  ATOM_VIBRATION_REPORTED = 487;
  ATOM_UWB_RANGING_START = 489;
  ATOM_APP_COMPACTED_V2 = 491;
  ATOM_DISPLAY_BRIGHTNESS_CHANGED = 494;
  ATOM_ACTIVITY_ACTION_BLOCKED = 495;
  ATOM_NETWORK_DNS_SERVER_SUPPORT_REPORTED = 504;
  ATOM_VM_BOOTED = 505;
  ATOM_VM_EXITED = 506;
  ATOM_AMBIENT_BRIGHTNESS_STATS_REPORTED = 507;
  ATOM_MEDIAMETRICS_SPATIALIZERCAPABILITIES_REPORTED = 508;
  ATOM_MEDIAMETRICS_SPATIALIZERDEVICEENABLED_REPORTED = 509;
  ATOM_MEDIAMETRICS_HEADTRACKERDEVICEENABLED_REPORTED = 510;
  ATOM_MEDIAMETRICS_HEADTRACKERDEVICESUPPORTED_REPORTED = 511;
  ATOM_HEARING_AID_INFO_REPORTED = 513;
  ATOM_DEVICE_WIDE_JOB_CONSTRAINT_CHANGED = 514;
  ATOM_AMBIENT_MODE_CHANGED = 515;
  ATOM_ANR_LATENCY_REPORTED = 516;
  ATOM_RESOURCE_API_INFO = 517;
  ATOM_SYSTEM_DEFAULT_NETWORK_CHANGED = 518;
  ATOM_IWLAN_SETUP_DATA_CALL_RESULT_REPORTED = 519;
  ATOM_IWLAN_PDN_DISCONNECTED_REASON_REPORTED = 520;
  ATOM_AIRPLANE_MODE_SESSION_REPORTED = 521;
  ATOM_VM_CPU_STATUS_REPORTED = 522;
  ATOM_VM_MEM_STATUS_REPORTED = 523;
  ATOM_PACKAGE_INSTALLATION_SESSION_REPORTED = 524;
  ATOM_DEFAULT_NETWORK_REMATCH_INFO = 525;
  ATOM_NETWORK_SELECTION_PERFORMANCE = 526;
  ATOM_NETWORK_NSD_REPORTED = 527;
  ATOM_BLUETOOTH_DISCONNECTION_REASON_REPORTED = 529;
  ATOM_BLUETOOTH_LOCAL_VERSIONS_REPORTED = 530;
  ATOM_BLUETOOTH_REMOTE_SUPPORTED_FEATURES_REPORTED = 531;
  ATOM_BLUETOOTH_LOCAL_SUPPORTED_FEATURES_REPORTED = 532;
  ATOM_BLUETOOTH_GATT_APP_INFO = 533;
  ATOM_BRIGHTNESS_CONFIGURATION_UPDATED = 534;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_LAUNCHED = 538;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FINISHED = 539;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECTION_REPORTED = 540;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_TRIGGERED = 541;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FIRST_DEVICE_SCAN_LATENCY = 542;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECT_DEVICE_LATENCY = 543;
  ATOM_PACKAGE_MANAGER_SNAPSHOT_REPORTED = 544;
  ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_BUILD_REPORTED = 545;
  ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_UPDATE_REPORTED = 546;
  ATOM_LAUNCHER_IMPRESSION_EVENT = 547;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_ALL_DEVICES_SCAN_LATENCY = 549;
  ATOM_WS_WATCH_FACE_EDITED = 551;
  ATOM_WS_WATCH_FACE_FAVORITE_ACTION_REPORTED = 552;
  ATOM_WS_WATCH_FACE_SET_ACTION_REPORTED = 553;
  ATOM_PACKAGE_UNINSTALLATION_REPORTED = 554;
  ATOM_GAME_MODE_CHANGED = 555;
  ATOM_GAME_MODE_CONFIGURATION_CHANGED = 556;
  ATOM_BEDTIME_MODE_STATE_CHANGED = 557;
  ATOM_NETWORK_SLICE_SESSION_ENDED = 558;
  ATOM_NETWORK_SLICE_DAILY_DATA_USAGE_REPORTED = 559;
  ATOM_NFC_TAG_TYPE_OCCURRED = 560;
  ATOM_NFC_AID_CONFLICT_OCCURRED = 561;
  ATOM_NFC_READER_CONFLICT_OCCURRED = 562;
  ATOM_WS_TILE_LIST_CHANGED = 563;
  ATOM_GET_TYPE_ACCESSED_WITHOUT_PERMISSION = 564;
  ATOM_MOBILE_BUNDLED_APP_INFO_GATHERED = 566;
  ATOM_WS_WATCH_FACE_COMPLICATION_SET_CHANGED = 567;
  ATOM_MEDIA_DRM_CREATED = 568;
  ATOM_MEDIA_DRM_ERRORED = 569;
  ATOM_MEDIA_DRM_SESSION_OPENED = 570;
  ATOM_MEDIA_DRM_SESSION_CLOSED = 571;
  ATOM_USER_SELECTED_RESOLUTION = 572;
  ATOM_UNSAFE_INTENT_EVENT_REPORTED = 573;
  ATOM_PERFORMANCE_HINT_SESSION_REPORTED = 574;
  ATOM_MEDIAMETRICS_MIDI_DEVICE_CLOSE_REPORTED = 576;
  ATOM_BIOMETRIC_TOUCH_REPORTED = 577;
  ATOM_HOTWORD_AUDIO_EGRESS_EVENT_REPORTED = 578;
  ATOM_LOCATION_ENABLED_STATE_CHANGED = 580;
  ATOM_IME_REQUEST_FINISHED = 581;
  ATOM_USB_COMPLIANCE_WARNINGS_REPORTED = 582;
  ATOM_APP_SUPPORTED_LOCALES_CHANGED = 583;
  ATOM_MEDIA_PROVIDER_VOLUME_RECOVERY_REPORTED = 586;
  ATOM_BIOMETRIC_PROPERTIES_COLLECTED = 587;
  ATOM_KERNEL_WAKEUP_ATTRIBUTED = 588;
  ATOM_SCREEN_STATE_CHANGED_V2 = 589;
  ATOM_WS_BACKUP_ACTION_REPORTED = 590;
  ATOM_WS_RESTORE_ACTION_REPORTED = 591;
  ATOM_DEVICE_LOG_ACCESS_EVENT_REPORTED = 592;
  ATOM_MEDIA_SESSION_UPDATED = 594;
  ATOM_WEAR_OOBE_STATE_CHANGED = 595;
  ATOM_WS_NOTIFICATION_UPDATED = 596;
  ATOM_NETWORK_VALIDATION_FAILURE_STATS_DAILY_REPORTED = 601;
  ATOM_WS_COMPLICATION_TAPPED = 602;
  ATOM_WS_NOTIFICATION_BLOCKING = 780;
  ATOM_WS_NOTIFICATION_BRIDGEMODE_UPDATED = 822;
  ATOM_WS_NOTIFICATION_DISMISSAL_ACTIONED = 823;
  ATOM_WS_NOTIFICATION_ACTIONED = 824;
  ATOM_WS_NOTIFICATION_LATENCY = 880;
  ATOM_WIFI_BYTES_TRANSFER = 10000;
  ATOM_WIFI_BYTES_TRANSFER_BY_FG_BG = 10001;
  ATOM_MOBILE_BYTES_TRANSFER = 10002;
  ATOM_MOBILE_BYTES_TRANSFER_BY_FG_BG = 10003;
  ATOM_BLUETOOTH_BYTES_TRANSFER = 10006;
  ATOM_KERNEL_WAKELOCK = 10004;
  ATOM_SUBSYSTEM_SLEEP_STATE = 10005;
  ATOM_CPU_TIME_PER_UID = 10009;
  ATOM_CPU_TIME_PER_UID_FREQ = 10010;
  ATOM_WIFI_ACTIVITY_INFO = 10011;
  ATOM_MODEM_ACTIVITY_INFO = 10012;
  ATOM_BLUETOOTH_ACTIVITY_INFO = 10007;
  ATOM_PROCESS_MEMORY_STATE = 10013;
  ATOM_SYSTEM_ELAPSED_REALTIME = 10014;
  ATOM_SYSTEM_UPTIME = 10015;
  ATOM_CPU_ACTIVE_TIME = 10016;
  ATOM_CPU_CLUSTER_TIME = 10017;
  ATOM_DISK_SPACE = 10018;
  ATOM_REMAINING_BATTERY_CAPACITY = 10019;
  ATOM_FULL_BATTERY_CAPACITY = 10020;
  ATOM_TEMPERATURE = 10021;
  ATOM_BINDER_CALLS = 10022;
  ATOM_BINDER_CALLS_EXCEPTIONS = 10023;
  ATOM_LOOPER_STATS = 10024;
  ATOM_DISK_STATS = 10025;
  ATOM_DIRECTORY_USAGE = 10026;
  ATOM_APP_SIZE = 10027;
  ATOM_CATEGORY_SIZE = 10028;
  ATOM_PROC_STATS = 10029;
  ATOM_BATTERY_VOLTAGE = 10030;
  ATOM_NUM_FINGERPRINTS_ENROLLED = 10031;
  ATOM_DISK_IO = 10032;
  ATOM_POWER_PROFILE = 10033;
  ATOM_PROC_STATS_PKG_PROC = 10034;
  ATOM_PROCESS_CPU_TIME = 10035;
  ATOM_CPU_TIME_PER_THREAD_FREQ = 10037;
  ATOM_ON_DEVICE_POWER_MEASUREMENT = 10038;
  ATOM_DEVICE_CALCULATED_POWER_USE = 10039;
  ATOM_PROCESS_MEMORY_HIGH_WATER_MARK = 10042;
  ATOM_BATTERY_LEVEL = 10043;
  ATOM_BUILD_INFORMATION = 10044;
  ATOM_BATTERY_CYCLE_COUNT = 10045;
  ATOM_DEBUG_ELAPSED_CLOCK = 10046;
  ATOM_DEBUG_FAILING_ELAPSED_CLOCK = 10047;
  ATOM_NUM_FACES_ENROLLED = 10048;
  ATOM_ROLE_HOLDER = 10049;
  ATOM_DANGEROUS_PERMISSION_STATE = 10050;
  ATOM_TRAIN_INFO = 10051;
  ATOM_TIME_ZONE_DATA_INFO = 10052;
  ATOM_EXTERNAL_STORAGE_INFO = 10053;
  ATOM_GPU_STATS_GLOBAL_INFO = 10054;
  ATOM_GPU_STATS_APP_INFO = 10055;
  ATOM_SYSTEM_ION_HEAP_SIZE = 10056;
  ATOM_APPS_ON_EXTERNAL_STORAGE_INFO = 10057;
  ATOM_FACE_SETTINGS = 10058;
  ATOM_COOLING_DEVICE = 10059;
  ATOM_APP_OPS = 10060;
  ATOM_PROCESS_SYSTEM_ION_HEAP_SIZE = 10061;
  ATOM_SURFACEFLINGER_STATS_GLOBAL_INFO = 10062;
  ATOM_SURFACEFLINGER_STATS_LAYER_INFO = 10063;
  ATOM_PROCESS_MEMORY_SNAPSHOT = 10064;
  ATOM_VMS_CLIENT_STATS = 10065;
  ATOM_NOTIFICATION_REMOTE_VIEWS = 10066;
  ATOM_DANGEROUS_PERMISSION_STATE_SAMPLED = 10067;
  ATOM_GRAPHICS_STATS = 10068;
  ATOM_RUNTIME_APP_OP_ACCESS = 10069;
  ATOM_ION_HEAP_SIZE = 10070;
  ATOM_PACKAGE_NOTIFICATION_PREFERENCES = 10071;
  ATOM_PACKAGE_NOTIFICATION_CHANNEL_PREFERENCES = 10072;
  ATOM_PACKAGE_NOTIFICATION_CHANNEL_GROUP_PREFERENCES = 10073;
  ATOM_GNSS_STATS = 10074;
  ATOM_ATTRIBUTED_APP_OPS = 10075;
  ATOM_VOICE_CALL_SESSION = 10076;
  ATOM_VOICE_CALL_RAT_USAGE = 10077;
  ATOM_SIM_SLOT_STATE = 10078;
  ATOM_SUPPORTED_RADIO_ACCESS_FAMILY = 10079;
  ATOM_SETTING_SNAPSHOT = 10080;
  ATOM_BLOB_INFO = 10081;
  ATOM_DATA_USAGE_BYTES_TRANSFER = 10082;
  ATOM_BYTES_TRANSFER_BY_TAG_AND_METERED = 10083;
  ATOM_DND_MODE_RULE = 10084;
  ATOM_GENERAL_EXTERNAL_STORAGE_ACCESS_STATS = 10085;
  ATOM_INCOMING_SMS = 10086;
  ATOM_OUTGOING_SMS = 10087;
  ATOM_CARRIER_ID_TABLE_VERSION = 10088;
  ATOM_DATA_CALL_SESSION = 10089;
  ATOM_CELLULAR_SERVICE_STATE = 10090;
  ATOM_CELLULAR_DATA_SERVICE_SWITCH = 10091;
  ATOM_SYSTEM_MEMORY = 10092;
  ATOM_IMS_REGISTRATION_TERMINATION = 10093;
  ATOM_IMS_REGISTRATION_STATS = 10094;
  ATOM_CPU_TIME_PER_CLUSTER_FREQ = 10095;
  ATOM_CPU_CYCLES_PER_UID_CLUSTER = 10096;
  ATOM_DEVICE_ROTATED_DATA = 10097;
  ATOM_CPU_CYCLES_PER_THREAD_GROUP_CLUSTER = 10098;
  ATOM_MEDIA_DRM_ACTIVITY_INFO = 10099;
  ATOM_OEM_MANAGED_BYTES_TRANSFER = 10100;
  ATOM_GNSS_POWER_STATS = 10101;
  ATOM_TIME_ZONE_DETECTOR_STATE = 10102;
  ATOM_KEYSTORE2_STORAGE_STATS = 10103;
  ATOM_RKP_POOL_STATS = 10104;
  ATOM_PROCESS_DMABUF_MEMORY = 10105;
  ATOM_PENDING_ALARM_INFO = 10106;
  ATOM_USER_LEVEL_HIBERNATED_APPS = 10107;
  ATOM_LAUNCHER_LAYOUT_SNAPSHOT = 10108;
  ATOM_GLOBAL_HIBERNATED_APPS = 10109;
  ATOM_INPUT_EVENT_LATENCY_SKETCH = 10110;
  ATOM_BATTERY_USAGE_STATS_BEFORE_RESET = 10111;
  ATOM_BATTERY_USAGE_STATS_SINCE_RESET = 10112;
  ATOM_BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL = 10113;
  ATOM_INSTALLED_INCREMENTAL_PACKAGE = 10114;
  ATOM_TELEPHONY_NETWORK_REQUESTS = 10115;
  ATOM_APP_SEARCH_STORAGE_INFO = 10116;
  ATOM_VMSTAT = 10117;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_GENERAL_INFO = 10118;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_AUTH_INFO = 10119;
  ATOM_KEYSTORE2_KEY_CREATION_WITH_PURPOSE_AND_MODES_INFO = 10120;
  ATOM_KEYSTORE2_ATOM_WITH_OVERFLOW = 10121;
  ATOM_KEYSTORE2_KEY_OPERATION_WITH_PURPOSE_AND_MODES_INFO = 10122;
  ATOM_KEYSTORE2_KEY_OPERATION_WITH_GENERAL_INFO = 10123;
  ATOM_RKP_ERROR_STATS = 10124;
  ATOM_KEYSTORE2_CRASH_STATS = 10125;
  ATOM_VENDOR_APEX_INFO = 10126;
  ATOM_ACCESSIBILITY_SHORTCUT_STATS = 10127;
  ATOM_ACCESSIBILITY_FLOATING_MENU_STATS = 10128;
  ATOM_DATA_USAGE_BYTES_TRANSFER_V2 = 10129;
  ATOM_MEDIA_CAPABILITIES = 10130;
  ATOM_CAR_WATCHDOG_SYSTEM_IO_USAGE_SUMMARY = 10131;
  ATOM_CAR_WATCHDOG_UID_IO_USAGE_SUMMARY = 10132;
  ATOM_IMS_REGISTRATION_FEATURE_TAG_STATS = 10133;
  ATOM_RCS_CLIENT_PROVISIONING_STATS = 10134;
  ATOM_RCS_ACS_PROVISIONING_STATS = 10135;
  ATOM_SIP_DELEGATE_STATS = 10136;
  ATOM_SIP_TRANSPORT_FEATURE_TAG_STATS = 10137;
  ATOM_SIP_MESSAGE_RESPONSE = 10138;
  ATOM_SIP_TRANSPORT_SESSION = 10139;
  ATOM_IMS_DEDICATED_BEARER_LISTENER_EVENT = 10140;
  ATOM_IMS_DEDICATED_BEARER_EVENT = 10141;
  ATOM_IMS_REGISTRATION_SERVICE_DESC_STATS = 10142;
  ATOM_UCE_EVENT_STATS = 10143;
  ATOM_PRESENCE_NOTIFY_EVENT = 10144;
  ATOM_GBA_EVENT = 10145;
  ATOM_PER_SIM_STATUS = 10146;
  ATOM_GPU_WORK_PER_UID = 10147;
  ATOM_PERSISTENT_URI_PERMISSIONS_AMOUNT_PER_PACKAGE = 10148;
  ATOM_SIGNED_PARTITION_INFO = 10149;
  ATOM_PINNED_FILE_SIZES_PER_PACKAGE = 10150;
  ATOM_PENDING_INTENTS_PER_PACKAGE = 10151;
  ATOM_USER_INFO = 10152;
  ATOM_TELEPHONY_NETWORK_REQUESTS_V2 = 10153;
  ATOM_DEVICE_TELEPHONY_PROPERTIES = 10154;
  ATOM_REMOTE_KEY_PROVISIONING_ERROR_COUNTS = 10155;
  ATOM_SAFETY_STATE = 10156;
  ATOM_INCOMING_MMS = 10157;
  ATOM_OUTGOING_MMS = 10158;
  ATOM_MULTI_USER_INFO = 10160;
  ATOM_NETWORK_BPF_MAP_INFO = 10161;
  ATOM_OUTGOING_SHORT_CODE_SMS = 10162;
  ATOM_CONNECTIVITY_STATE_SAMPLE = 10163;
  ATOM_NETWORK_SELECTION_REMATCH_REASONS_INFO = 10164;
  ATOM_GAME_MODE_INFO = 10165;
  ATOM_GAME_MODE_CONFIGURATION = 10166;
  ATOM_GAME_MODE_LISTENER = 10167;
  ATOM_NETWORK_SLICE_REQUEST_COUNT = 10168;
  ATOM_WS_TILE_SNAPSHOT = 10169;
  ATOM_WS_ACTIVE_WATCH_FACE_COMPLICATION_SET_SNAPSHOT = 10170;
  ATOM_PROCESS_STATE = 10171;
  ATOM_PROCESS_ASSOCIATION = 10172;
  ATOM_ADPF_SYSTEM_COMPONENT_INFO = 10173;
  ATOM_NOTIFICATION_MEMORY_USE = 10174;
  ATOM_HDR_CAPABILITIES = 10175;
  ATOM_WS_FAVOURITE_WATCH_FACE_LIST_SNAPSHOT = 10176;
  ATOM_ACCESSIBILITY_CHECK_RESULT_REPORTED = 910;
  ATOM_ADAPTIVE_AUTH_UNLOCK_AFTER_LOCK_REPORTED = 820;
  ATOM_THERMAL_STATUS_CALLED = 772;
  ATOM_THERMAL_HEADROOM_CALLED = 773;
  ATOM_THERMAL_HEADROOM_THRESHOLDS_CALLED = 774;
  ATOM_ADPF_HINT_SESSION_TID_CLEANUP = 839;
  ATOM_THERMAL_HEADROOM_THRESHOLDS = 10201;
  ATOM_ADPF_SESSION_SNAPSHOT = 10218;
  ATOM_JSSCRIPTENGINE_LATENCY_REPORTED = 483;
  ATOM_AD_SERVICES_API_CALLED = 435;
  ATOM_AD_SERVICES_MESUREMENT_REPORTS_UPLOADED = 436;
  ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STATUS_REPORTED = 490;
  ATOM_MOBILE_DATA_DOWNLOAD_DOWNLOAD_RESULT_REPORTED = 502;
  ATOM_AD_SERVICES_SETTINGS_USAGE_REPORTED = 493;
  ATOM_BACKGROUND_FETCH_PROCESS_REPORTED = 496;
  ATOM_UPDATE_CUSTOM_AUDIENCE_PROCESS_REPORTED = 497;
  ATOM_RUN_AD_BIDDING_PROCESS_REPORTED = 498;
  ATOM_RUN_AD_SCORING_PROCESS_REPORTED = 499;
  ATOM_RUN_AD_SELECTION_PROCESS_REPORTED = 500;
  ATOM_RUN_AD_BIDDING_PER_CA_PROCESS_REPORTED = 501;
  ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STORAGE_STATS_REPORTED = 503;
  ATOM_AD_SERVICES_MEASUREMENT_REGISTRATIONS = 512;
  ATOM_AD_SERVICES_GET_TOPICS_REPORTED = 535;
  ATOM_AD_SERVICES_EPOCH_COMPUTATION_GET_TOP_TOPICS_REPORTED = 536;
  ATOM_AD_SERVICES_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 537;
  ATOM_AD_SERVICES_BACK_COMPAT_GET_TOPICS_REPORTED = 598;
  ATOM_AD_SERVICES_BACK_COMPAT_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 599;
  ATOM_AD_SERVICES_MEASUREMENT_DEBUG_KEYS = 640;
  ATOM_AD_SERVICES_ERROR_REPORTED = 662;
  ATOM_AD_SERVICES_BACKGROUND_JOBS_EXECUTION_REPORTED = 663;
  ATOM_AD_SERVICES_MEASUREMENT_DELAYED_SOURCE_REGISTRATION = 673;
  ATOM_AD_SERVICES_MEASUREMENT_ATTRIBUTION = 674;
  ATOM_AD_SERVICES_MEASUREMENT_JOBS = 675;
  ATOM_AD_SERVICES_MEASUREMENT_WIPEOUT = 676;
  ATOM_AD_SERVICES_MEASUREMENT_AD_ID_MATCH_FOR_DEBUG_KEYS = 695;
  ATOM_AD_SERVICES_ENROLLMENT_DATA_STORED = 697;
  ATOM_AD_SERVICES_ENROLLMENT_FILE_DOWNLOADED = 698;
  ATOM_AD_SERVICES_ENROLLMENT_MATCHED = 699;
  ATOM_AD_SERVICES_CONSENT_MIGRATED = 702;
  ATOM_AD_SERVICES_ENROLLMENT_FAILED = 714;
  ATOM_AD_SERVICES_MEASUREMENT_CLICK_VERIFICATION = 756;
  ATOM_AD_SERVICES_ENCRYPTION_KEY_FETCHED = 765;
  ATOM_AD_SERVICES_ENCRYPTION_KEY_DB_TRANSACTION_ENDED = 766;
  ATOM_DESTINATION_REGISTERED_BEACONS = 767;
  ATOM_REPORT_INTERACTION_API_CALLED = 768;
  ATOM_INTERACTION_REPORTING_TABLE_CLEARED = 769;
  ATOM_APP_MANIFEST_CONFIG_HELPER_CALLED = 788;
  ATOM_AD_FILTERING_PROCESS_JOIN_CA_REPORTED = 793;
  ATOM_AD_FILTERING_PROCESS_AD_SELECTION_REPORTED = 794;
  ATOM_AD_COUNTER_HISTOGRAM_UPDATER_REPORTED = 795;
  ATOM_SIGNATURE_VERIFICATION = 807;
  ATOM_K_ANON_IMMEDIATE_SIGN_JOIN_STATUS_REPORTED = 808;
  ATOM_K_ANON_BACKGROUND_JOB_STATUS_REPORTED = 809;
  ATOM_K_ANON_INITIALIZE_STATUS_REPORTED = 810;
  ATOM_K_ANON_SIGN_STATUS_REPORTED = 811;
  ATOM_K_ANON_JOIN_STATUS_REPORTED = 812;
  ATOM_K_ANON_KEY_ATTESTATION_STATUS_REPORTED = 813;
  ATOM_GET_AD_SELECTION_DATA_API_CALLED = 814;
  ATOM_GET_AD_SELECTION_DATA_BUYER_INPUT_GENERATED = 815;
  ATOM_BACKGROUND_JOB_SCHEDULING_REPORTED = 834;
  ATOM_TOPICS_ENCRYPTION_EPOCH_COMPUTATION_REPORTED = 840;
  ATOM_TOPICS_ENCRYPTION_GET_TOPICS_REPORTED = 841;
  ATOM_ADSERVICES_SHELL_COMMAND_CALLED = 842;
  ATOM_UPDATE_SIGNALS_API_CALLED = 843;
  ATOM_ENCODING_JOB_RUN = 844;
  ATOM_ENCODING_JS_FETCH = 845;
  ATOM_ENCODING_JS_EXECUTION = 846;
  ATOM_PERSIST_AD_SELECTION_RESULT_CALLED = 847;
  ATOM_SERVER_AUCTION_KEY_FETCH_CALLED = 848;
  ATOM_SERVER_AUCTION_BACKGROUND_KEY_FETCH_ENABLED = 849;
  ATOM_AD_SERVICES_MEASUREMENT_PROCESS_ODP_REGISTRATION = 864;
  ATOM_AD_SERVICES_MEASUREMENT_NOTIFY_REGISTRATION_TO_ODP = 865;
  ATOM_SELECT_ADS_FROM_OUTCOMES_API_CALLED = 876;
  ATOM_REPORT_IMPRESSION_API_CALLED = 877;
  ATOM_AD_SERVICES_ENROLLMENT_TRANSACTION_STATS = 885;
  ATOM_AD_SERVICES_COBALT_LOGGER_EVENT_REPORTED = 902;
  ATOM_AD_SERVICES_COBALT_PERIODIC_JOB_EVENT_REPORTED = 903;
  ATOM_UPDATE_SIGNALS_PROCESS_REPORTED = 905;
  ATOM_TOPICS_SCHEDULE_EPOCH_JOB_SETTING_REPORTED = 930;
  ATOM_AI_WALLPAPERS_BUTTON_PRESSED = 706;
  ATOM_AI_WALLPAPERS_TEMPLATE_SELECTED = 707;
  ATOM_AI_WALLPAPERS_TERM_SELECTED = 708;
  ATOM_AI_WALLPAPERS_WALLPAPER_SET = 709;
  ATOM_AI_WALLPAPERS_SESSION_SUMMARY = 710;
  ATOM_APEX_INSTALLATION_REQUESTED = 732;
  ATOM_APEX_INSTALLATION_STAGED = 733;
  ATOM_APEX_INSTALLATION_ENDED = 734;
  ATOM_APP_SEARCH_SET_SCHEMA_STATS_REPORTED = 385;
  ATOM_APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED = 579;
  ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_STATS_REPORTED = 825;
  ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_RAW_QUERY_STATS_REPORTED = 826;
  ATOM_APP_SEARCH_APPS_INDEXER_STATS_REPORTED = 909;
  ATOM_ART_DATUM_REPORTED = 332;
  ATOM_ART_DEVICE_DATUM_REPORTED = 550;
  ATOM_ART_DATUM_DELTA_REPORTED = 565;
  ATOM_ART_DEX2OAT_REPORTED = 929;
  ATOM_ART_DEVICE_STATUS = 10205;
  ATOM_BACKGROUND_DEXOPT_JOB_ENDED = 467;
  ATOM_PREREBOOT_DEXOPT_JOB_ENDED = 883;
  ATOM_ODREFRESH_REPORTED = 366;
  ATOM_ODSIGN_REPORTED = 548;
  ATOM_AUTOFILL_UI_EVENT_REPORTED = 603;
  ATOM_AUTOFILL_FILL_REQUEST_REPORTED = 604;
  ATOM_AUTOFILL_FILL_RESPONSE_REPORTED = 605;
  ATOM_AUTOFILL_SAVE_EVENT_REPORTED = 606;
  ATOM_AUTOFILL_SESSION_COMMITTED = 607;
  ATOM_AUTOFILL_FIELD_CLASSIFICATION_EVENT_REPORTED = 659;
  ATOM_CAR_RECENTS_EVENT_REPORTED = 770;
  ATOM_CAR_CALM_MODE_EVENT_REPORTED = 797;
  ATOM_CAR_WAKEUP_FROM_SUSPEND_REPORTED = 852;
  ATOM_PLUGIN_INITIALIZED = 655;
  ATOM_BLUETOOTH_HASHED_DEVICE_NAME_REPORTED = 613;
  ATOM_BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION = 614;
  ATOM_BLUETOOTH_L2CAP_COC_SERVER_CONNECTION = 615;
  ATOM_BLUETOOTH_LE_SESSION_CONNECTED = 656;
  ATOM_RESTRICTED_BLUETOOTH_DEVICE_NAME_REPORTED = 666;
  ATOM_BLUETOOTH_PROFILE_CONNECTION_ATTEMPTED = 696;
  ATOM_BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED = 781;
  ATOM_BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED = 782;
  ATOM_REMOTE_DEVICE_INFORMATION_WITH_METRIC_ID = 862;
  ATOM_LE_APP_SCAN_STATE_CHANGED = 870;
  ATOM_LE_RADIO_SCAN_STOPPED = 871;
  ATOM_LE_SCAN_RESULT_RECEIVED = 872;
  ATOM_LE_SCAN_ABUSED = 873;
  ATOM_LE_ADV_STATE_CHANGED = 874;
  ATOM_LE_ADV_ERROR_REPORTED = 875;
  ATOM_A2DP_SESSION_REPORTED = 904;
  ATOM_BLUETOOTH_CROSS_LAYER_EVENT_REPORTED = 916;
  ATOM_BROADCAST_AUDIO_SESSION_REPORTED = 927;
  ATOM_BROADCAST_AUDIO_SYNC_REPORTED = 928;
  ATOM_BLUETOOTH_RFCOMM_CONNECTION_REPORTED_AT_CLOSE = 982;
  ATOM_BLUETOOTH_LE_CONNECTION = 988;
  ATOM_BROADCAST_SENT = 922;
  ATOM_CAMERA_FEATURE_COMBINATION_QUERY_EVENT = 900;
  ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_STATE_CHANGED = 934;
  ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_FAILED = 972;
  ATOM_DAILY_KEEPALIVE_INFO_REPORTED = 650;
  ATOM_NETWORK_REQUEST_STATE_CHANGED = 779;
  ATOM_TETHERING_ACTIVE_SESSIONS_REPORTED = 925;
  ATOM_NETWORK_STATS_RECORDER_FILE_OPERATED = 783;
  ATOM_CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED = 979;
  ATOM_APF_SESSION_INFO_REPORTED = 777;
  ATOM_IP_CLIENT_RA_INFO_REPORTED = 778;
  ATOM_VPN_CONNECTION_STATE_CHANGED = 850;
  ATOM_VPN_CONNECTION_REPORTED = 851;
  ATOM_CPU_POLICY = 10199;
  ATOM_CREDENTIAL_MANAGER_API_CALLED = 585;
  ATOM_CREDENTIAL_MANAGER_INIT_PHASE_REPORTED = 651;
  ATOM_CREDENTIAL_MANAGER_CANDIDATE_PHASE_REPORTED = 652;
  ATOM_CREDENTIAL_MANAGER_FINAL_PHASE_REPORTED = 653;
  ATOM_CREDENTIAL_MANAGER_TOTAL_REPORTED = 667;
  ATOM_CREDENTIAL_MANAGER_FINALNOUID_REPORTED = 668;
  ATOM_CREDENTIAL_MANAGER_GET_REPORTED = 669;
  ATOM_CREDENTIAL_MANAGER_AUTH_CLICK_REPORTED = 670;
  ATOM_CREDENTIAL_MANAGER_APIV2_CALLED = 671;
  ATOM_CRONET_ENGINE_CREATED = 703;
  ATOM_CRONET_TRAFFIC_REPORTED = 704;
  ATOM_CRONET_ENGINE_BUILDER_INITIALIZED = 762;
  ATOM_CRONET_HTTP_FLAGS_INITIALIZED = 763;
  ATOM_CRONET_INITIALIZED = 764;
  ATOM_DESKTOP_MODE_UI_CHANGED = 818;
  ATOM_DESKTOP_MODE_SESSION_TASK_UPDATE = 819;
  ATOM_DESKTOP_MODE_TASK_SIZE_UPDATED = 935;
  ATOM_DEVICE_LOCK_CHECK_IN_REQUEST_REPORTED = 726;
  ATOM_DEVICE_LOCK_PROVISIONING_COMPLETE_REPORTED = 727;
  ATOM_DEVICE_LOCK_KIOSK_APP_REQUEST_REPORTED = 728;
  ATOM_DEVICE_LOCK_CHECK_IN_RETRY_REPORTED = 789;
  ATOM_DEVICE_LOCK_PROVISION_FAILURE_REPORTED = 790;
  ATOM_DEVICE_LOCK_LOCK_UNLOCK_DEVICE_FAILURE_REPORTED = 791;
  ATOM_DEVICE_POLICY_MANAGEMENT_MODE = 10216;
  ATOM_DEVICE_POLICY_STATE = 10217;
  ATOM_DISPLAY_MODE_DIRECTOR_VOTE_CHANGED = 792;
  ATOM_EXTERNAL_DISPLAY_STATE_CHANGED = 806;
  ATOM_DND_STATE_CHANGED = 657;
  ATOM_DREAM_SETTING_CHANGED = 705;
  ATOM_DREAM_SETTING_SNAPSHOT = 10192;
  ATOM_EXPRESS_EVENT_REPORTED = 528;
  ATOM_EXPRESS_HISTOGRAM_SAMPLE_REPORTED = 593;
  ATOM_EXPRESS_UID_EVENT_REPORTED = 644;
  ATOM_EXPRESS_UID_HISTOGRAM_SAMPLE_REPORTED = 658;
  ATOM_FEDERATED_COMPUTE_API_CALLED = 712;
  ATOM_FEDERATED_COMPUTE_TRAINING_EVENT_REPORTED = 771;
  ATOM_EXAMPLE_ITERATOR_NEXT_LATENCY_REPORTED = 838;
  ATOM_FULL_SCREEN_INTENT_LAUNCHED = 631;
  ATOM_BAL_ALLOWED = 632;
  ATOM_IN_TASK_ACTIVITY_STARTED = 685;
  ATOM_DEVICE_ORIENTATION_CHANGED = 906;
  ATOM_CACHED_APPS_HIGH_WATERMARK = 10189;
  ATOM_STYLUS_PREDICTION_METRICS_REPORTED = 718;
  ATOM_USER_RISK_EVENT_REPORTED = 725;
  ATOM_MEDIA_PROJECTION_STATE_CHANGED = 729;
  ATOM_MEDIA_PROJECTION_TARGET_CHANGED = 730;
  ATOM_EXCESSIVE_BINDER_PROXY_COUNT_REPORTED = 853;
  ATOM_PROXY_BYTES_TRANSFER_BY_FG_BG = 10200;
  ATOM_MOBILE_BYTES_TRANSFER_BY_PROC_STATE = 10204;
  ATOM_BIOMETRIC_FRR_NOTIFICATION = 817;
  ATOM_SENSITIVE_CONTENT_MEDIA_PROJECTION_SESSION = 830;
  ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_SESSION = 831;
  ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_APPLIED = 832;
  ATOM_SENSITIVE_NOTIFICATION_REDACTION = 833;
  ATOM_SENSITIVE_CONTENT_APP_PROTECTION = 835;
  ATOM_APP_RESTRICTION_STATE_CHANGED = 866;
  ATOM_BATTERY_USAGE_STATS_PER_UID = 10209;
  ATOM_POSTGC_MEMORY_SNAPSHOT = 924;
  ATOM_POWER_SAVE_TEMP_ALLOWLIST_CHANGED = 926;
  ATOM_APP_OP_ACCESS_TRACKED = 931;
  ATOM_CONTENT_OR_FILE_URI_EVENT_REPORTED = 933;
  ATOM_APPLICATION_GRAMMATICAL_INFLECTION_CHANGED = 584;
  ATOM_SYSTEM_GRAMMATICAL_INFLECTION_CHANGED = 816;
  ATOM_BATTERY_HEALTH = 10220;
  ATOM_HDMI_EARC_STATUS_REPORTED = 701;
  ATOM_HDMI_SOUNDBAR_MODE_STATUS_REPORTED = 724;
  ATOM_HEALTH_CONNECT_API_CALLED = 616;
  ATOM_HEALTH_CONNECT_USAGE_STATS = 617;
  ATOM_HEALTH_CONNECT_STORAGE_STATS = 618;
  ATOM_HEALTH_CONNECT_API_INVOKED = 643;
  ATOM_EXERCISE_ROUTE_API_CALLED = 654;
  ATOM_HEALTH_CONNECT_EXPORT_INVOKED = 907;
  ATOM_HEALTH_CONNECT_IMPORT_INVOKED = 918;
  ATOM_HEALTH_CONNECT_EXPORT_IMPORT_STATS_REPORTED = 919;
  ATOM_HEALTH_CONNECT_UI_IMPRESSION = 623;
  ATOM_HEALTH_CONNECT_UI_INTERACTION = 624;
  ATOM_HEALTH_CONNECT_APP_OPENED_REPORTED = 625;
  ATOM_HOTWORD_EGRESS_SIZE_ATOM_REPORTED = 761;
  ATOM_IKE_SESSION_TERMINATED = 678;
  ATOM_IKE_LIVENESS_CHECK_SESSION_VALIDATED = 760;
  ATOM_NEGOTIATED_SECURITY_ASSOCIATION = 821;
  ATOM_KEYBOARD_CONFIGURED = 682;
  ATOM_KEYBOARD_SYSTEMS_EVENT_REPORTED = 683;
  ATOM_INPUTDEVICE_USAGE_REPORTED = 686;
  ATOM_INPUT_EVENT_LATENCY_REPORTED = 932;
  ATOM_TOUCHPAD_USAGE = 10191;
  ATOM_KERNEL_OOM_KILL_OCCURRED = 754;
  ATOM_EMERGENCY_STATE_CHANGED = 633;
  ATOM_CHRE_SIGNIFICANT_MOTION_STATE_CHANGED = 868;
  ATOM_POPULATION_DENSITY_PROVIDER_LOADING_REPORTED = 1002;
  ATOM_DENSITY_BASED_COARSE_LOCATIONS_USAGE_REPORTED = 1003;
  ATOM_DENSITY_BASED_COARSE_LOCATIONS_PROVIDER_QUERY_REPORTED = 1004;
  ATOM_MEDIA_CODEC_RECLAIM_REQUEST_COMPLETED = 600;
  ATOM_MEDIA_CODEC_STARTED = 641;
  ATOM_MEDIA_CODEC_STOPPED = 642;
  ATOM_MEDIA_CODEC_RENDERED = 684;
  ATOM_MEDIA_EDITING_ENDED_REPORTED = 798;
  ATOM_MTE_STATE = 10181;
  ATOM_MICROXR_DEVICE_BOOT_COMPLETE_REPORTED = 901;
  ATOM_NFC_OBSERVE_MODE_STATE_CHANGED = 855;
  ATOM_NFC_FIELD_CHANGED = 856;
  ATOM_NFC_POLLING_LOOP_NOTIFICATION_REPORTED = 857;
  ATOM_NFC_PROPRIETARY_CAPABILITIES_REPORTED = 858;
  ATOM_ONDEVICEPERSONALIZATION_API_CALLED = 711;
  ATOM_COMPONENT_STATE_CHANGED_REPORTED = 863;
  ATOM_PDF_LOAD_REPORTED = 859;
  ATOM_PDF_API_USAGE_REPORTED = 860;
  ATOM_PDF_SEARCH_REPORTED = 861;
  ATOM_PRESSURE_STALL_INFORMATION = 10229;
  ATOM_PERMISSION_RATIONALE_DIALOG_VIEWED = 645;
  ATOM_PERMISSION_RATIONALE_DIALOG_ACTION_REPORTED = 646;
  ATOM_APP_DATA_SHARING_UPDATES_NOTIFICATION_INTERACTION = 647;
  ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_VIEWED = 648;
  ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_ACTION_REPORTED = 649;
  ATOM_ENHANCED_CONFIRMATION_DIALOG_RESULT_REPORTED = 827;
  ATOM_ENHANCED_CONFIRMATION_RESTRICTION_CLEARED = 828;
  ATOM_PHOTOPICKER_SESSION_INFO_REPORTED = 886;
  ATOM_PHOTOPICKER_API_INFO_REPORTED = 887;
  ATOM_PHOTOPICKER_UI_EVENT_LOGGED = 888;
  ATOM_PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED = 889;
  ATOM_PHOTOPICKER_PREVIEW_INFO_LOGGED = 890;
  ATOM_PHOTOPICKER_MENU_INTERACTION_LOGGED = 891;
  ATOM_PHOTOPICKER_BANNER_INTERACTION_LOGGED = 892;
  ATOM_PHOTOPICKER_MEDIA_LIBRARY_INFO_LOGGED = 893;
  ATOM_PHOTOPICKER_PAGE_INFO_LOGGED = 894;
  ATOM_PHOTOPICKER_MEDIA_GRID_SYNC_INFO_REPORTED = 895;
  ATOM_PHOTOPICKER_ALBUM_SYNC_INFO_REPORTED = 896;
  ATOM_PHOTOPICKER_SEARCH_INFO_REPORTED = 897;
  ATOM_SEARCH_DATA_EXTRACTION_DETAILS_REPORTED = 898;
  ATOM_EMBEDDED_PHOTOPICKER_INFO_REPORTED = 899;
  ATOM_ATOM_9999 = 9999;
  ATOM_ATOM_99999 = 99999;
  ATOM_SCREEN_OFF_REPORTED = 776;
  ATOM_SCREEN_TIMEOUT_OVERRIDE_REPORTED = 836;
  ATOM_SCREEN_INTERACTIVE_SESSION_REPORTED = 837;
  ATOM_SCREEN_DIM_REPORTED = 867;
  ATOM_MEDIA_PROVIDER_DATABASE_ROLLBACK_REPORTED = 784;
  ATOM_BACKUP_SETUP_STATUS_REPORTED = 785;
  ATOM_RANGING_SESSION_CONFIGURED = 993;
  ATOM_RANGING_SESSION_STARTED = 994;
  ATOM_RANGING_SESSION_CLOSED = 995;
  ATOM_RANGING_TECHNOLOGY_STARTED = 996;
  ATOM_RANGING_TECHNOLOGY_STOPPED = 997;
  ATOM_RKPD_POOL_STATS = 664;
  ATOM_RKPD_CLIENT_OPERATION = 665;
  ATOM_SANDBOX_API_CALLED = 488;
  ATOM_SANDBOX_ACTIVITY_EVENT_OCCURRED = 735;
  ATOM_SDK_SANDBOX_RESTRICTED_ACCESS_IN_SESSION = 796;
  ATOM_SANDBOX_SDK_STORAGE = 10159;
  ATOM_SELINUX_AUDIT_LOG = 799;
  ATOM_SETTINGS_SPA_REPORTED = 622;
  ATOM_TEST_EXTENSION_ATOM_REPORTED = 660;
  ATOM_TEST_RESTRICTED_ATOM_REPORTED = 672;
  ATOM_STATS_SOCKET_LOSS_REPORTED = 752;
  ATOM_LOCKSCREEN_SHORTCUT_SELECTED = 611;
  ATOM_LOCKSCREEN_SHORTCUT_TRIGGERED = 612;
  ATOM_LAUNCHER_IMPRESSION_EVENT_V2 = 716;
  ATOM_DISPLAY_SWITCH_LATENCY_TRACKED = 753;
  ATOM_NOTIFICATION_LISTENER_SERVICE = 829;
  ATOM_NAV_HANDLE_TOUCH_POINTS = 869;
  ATOM_COMMUNAL_HUB_WIDGET_EVENT_REPORTED = 908;
  ATOM_COMMUNAL_HUB_SNAPSHOT = 10226;
  ATOM_EMERGENCY_NUMBER_DIALED = 637;
  ATOM_CALL_STATS = 10221;
  ATOM_CALL_AUDIO_ROUTE_STATS = 10222;
  ATOM_TELECOM_API_STATS = 10223;
  ATOM_TELECOM_ERROR_STATS = 10224;
  ATOM_CELLULAR_RADIO_POWER_STATE_CHANGED = 713;
  ATOM_EMERGENCY_NUMBERS_INFO = 10180;
  ATOM_DATA_NETWORK_VALIDATION = 10207;
  ATOM_DATA_RAT_STATE_CHANGED = 854;
  ATOM_CONNECTED_CHANNEL_CHANGED = 882;
  ATOM_IWLAN_UNDERLYING_NETWORK_VALIDATION_RESULT_REPORTED = 923;
  ATOM_QUALIFIED_RAT_LIST_CHANGED = 634;
  ATOM_QNS_IMS_CALL_DROP_STATS = 635;
  ATOM_QNS_FALLBACK_RESTRICTION_CHANGED = 636;
  ATOM_QNS_RAT_PREFERENCE_MISMATCH_INFO = 10177;
  ATOM_QNS_HANDOVER_TIME_MILLIS = 10178;
  ATOM_QNS_HANDOVER_PINGPONG = 10179;
  ATOM_SATELLITE_CONTROLLER = 10182;
  ATOM_SATELLITE_SESSION = 10183;
  ATOM_SATELLITE_INCOMING_DATAGRAM = 10184;
  ATOM_SATELLITE_OUTGOING_DATAGRAM = 10185;
  ATOM_SATELLITE_PROVISION = 10186;
  ATOM_SATELLITE_SOS_MESSAGE_RECOMMENDER = 10187;
  ATOM_CARRIER_ROAMING_SATELLITE_SESSION = 10211;
  ATOM_CARRIER_ROAMING_SATELLITE_CONTROLLER_STATS = 10212;
  ATOM_CONTROLLER_STATS_PER_PACKAGE = 10213;
  ATOM_SATELLITE_ENTITLEMENT = 10214;
  ATOM_SATELLITE_CONFIG_UPDATER = 10215;
  ATOM_SATELLITE_ACCESS_CONTROLLER = 10219;
  ATOM_CELLULAR_IDENTIFIER_DISCLOSED = 800;
  ATOM_THREADNETWORK_TELEMETRY_DATA_REPORTED = 738;
  ATOM_THREADNETWORK_TOPO_ENTRY_REPEATED = 739;
  ATOM_THREADNETWORK_DEVICE_INFO_REPORTED = 740;
  ATOM_BOOT_INTEGRITY_INFO_REPORTED = 775;
  ATOM_TV_LOW_POWER_STANDBY_POLICY = 679;
  ATOM_EXTERNAL_TV_INPUT_EVENT = 717;
  ATOM_TEST_UPROBESTATS_ATOM_REPORTED = 915;
  ATOM_UWB_ACTIVITY_INFO = 10188;
  ATOM_MEDIATOR_UPDATED = 721;
  ATOM_SYSPROXY_BLUETOOTH_BYTES_TRANSFER = 10196;
  ATOM_SYSPROXY_CONNECTION_UPDATED = 786;
  ATOM_WEAR_COMPANION_CONNECTION_STATE = 921;
  ATOM_MEDIA_ACTION_REPORTED = 608;
  ATOM_MEDIA_CONTROLS_LAUNCHED = 609;
  ATOM_MEDIA_SESSION_STATE_CHANGED = 677;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_API_LATENCY = 757;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_SASS_DEVICE_UNAVAILABLE = 758;
  ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FASTPAIR_API_TIMEOUT = 759;
  ATOM_WEAR_MODE_STATE_CHANGED = 715;
  ATOM_RENDERER_INITIALIZED = 736;
  ATOM_SCHEMA_VERSION_RECEIVED = 737;
  ATOM_LAYOUT_INSPECTED = 741;
  ATOM_LAYOUT_EXPRESSION_INSPECTED = 742;
  ATOM_LAYOUT_ANIMATIONS_INSPECTED = 743;
  ATOM_MATERIAL_COMPONENTS_INSPECTED = 744;
  ATOM_TILE_REQUESTED = 745;
  ATOM_STATE_RESPONSE_RECEIVED = 746;
  ATOM_TILE_RESPONSE_RECEIVED = 747;
  ATOM_INFLATION_FINISHED = 748;
  ATOM_INFLATION_FAILED = 749;
  ATOM_IGNORED_INFLATION_FAILURES_REPORTED = 750;
  ATOM_DRAWABLE_RENDERED = 751;
  ATOM_WEAR_TIME_SYNC_REQUESTED = 911;
  ATOM_WEAR_TIME_UPDATE_STARTED = 912;
  ATOM_WEAR_TIME_SYNC_ATTEMPT_COMPLETED = 913;
  ATOM_WEAR_TIME_CHANGED = 914;
  ATOM_WEAR_ADAPTIVE_SUSPEND_STATS_REPORTED = 619;
  ATOM_WEAR_POWER_ANOMALY_SERVICE_OPERATIONAL_STATS_REPORTED = 620;
  ATOM_WEAR_POWER_ANOMALY_SERVICE_EVENT_STATS_REPORTED = 621;
  ATOM_WS_WEAR_TIME_SESSION = 610;
  ATOM_WS_INCOMING_CALL_ACTION_REPORTED = 626;
  ATOM_WS_CALL_DISCONNECTION_REPORTED = 627;
  ATOM_WS_CALL_DURATION_REPORTED = 628;
  ATOM_WS_CALL_USER_EXPERIENCE_LATENCY_REPORTED = 629;
  ATOM_WS_CALL_INTERACTION_REPORTED = 630;
  ATOM_WS_ON_BODY_STATE_CHANGED = 787;
  ATOM_WS_WATCH_FACE_RESTRICTED_COMPLICATIONS_IMPACTED = 802;
  ATOM_WS_WATCH_FACE_DEFAULT_RESTRICTED_COMPLICATIONS_REMOVED = 803;
  ATOM_WS_COMPLICATIONS_IMPACTED_NOTIFICATION_EVENT_REPORTED = 804;
  ATOM_WS_REMOTE_EVENT_USAGE_REPORTED = 920;
  ATOM_WS_BUGREPORT_REQUESTED = 936;
  ATOM_WS_BUGREPORT_TRIGGERED = 937;
  ATOM_WS_BUGREPORT_FINISHED = 938;
  ATOM_WS_BUGREPORT_RESULT_RECEIVED = 939;
  ATOM_WS_STANDALONE_MODE_SNAPSHOT = 10197;
  ATOM_WS_FAVORITE_WATCH_FACE_SNAPSHOT = 10206;
  ATOM_WS_PHOTOS_WATCH_FACE_FEATURE_SNAPSHOT = 10225;
  ATOM_WS_WATCH_FACE_CUSTOMIZATION_SNAPSHOT = 10227;
  ATOM_WEAR_POWER_MENU_OPENED = 731;
  ATOM_WEAR_ASSISTANT_OPENED = 755;
  ATOM_FIRST_OVERLAY_STATE_CHANGED = 917;
  ATOM_WIFI_AWARE_NDP_REPORTED = 638;
  ATOM_WIFI_AWARE_ATTACH_REPORTED = 639;
  ATOM_WIFI_SELF_RECOVERY_TRIGGERED = 661;
  ATOM_SOFT_AP_STARTED = 680;
  ATOM_SOFT_AP_STOPPED = 681;
  ATOM_WIFI_LOCK_RELEASED = 687;
  ATOM_WIFI_LOCK_DEACTIVATED = 688;
  ATOM_WIFI_CONFIG_SAVED = 689;
  ATOM_WIFI_AWARE_RESOURCE_USING_CHANGED = 690;
  ATOM_WIFI_AWARE_HAL_API_CALLED = 691;
  ATOM_WIFI_LOCAL_ONLY_REQUEST_RECEIVED = 692;
  ATOM_WIFI_LOCAL_ONLY_REQUEST_SCAN_TRIGGERED = 693;
  ATOM_WIFI_THREAD_TASK_EXECUTED = 694;
  ATOM_WIFI_STATE_CHANGED = 700;
  ATOM_PNO_SCAN_STARTED = 719;
  ATOM_PNO_SCAN_STOPPED = 720;
  ATOM_WIFI_IS_UNUSABLE_REPORTED = 722;
  ATOM_WIFI_AP_CAPABILITIES_REPORTED = 723;
  ATOM_SOFT_AP_STATE_CHANGED = 805;
  ATOM_SCORER_PREDICTION_RESULT_REPORTED = 884;
  ATOM_WIFI_AWARE_CAPABILITIES = 10190;
  ATOM_WIFI_MODULE_INFO = 10193;
  ATOM_WIFI_SETTING_INFO = 10194;
  ATOM_WIFI_COMPLEX_SETTING_INFO = 10195;
  ATOM_WIFI_CONFIGURED_NETWORK_INFO = 10198;
}
// End of protos/perfetto/config/statsd/atom_ids.proto

// Begin of protos/perfetto/config/statsd/statsd_tracing_config.proto

// This file is named 'statsd_tracing_config.proto' rather than
// 'statsd_config.proto' (which would be more consistent with the other
// config protos) so it doesn't show up and confuse folks looking for
// the existing statsd_config.proto for configuring statsd itself.
// Same for the config proto itself.
message StatsdTracingConfig {
  // This is for the common case of the atom id being known in the enum AtomId.
  repeated AtomId push_atom_id = 1;

  // Escape hatch for Atom IDs that are not yet in the AtomId enum
  // (e.g. non-upstream atoms that don't exist in AOSP).
  repeated int32 raw_push_atom_id = 2;
  repeated StatsdPullAtomConfig pull_config = 3;
}

message StatsdPullAtomConfig {
  repeated AtomId pull_atom_id = 1;
  repeated int32 raw_pull_atom_id = 2;

  optional int32 pull_frequency_ms = 3;
  repeated string packages = 4;
}

// End of protos/perfetto/config/statsd/statsd_tracing_config.proto

// Begin of protos/perfetto/common/sys_stats_counters.proto

// When editing entries here remember also to update "sys_stats_counters.h" with
// the corresponding string definitions for the actual /proc files parser.

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0;
  MEMINFO_MEM_TOTAL = 1;
  MEMINFO_MEM_FREE = 2;
  MEMINFO_MEM_AVAILABLE = 3;
  MEMINFO_BUFFERS = 4;
  MEMINFO_CACHED = 5;
  MEMINFO_SWAP_CACHED = 6;
  MEMINFO_ACTIVE = 7;
  MEMINFO_INACTIVE = 8;
  MEMINFO_ACTIVE_ANON = 9;
  MEMINFO_INACTIVE_ANON = 10;
  MEMINFO_ACTIVE_FILE = 11;
  MEMINFO_INACTIVE_FILE = 12;
  MEMINFO_UNEVICTABLE = 13;
  MEMINFO_MLOCKED = 14;
  MEMINFO_SWAP_TOTAL = 15;
  MEMINFO_SWAP_FREE = 16;
  MEMINFO_DIRTY = 17;
  MEMINFO_WRITEBACK = 18;
  MEMINFO_ANON_PAGES = 19;
  MEMINFO_MAPPED = 20;
  MEMINFO_SHMEM = 21;
  MEMINFO_SLAB = 22;
  MEMINFO_SLAB_RECLAIMABLE = 23;
  MEMINFO_SLAB_UNRECLAIMABLE = 24;
  MEMINFO_KERNEL_STACK = 25;
  MEMINFO_PAGE_TABLES = 26;
  MEMINFO_COMMIT_LIMIT = 27;
  MEMINFO_COMMITED_AS = 28;
  MEMINFO_VMALLOC_TOTAL = 29;
  MEMINFO_VMALLOC_USED = 30;
  MEMINFO_VMALLOC_CHUNK = 31;
  MEMINFO_CMA_TOTAL = 32;
  MEMINFO_CMA_FREE = 33;
  MEMINFO_GPU = 34;
  MEMINFO_ZRAM = 35;
  MEMINFO_MISC = 36;
  MEMINFO_ION_HEAP = 37;
  MEMINFO_ION_HEAP_POOL = 38;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0;
  VMSTAT_NR_FREE_PAGES = 1;
  VMSTAT_NR_ALLOC_BATCH = 2;
  VMSTAT_NR_INACTIVE_ANON = 3;
  VMSTAT_NR_ACTIVE_ANON = 4;
  VMSTAT_NR_INACTIVE_FILE = 5;
  VMSTAT_NR_ACTIVE_FILE = 6;
  VMSTAT_NR_UNEVICTABLE = 7;
  VMSTAT_NR_MLOCK = 8;
  VMSTAT_NR_ANON_PAGES = 9;
  VMSTAT_NR_MAPPED = 10;
  VMSTAT_NR_FILE_PAGES = 11;
  VMSTAT_NR_DIRTY = 12;
  VMSTAT_NR_WRITEBACK = 13;
  VMSTAT_NR_SLAB_RECLAIMABLE = 14;
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;
  VMSTAT_NR_PAGE_TABLE_PAGES = 16;
  VMSTAT_NR_KERNEL_STACK = 17;
  VMSTAT_NR_OVERHEAD = 18;
  VMSTAT_NR_UNSTABLE = 19;
  VMSTAT_NR_BOUNCE = 20;
  VMSTAT_NR_VMSCAN_WRITE = 21;
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  VMSTAT_NR_WRITEBACK_TEMP = 23;
  VMSTAT_NR_ISOLATED_ANON = 24;
  VMSTAT_NR_ISOLATED_FILE = 25;
  VMSTAT_NR_SHMEM = 26;
  VMSTAT_NR_DIRTIED = 27;
  VMSTAT_NR_WRITTEN = 28;
  VMSTAT_NR_PAGES_SCANNED = 29;
  VMSTAT_WORKINGSET_REFAULT = 30;
  VMSTAT_WORKINGSET_ACTIVATE = 31;
  VMSTAT_WORKINGSET_NODERECLAIM = 32;
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  VMSTAT_NR_FREE_CMA = 34;
  VMSTAT_NR_SWAPCACHE = 35;
  VMSTAT_NR_DIRTY_THRESHOLD = 36;
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  VMSTAT_PGPGIN = 38;
  VMSTAT_PGPGOUT = 39;
  VMSTAT_PGPGOUTCLEAN = 40;
  VMSTAT_PSWPIN = 41;
  VMSTAT_PSWPOUT = 42;
  VMSTAT_PGALLOC_DMA = 43;
  VMSTAT_PGALLOC_NORMAL = 44;
  VMSTAT_PGALLOC_MOVABLE = 45;
  VMSTAT_PGFREE = 46;
  VMSTAT_PGACTIVATE = 47;
  VMSTAT_PGDEACTIVATE = 48;
  VMSTAT_PGFAULT = 49;
  VMSTAT_PGMAJFAULT = 50;
  VMSTAT_PGREFILL_DMA = 51;
  VMSTAT_PGREFILL_NORMAL = 52;
  VMSTAT_PGREFILL_MOVABLE = 53;
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54;
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;
  VMSTAT_PGSTEAL_DIRECT_DMA = 57;
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;
  VMSTAT_PGSCAN_KSWAPD_DMA = 60;
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;
  VMSTAT_PGSCAN_DIRECT_DMA = 63;
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64;
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;
  VMSTAT_PGINODESTEAL = 67;
  VMSTAT_SLABS_SCANNED = 68;
  VMSTAT_KSWAPD_INODESTEAL = 69;
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  VMSTAT_PAGEOUTRUN = 72;
  VMSTAT_ALLOCSTALL = 73;
  VMSTAT_PGROTATED = 74;
  VMSTAT_DROP_PAGECACHE = 75;
  VMSTAT_DROP_SLAB = 76;
  VMSTAT_PGMIGRATE_SUCCESS = 77;
  VMSTAT_PGMIGRATE_FAIL = 78;
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79;
  VMSTAT_COMPACT_FREE_SCANNED = 80;
  VMSTAT_COMPACT_ISOLATED = 81;
  VMSTAT_COMPACT_STALL = 82;
  VMSTAT_COMPACT_FAIL = 83;
  VMSTAT_COMPACT_SUCCESS = 84;
  VMSTAT_COMPACT_DAEMON_WAKE = 85;
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86;
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;
  VMSTAT_NR_ZSPAGES = 93;
  VMSTAT_NR_ION_HEAP = 94;
  VMSTAT_NR_GPU_HEAP = 95;
  VMSTAT_ALLOCSTALL_DMA = 96;
  VMSTAT_ALLOCSTALL_MOVABLE = 97;
  VMSTAT_ALLOCSTALL_NORMAL = 98;
  VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99;
  VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100;
  VMSTAT_NR_FASTRPC = 101;
  VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102;
  VMSTAT_NR_ION_HEAP_POOL = 103;
  VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104;
  VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105;
  VMSTAT_NR_SHMEM_HUGEPAGES = 106;
  VMSTAT_NR_SHMEM_PMDMAPPED = 107;
  VMSTAT_NR_UNRECLAIMABLE_PAGES = 108;
  VMSTAT_NR_ZONE_ACTIVE_ANON = 109;
  VMSTAT_NR_ZONE_ACTIVE_FILE = 110;
  VMSTAT_NR_ZONE_INACTIVE_ANON = 111;
  VMSTAT_NR_ZONE_INACTIVE_FILE = 112;
  VMSTAT_NR_ZONE_UNEVICTABLE = 113;
  VMSTAT_NR_ZONE_WRITE_PENDING = 114;
  VMSTAT_OOM_KILL = 115;
  VMSTAT_PGLAZYFREE = 116;
  VMSTAT_PGLAZYFREED = 117;
  VMSTAT_PGREFILL = 118;
  VMSTAT_PGSCAN_DIRECT = 119;
  VMSTAT_PGSCAN_KSWAPD = 120;
  VMSTAT_PGSKIP_DMA = 121;
  VMSTAT_PGSKIP_MOVABLE = 122;
  VMSTAT_PGSKIP_NORMAL = 123;
  VMSTAT_PGSTEAL_DIRECT = 124;
  VMSTAT_PGSTEAL_KSWAPD = 125;
  VMSTAT_SWAP_RA = 126;
  VMSTAT_SWAP_RA_HIT = 127;
  VMSTAT_WORKINGSET_RESTORE = 128;
  VMSTAT_ALLOCSTALL_DEVICE = 129;
  VMSTAT_ALLOCSTALL_DMA32 = 130;
  VMSTAT_BALLOON_DEFLATE = 131;
  VMSTAT_BALLOON_INFLATE = 132;
  VMSTAT_BALLOON_MIGRATE = 133;
  VMSTAT_CMA_ALLOC_FAIL = 134;
  VMSTAT_CMA_ALLOC_SUCCESS = 135;
  VMSTAT_NR_FILE_HUGEPAGES = 136;
  VMSTAT_NR_FILE_PMDMAPPED = 137;
  VMSTAT_NR_FOLL_PIN_ACQUIRED = 138;
  VMSTAT_NR_FOLL_PIN_RELEASED = 139;
  VMSTAT_NR_SEC_PAGE_TABLE_PAGES = 140;
  VMSTAT_NR_SHADOW_CALL_STACK = 141;
  VMSTAT_NR_SWAPCACHED = 142;
  VMSTAT_NR_THROTTLED_WRITTEN = 143;
  VMSTAT_PGALLOC_DEVICE = 144;
  VMSTAT_PGALLOC_DMA32 = 145;
  VMSTAT_PGDEMOTE_DIRECT = 146;
  VMSTAT_PGDEMOTE_KSWAPD = 147;
  VMSTAT_PGREUSE = 148;
  VMSTAT_PGSCAN_ANON = 149;
  VMSTAT_PGSCAN_FILE = 150;
  VMSTAT_PGSKIP_DEVICE = 151;
  VMSTAT_PGSKIP_DMA32 = 152;
  VMSTAT_PGSTEAL_ANON = 153;
  VMSTAT_PGSTEAL_FILE = 154;
  VMSTAT_THP_COLLAPSE_ALLOC = 155;
  VMSTAT_THP_COLLAPSE_ALLOC_FAILED = 156;
  VMSTAT_THP_DEFERRED_SPLIT_PAGE = 157;
  VMSTAT_THP_FAULT_ALLOC = 158;
  VMSTAT_THP_FAULT_FALLBACK = 159;
  VMSTAT_THP_FAULT_FALLBACK_CHARGE = 160;
  VMSTAT_THP_FILE_ALLOC = 161;
  VMSTAT_THP_FILE_FALLBACK = 162;
  VMSTAT_THP_FILE_FALLBACK_CHARGE = 163;
  VMSTAT_THP_FILE_MAPPED = 164;
  VMSTAT_THP_MIGRATION_FAIL = 165;
  VMSTAT_THP_MIGRATION_SPLIT = 166;
  VMSTAT_THP_MIGRATION_SUCCESS = 167;
  VMSTAT_THP_SCAN_EXCEED_NONE_PTE = 168;
  VMSTAT_THP_SCAN_EXCEED_SHARE_PTE = 169;
  VMSTAT_THP_SCAN_EXCEED_SWAP_PTE = 170;
  VMSTAT_THP_SPLIT_PAGE = 171;
  VMSTAT_THP_SPLIT_PAGE_FAILED = 172;
  VMSTAT_THP_SPLIT_PMD = 173;
  VMSTAT_THP_SWPOUT = 174;
  VMSTAT_THP_SWPOUT_FALLBACK = 175;
  VMSTAT_THP_ZERO_PAGE_ALLOC = 176;
  VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED = 177;
  VMSTAT_VMA_LOCK_ABORT = 178;
  VMSTAT_VMA_LOCK_MISS = 179;
  VMSTAT_VMA_LOCK_RETRY = 180;
  VMSTAT_VMA_LOCK_SUCCESS = 181;
  VMSTAT_WORKINGSET_ACTIVATE_ANON = 182;
  VMSTAT_WORKINGSET_ACTIVATE_FILE = 183;
  VMSTAT_WORKINGSET_NODES = 184;
  VMSTAT_WORKINGSET_REFAULT_ANON = 185;
  VMSTAT_WORKINGSET_REFAULT_FILE = 186;
  VMSTAT_WORKINGSET_RESTORE_ANON = 187;
  VMSTAT_WORKINGSET_RESTORE_FILE = 188;
}

// End of protos/perfetto/common/sys_stats_counters.proto

// Begin of protos/perfetto/config/sys_stats/sys_stats_config.proto

// This file defines the configuration for the Linux /proc poller data source,
// which injects counters in the trace.
// Counters that are needed in the trace must be explicitly listed in the
// *_counters fields. This is to avoid spamming the trace with all counters
// at all times.
// The sampling rate is configurable. All polling rates (*_period_ms) need
// to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
message SysStatsConfig {
  // Polls /proc/meminfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
  optional uint32 meminfo_period_ms = 1;

  // If empty all known counters are reported. Otherwise, only the counters
  // specified below are reported.
  repeated MeminfoCounters meminfo_counters = 2;

  // Polls /proc/vmstat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
  optional uint32 vmstat_period_ms = 3;
  repeated VmstatCounters vmstat_counters = 4;

  // Pols /proc/stat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
  optional uint32 stat_period_ms = 5;
  enum StatCounters {
    STAT_UNSPECIFIED = 0;
    STAT_CPU_TIMES = 1;
    STAT_IRQ_COUNTS = 2;
    STAT_SOFTIRQ_COUNTS = 3;
    STAT_FORK_COUNT = 4;
  }
  repeated StatCounters stat_counters = 6;

  // Polls /sys/devfreq/*/curfreq every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // This option can be used to record unchanging values.
  // Updates from frequency changes can come from ftrace/set_clock_rate.
  optional uint32 devfreq_period_ms = 7;

  // Polls /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq every X ms.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpufreq_period_ms = 8;

  // Polls /proc/buddyinfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 buddyinfo_period_ms = 9;

  // Polls /proc/diskstats every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 diskstat_period_ms = 10;

  // Polls /proc/pressure/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 psi_period_ms = 11;

  // Polls /sys/class/thermal/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 thermal_period_ms = 12;

  // Polls /sys/devices/system/cpu/cpu*/cpuidle/state* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpuidle_period_ms = 13;

  // Polls device-specific GPU frequency info every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 gpufreq_period_ms = 14;
}

// End of protos/perfetto/config/sys_stats/sys_stats_config.proto

// Begin of protos/perfetto/config/system_info/system_info_config.proto

// This data-source does a one-off recording of system information when
// the trace starts.
// Currently this includes:
// - Values of
// /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies This
// datasource has no configuration options at present.
message SystemInfoConfig {}

// End of protos/perfetto/config/system_info/system_info_config.proto

// Begin of protos/perfetto/config/test_config.proto

// The configuration for a fake producer used in tests.
message TestConfig {
  message DummyFields {
    optional uint32 field_uint32 = 1;
    optional int32 field_int32 = 2;
    optional uint64 field_uint64 = 3;
    optional int64 field_int64 = 4;
    optional fixed64 field_fixed64 = 5;
    optional sfixed64 field_sfixed64 = 6;
    optional fixed32 field_fixed32 = 7;
    optional sfixed32 field_sfixed32 = 8;
    optional double field_double = 9;
    optional float field_float = 10;
    optional sint64 field_sint64 = 11;
    optional sint32 field_sint32 = 12;
    optional string field_string = 13;
    optional bytes field_bytes = 14;
  }

  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;

  optional DummyFields dummy_fields = 6;
}

// End of protos/perfetto/config/test_config.proto

// Begin of protos/perfetto/config/track_event/track_event_config.proto

message TrackEventConfig {
  // The following fields define the set of enabled trace categories. Each list
  // item is a glob.
  //
  // To determine if category is enabled, it is checked against the filters in
  // the following order:
  //
  //   1. Exact matches in enabled categories.
  //   2. Exact matches in enabled tags.
  //   3. Exact matches in disabled categories.
  //   4. Exact matches in disabled tags.
  //   5. Pattern matches in enabled categories.
  //   6. Pattern matches in enabled tags.
  //   7. Pattern matches in disabled categories.
  //   8. Pattern matches in disabled tags.
  //
  // If none of the steps produced a match:
  //  - In the C++ SDK (`perfetto::Category`), categories are enabled by
  //  default.
  //  - In the C SDK (`PerfettoTeCategory`), categories are disabled by default.
  //
  // Examples:
  //
  //  - To enable all non-slow/debug categories:
  //
  //       enabled_categories: "*"
  //
  //  - To enable specific categories:
  //
  //       disabled_categories: "*"
  //       enabled_categories: "my_category"
  //       enabled_categories: "my_category2"
  //
  //  - To enable only categories with a specific tag:
  //
  //       disabled_tags: "*"
  //       enabled_tags: "my_tag"
  //

  // Default: []
  repeated string disabled_categories = 1;

  // Default: []
  repeated string enabled_categories = 2;

  // Default: ["slow", "debug"]
  repeated string disabled_tags = 3;

  // Default: []
  repeated string enabled_tags = 4;

  // Default: false (i.e. enabled by default)
  optional bool disable_incremental_timestamps = 5;

  // Allows to specify a custom unit different than the default (ns).
  // Also affects thread timestamps if enable_thread_time_sampling = true.
  // A multiplier of 1000 means that a timestamp = 3 should be interpreted as
  // 3000 ns = 3 us.
  // Default: 1 (if unset, it should be read as 1).
  optional uint64 timestamp_unit_multiplier = 6;

  // Default: false (i.e. debug_annotations is NOT filtered out by default)
  // When true, any debug annotations provided as arguments to the
  // TRACE_EVENT macros are not written into the trace. Typed arguments will
  // still be emitted even if set to true.
  optional bool filter_debug_annotations = 7;

  // Default: false (i.e. disabled)
  // When true, the SDK samples and emits the current thread time counter value
  // for each event on the current thread's track. This value represents the
  // total CPU time consumed by that thread since its creation.
  // Learn more: "CLOCK_THREAD_CPUTIME_ID" flag at
  // https://man7.org/linux/man-pages/man3/clock_gettime.3.html
  optional bool enable_thread_time_sampling = 8;

  // When enable_thread_time_sampling is true, and this is specified, thread
  // time is sampled only if the elapsed wall time >
  // `thread_time_subsampling_ns`. Otherwise, thread time is considered nil.
  // Effectively, this means thread time will have a leeway of
  // `thread_time_subsampling_ns` and won't be emitted for shorter events.
  optional uint64 thread_time_subsampling_ns = 10;

  // Default: false (i.e. dynamic event names are NOT filtered out by default)
  // When true, event_names wrapped in perfetto::DynamicString will be filtered
  // out.
  optional bool filter_dynamic_event_names = 9;
}

// End of protos/perfetto/config/track_event/track_event_config.proto

// Begin of protos/perfetto/config/data_source_config.proto

// The configuration that is passed to each data source when starting tracing.
// Next id: 139
message DataSourceConfig {
  enum SessionInitiator {
    SESSION_INITIATOR_UNSPECIFIED = 0;
    // This trace was initiated from a trusted system app has DUMP and
    // USAGE_STATS permission. This system app is expected to not expose the
    // trace to the user of the device.
    // This is determined by checking the UID initiating the trace.
    SESSION_INITIATOR_TRUSTED_SYSTEM = 1;
  };
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // If true, |trace_duration_ms| should count also time in suspend. This
  // is propagated from TraceConfig.prefer_suspend_clock_for_duration.
  optional bool prefer_suspend_clock_for_duration = 122;

  // Set by the service to indicate how long it waits after StopDataSource.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 stop_timeout_ms = 7;

  // Set by the service to indicate whether this tracing session has extra
  // guardrails.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional bool enable_extra_guardrails = 6;

  // Set by the service to indicate which user initiated this trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional SessionInitiator session_initiator = 8;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint64 tracing_session_id = 4;

  enum BufferExhaustedPolicy {
    // The data source will use its default buffer exhausted policy, specified
    // by the code when the data source is registered.
    BUFFER_EXHAUSTED_UNSPECIFIED = 0;
    // The data source will drop packets when there's no space in the shared
    // memory buffer.
    BUFFER_EXHAUSTED_DROP = 1;
    // The data source will wait when there's no space in the shared memory
    // buffer. If there's still not space, after a few seconds, the whole
    // producer process will be aborted.
    BUFFER_EXHAUSTED_STALL_THEN_ABORT = 2;
    // The data source will wait when there's no space in the shared memory
    // buffer.  If there's still not space, after a few seconds, the data source
    // will drop packets.
    BUFFER_EXHAUSTED_STALL_THEN_DROP = 3;
  };
  // How to behave when the producer runs out of space in the shared memory
  // buffer. This is only honored by some data sources (in the SDK, the data
  // sources registered with a configurable buffer exhausted policy).
  optional BufferExhaustedPolicy buffer_exhausted_policy = 9;

  optional PriorityBoostConfig priority_boost = 10;

  // Keep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  // All data source config fields must be marked as [lazy=true]. This prevents
  // the proto-to-cpp generator from recursing into those when generating the
  // cpp classes and polluting tracing/core with data-source-specific classes.
  // Instead they are treated as opaque strings containing raw proto bytes.

  // Data source name: linux.ftrace
  optional FtraceConfig ftrace_config = 100 [lazy = true];
  // Data source name: linux.inode_file_map
  optional InodeFileConfig inode_file_config = 102 [lazy = true];
  // Data source name: linux.process_stats
  optional ProcessStatsConfig process_stats_config = 103 [lazy = true];
  // Data source name: linux.sys_stats
  optional SysStatsConfig sys_stats_config = 104 [lazy = true];
  // Data source name: android.heapprofd
  // Introduced in Android 10.
  optional HeapprofdConfig heapprofd_config = 105 [lazy = true];
  // Data source name: android.java_hprof
  // Introduced in Android 11.
  optional JavaHprofConfig java_hprof_config = 110 [lazy = true];
  // Data source name: android.power
  optional AndroidPowerConfig android_power_config = 106 [lazy = true];
  // Data source name: android.log
  optional AndroidLogConfig android_log_config = 107 [lazy = true];
  // Data source name: gpu.counters
  optional GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  // Data source name: android.game_interventions
  optional AndroidGameInterventionListConfig
      android_game_intervention_list_config = 116 [lazy = true];
  // Data source name: android.packages_list
  optional PackagesListConfig packages_list_config = 109 [lazy = true];
  // Data source name: linux.perf
  optional PerfEventConfig perf_event_config = 111 [lazy = true];
  // Data source name: vulkan.memory_tracker
  optional VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];
  // Data source name: track_event
  optional TrackEventConfig track_event_config = 113 [lazy = true];
  // Data source name: android.polled_state
  optional AndroidPolledStateConfig android_polled_state_config = 114
      [lazy = true];
  // Data source name: android.system_property
  optional AndroidSystemPropertyConfig android_system_property_config = 118
      [lazy = true];
  // Data source name: android.statsd
  optional StatsdTracingConfig statsd_tracing_config = 117 [lazy = true];
  // Data source name: linux.system_info
  optional SystemInfoConfig system_info_config = 119;
  // Data source name: linux.frozen_ftrace
  optional FrozenFtraceConfig frozen_ftrace_config = 136 [lazy = true];

  // Chrome is special as it doesn't use the perfetto IPC layer. We want to
  // avoid proto serialization and de-serialization there because that would
  // just add extra hops on top of the Mojo ser/des. Instead we auto-generate a
  // C++ class for it so it can pass around plain C++ objets.
  optional ChromeConfig chrome_config = 101;

  // Data source name: code.v8.dev
  optional V8Config v8_config = 127 [lazy = true];

  // If an interceptor is specified here, packets for this data source will be
  // rerouted to the interceptor instead of the main trace buffer. This can be
  // used, for example, to write trace data into ETW or for logging trace points
  // to the console.
  //
  // Note that interceptors are only supported by data sources registered
  // through the Perfetto SDK API. Data sources that don't use that API (e.g.,
  // traced_probes) may not support interception.
  optional InterceptorConfig interceptor_config = 115;

  // Data source name: android.network_packets.
  // Introduced in Android 14 (U).
  optional NetworkPacketTraceConfig network_packet_trace_config = 120
      [lazy = true];

  // Data source name: android.surfaceflinger.layers
  optional SurfaceFlingerLayersConfig surfaceflinger_layers_config = 121
      [lazy = true];

  // Data source name: android.surfaceflinger.transactions
  optional SurfaceFlingerTransactionsConfig surfaceflinger_transactions_config =
      123 [lazy = true];

  // Data source name: android.sdk_sysprop_guard
  // Introduced in Android 14 (U) QPR1.
  optional AndroidSdkSyspropGuardConfig android_sdk_sysprop_guard_config = 124
      [lazy = true];

  // Data source name: windows.etw
  optional EtwConfig etw_config = 125 [lazy = true];

  // Data source name: android.protolog
  optional ProtoLogConfig protolog_config = 126 [lazy = true];

  // Data source name: android.input.inputevent
  optional AndroidInputEventConfig android_input_event_config = 128
      [lazy = true];

  // Data source name: android.pixel.modem
  optional PixelModemConfig pixel_modem_config = 129 [lazy = true];

  // Data source name: android.windowmanager
  optional WindowManagerConfig windowmanager_config = 130 [lazy = true];

  // Data source name: org.chromium.system_metrics
  optional ChromiumSystemMetricsConfig chromium_system_metrics = 131
      [lazy = true];

  // Data source name: android.kernel_wakelocks
  optional KernelWakelocksConfig kernel_wakelocks_config = 132 [lazy = true];

  // Data source name: gpu.renderstages
  optional GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];

  // Data source name: org.chromium.histogram_samples
  optional ChromiumHistogramSamplesConfig chromium_histogram_samples = 134
      [lazy = true];

  // Data source name: android.app_wakelocks
  optional AppWakelocksConfig app_wakelocks_config = 135 [lazy = true];

  // Data source name: android.cpu_per_uid
  optional CpuPerUidConfig cpu_per_uid_config = 137 [lazy = true];

  // Data source name: android.user_list
  optional UserListConfig user_list_config = 138 [lazy = true];

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing = 1001;

  // Was |for_testing|. Caused more problems then found.
  reserved 268435455;
}

// End of protos/perfetto/config/data_source_config.proto

// Begin of protos/perfetto/config/trace_config.proto

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 43.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    // |page_size|, now deprecated.
    reserved 2;

    // |optimize_for|, now deprecated.
    reserved 3;

    enum FillPolicy {
      UNSPECIFIED = 0;

      // Default behavior. The buffer operates as a conventional ring buffer.
      // If the writer is faster than the reader (or if the reader reads only
      // after tracing is stopped) newly written packets will overwrite old
      // packets.
      RING_BUFFER = 1;

      // Behaves like RING_BUFFER as long as there is space in the buffer or
      // the reader catches up with the writer. As soon as the writer hits
      // an unread chunk, it stops accepting new data in the buffer.
      DISCARD = 2;
    }
    optional FillPolicy fill_policy = 4;

    // When true the buffer is moved (rather than copied) onto the cloned
    // session, and an empty buffer of the same size is allocated in the source
    // tracing session. This feature will likely get deprecated in the future.
    // It been introduced mainly to support the surfaceflinger snapshot dump
    // for bugreports, where SF can dumps O(400MB) into the bugreport trace. In
    // that case we don't want to retain another in-memory copy of the buffer.
    optional bool transfer_on_clone = 5;

    // Used in conjunction with transfer_on_clone. When true the buffer is
    // cleared before issuing the Flush(reason=kTraceClone). This is to ensure
    // that if the data source took too long to write the data in a previous
    // clone-related flush, we don't end up with a mixture of leftovers from
    // the previous write and new data.
    optional bool clear_before_clone = 6;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional protos.DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and either |producer_name_filter| or |producer_name_regex_filter| is set,
    // the data source is enabled only for producers whose names match any of
    // the filters.
    // |producer_name_filter| has to be an exact match, while
    // |producer_name_regex_filter| is a regular expression.
    // This allows to enable a data source only for specific processes.
    // The "repeated" fields have OR semantics: specifying a filter ["foo",
    // "bar"] will enable data sources on both "foo" and "bar" (if they exist).
    repeated string producer_name_filter = 2;
    repeated string producer_name_regex_filter = 3;

    // Filter by machine names. The name of a machine is determined by the
    // PERFETTO_MACHINE_NAME env variable. In Android systems, if the env
    // variable is not set then the
    // persist.traced_relay.machine_name system property is used. If the
    // sysprop isn't set or not in an Android system, then the machine name by
    // default is set to the utsname sysname (e.g. Linux), which can be obtained
    // via the 'uname -s' command. As a convenience, one can use "host" to refer
    // to the host machine, which is the machine running traced.
    repeated string machine_name_filter = 4;
  }
  repeated DataSource data_sources = 2;

  // Config for disabling builtin data sources in the tracing service.
  message BuiltinDataSource {
    // Disable emitting clock timestamps into the trace.
    optional bool disable_clock_snapshotting = 1;

    // Disable echoing the original trace config in the trace.
    optional bool disable_trace_config = 2;

    // Disable emitting system info (build fingerprint, cpuinfo, etc).
    optional bool disable_system_info = 3;

    // Disable emitting events for data-source state changes (e.g. the marker
    // for all data sources having ACKed the start of the trace).
    optional bool disable_service_events = 4;

    // The authoritative clock domain for the trace. Defaults to BOOTTIME. See
    // also ClockSnapshot's primary_trace_clock. The configured value is written
    // into the trace as part of the ClockSnapshots emitted by the service.
    // Trace processor will attempt to translate packet/event timestamps from
    // various data sources (and their chosen clock domains) to this domain
    // during import. Added in Android R.
    optional BuiltinClock primary_trace_clock = 5;

    // Time interval in between snapshotting of sync markers, clock snapshots,
    // stats, and other periodic service-emitted events. Note that the service
    // only keeps track of the first and the most recent snapshot until
    // ReadBuffers() is called.
    optional uint32 snapshot_interval_ms = 6;

    // Hints to the service that a suspend-aware (i.e. counting time in suspend)
    // clock should be used for periodic snapshots of service-emitted events.
    // This means, if a snapshot *should* have happened during suspend, it will
    // happen immediately after the device resumes.
    //
    // Choosing a clock like this is done on best-effort basis; not all
    // platforms (e.g. Windows) expose a clock which can be used for periodic
    // tasks counting suspend. If such a clock is not available, the service
    // falls back to the best-available alternative.
    //
    // Introduced in Android S.
    // TODO(lalitm): deprecate this in T and make this the default if nothing
    // crashes in S.
    optional bool prefer_suspend_clock_for_snapshot = 7;

    // Disables the reporting of per-trace-writer histograms in TraceStats.
    optional bool disable_chunk_usage_histograms = 8;
  }
  optional BuiltinDataSource builtin_data_sources = 20;

  // If specified, the trace will be stopped |duration_ms| after starting.
  // This does *not* count the time the system is suspended, so we will run
  // for duration_ms of system activity, not wall time.
  //
  // However in case of traces with triggers, see
  // TriggerConfig.trigger_timeout_ms instead.
  optional uint32 duration_ms = 3;

  // If true, tries to use CLOCK_BOOTTIME for duration_ms rather than
  // CLOCK_MONOTONIC (which doesn't count time in suspend). Supported only on
  // Linux/Android, no-op on other platforms. This is used when dealing with
  // long (e.g. 24h) traces, where suspend can inflate them to weeks of
  // wall-time, making them more likely to hit device reboots (and hence loss).
  // This option also changes consistently the semantic of
  // TriggerConfig.stop_delay_ms.
  optional bool prefer_suspend_clock_for_duration = 36;

  // This is set when --dropbox is passed to the Perfetto command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
    // The identifier of the subscription which triggered this trace.
    optional int64 triggering_subscription_id = 4;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true && |output_path| is empty, the EnableTracing() request must
  // provide a file descriptor. The service will then periodically read packets
  // out of the trace buffer and store it into the passed file.
  // If |output_path| is not empty no fd should be passed, the service
  // will create a new file and write into that (see comment below).
  optional bool write_into_file = 8;

  // This must point to a non-existing file. If the file exists the service
  // will NOT overwrite and will fail instead as a security precaution.
  // On Android, when this is used with the system traced, the path must be
  // within /data/misc/perfetto-traces/ or the trace will fail.
  // This option has been introduced in Android R. Before R write_into_file
  // can be used only with the "pass a file descriptor over IPC" mode.
  optional string output_path = 29;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // Perfetto.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    // On R-, this override only affected userdebug builds. Since S, it also
    // affects user builds.
    // In 24Q3+ (V+), this override is a noop because upload guardrail logic
    // was removed from Perfetto.
    optional uint64 max_upload_per_day_bytes = 1 [deprecated = true];

    // Overrides the guardrail for maximum trace buffer size.
    // Available on U+
    optional uint32 max_tracing_buffer_size_kb = 2;
  }
  optional GuardrailOverrides guardrail_overrides = 11;

  // When true, data sources are not started until an explicit call to
  // StartTracing() on the consumer port. This is to support early
  // initialization and fast trace triggering. This can be used only when the
  // Consumer explicitly triggers the StartTracing() method.
  // This should not be used in a remote trace config via statsd, doing so will
  // result in a hung trace session.
  optional bool deferred_start = 12;

  // When set, it periodically issues a Flush() to all data source, forcing them
  // to commit their data into the tracing service. This can be used for
  // quasi-real-time streaming mode and to guarantee some partial ordering of
  // events in the trace in windows of X ms.
  optional uint32 flush_period_ms = 13;

  // Wait for this long for producers to acknowledge flush requests.
  // Default 5s.
  optional uint32 flush_timeout_ms = 14;

  // Wait for this long for producers to acknowledge stop requests.
  // Default 5s.
  optional uint32 data_source_stop_timeout_ms = 23;

  // |disable_clock_snapshotting| moved.
  reserved 15;

  // Android-only. If set, sends an intent to the Traceur system app when the
  // trace ends to notify it about the trace readiness.
  optional bool notify_traceur = 16;

  // This field was introduced in Android S.
  // Android-only. If set to a value > 0, marks the trace session as a candidate
  // for being attached to a bugreport. This field effectively acts as a z-index
  // for bugreports. When Android's dumpstate runs perfetto
  // --save-for-bugreport, traced will pick the tracing session with the highest
  // score (score <= 0 is ignored) and:
  // On Android S, T:  will steal its contents, save the trace into
  //     a known path and stop prematurely.
  // On Android U+: will create a read-only snapshot and save that into a known
  //     path, without stoppin the original tracing session.
  // When this field is set the tracing session becomes eligible to be cloned
  // by other UIDs.
  optional int32 bugreport_score = 30;

  // When set, defines name of the file that will be saved under
  // /data/misc/perfetto-traces/bugreport/ when using --save-all-for-bugreport.
  // If omitted, traces will be named systrace.pftrace, systrace_1.pftrace, etc,
  // starting from the highest `bugreport_score`.
  // Introduced in v42 / Android V.
  optional string bugreport_filename = 38;

  // Triggers allow producers to start or stop the tracing session when an event
  // occurs.
  //
  // For example if we are tracing probabilistically, most traces will be
  // uninteresting. Triggers allow us to keep only the interesting ones such as
  // those traces during which the device temperature reached a certain
  // threshold. In this case the producer can activate a trigger to keep
  // (STOP_TRACING) the trace, otherwise it can also begin a trace
  // (START_TRACING) because it knows something is about to happen.
  message TriggerConfig {
    enum TriggerMode {
      UNSPECIFIED = 0;

      // When this mode is chosen, data sources are not started until one of the
      // |triggers| are received. This supports early initialization and fast
      // starting of the tracing system. On triggering, the session will then
      // record for |stop_delay_ms|. However if no trigger is seen
      // after |trigger_timeout_ms| the session will be stopped and no data will
      // be returned.
      START_TRACING = 1;

      // When this mode is chosen, the session will be started via the normal
      // EnableTracing() & StartTracing(). If no trigger is ever seen
      // the session will be stopped after |trigger_timeout_ms| and no data will
      // be returned. However if triggered the trace will stop after
      // |stop_delay_ms| and any data in the buffer will be returned to the
      // consumer.
      STOP_TRACING = 2;

      // 3 was taken by CLONE_SNAPSHOT but that has been moved to 4.
      // The early implementation of CLONE_SNAPSHOT had various bugs
      // (b/290798988, b/290799105) and made it into Android U. The number
      // change is to make sure nobody rolls out a config that hits the broken
      // behaviour.
      reserved 3;

      // When this mode is chosen, this causes a snapshot of the current tracing
      // session to be created after |stop_delay_ms| while the current tracing
      // session continues undisturbed (% an extra flush). This mode can be
      // used only when the tracing session is handled by the "perfetto" cmdline
      // client (which is true in 90% of cases). Part of the business logic
      // necessary for this behavior, and ensuing file handling, lives in
      // perfetto_cmd.cc . On other consumers, this causes only a notification
      // of the trigger through a CloneTriggerHit ObservableEvent. The custom
      // consumer is supposed to call CloneSession() itself after the event.
      // Use use_clone_snapshot_if_available=true when targeting older versions
      // of perfetto.
      CLONE_SNAPSHOT = 4;

      // NOTE: CLONE_SNAPSHOT should be used only when we targeting Android V+
      // (15+) / Perfetto v38+. A bug in older versions of the tracing service
      // might cause indefinitely long tracing sessions (see b/274931668).
    }
    optional TriggerMode trigger_mode = 1;

    // This flag is really a workaround for b/274931668. This is needed only
    // when deploying configs to different versions of the tracing service.
    // When this is set to true this has the same effect of setting trigger_mode
    // to CLONE_SNAPSHOT on newer versions of the service. This boolean has been
    // introduced to allow to have configs that use CLONE_SNAPSHOT on newer
    // versions of Android and fall back to STOP_TRACING on older versions where
    // CLONE_SNAPSHOT did not exist.
    // When using this flag, trigger_mode must be set to STOP_TRACING.
    optional bool use_clone_snapshot_if_available = 5;

    // DEPRECATED, was use_clone_snapshot_if_available in U. See the comment
    // around CLONE_SNAPSHOT.
    reserved 4;

    message Trigger {
      // The producer must specify this name to activate the trigger.
      optional string name = 1;

      // An std::regex that will match the producer that can activate this
      // trigger. This is optional. If unset any producers can activate this
      // trigger.
      optional string producer_name_regex = 2;

      // After a trigger is received either in START_TRACING or STOP_TRACING
      // mode then the trace will end |stop_delay_ms| after triggering.
      // In CLONE_SNAPSHOT mode, this is the delay between the trigger and the
      // snapshot.
      // If |prefer_suspend_clock_for_duration| is set, the duration will be
      // based on wall-clock, counting also time in suspend.
      optional uint32 stop_delay_ms = 3;

      // Limits the number of traces this trigger can start/stop in a rolling
      // 24 hour window. If this field is unset or zero, no limit is applied and
      // activiation of this trigger *always* starts/stops the trace.
      optional uint32 max_per_24_h = 4;

      // A value between 0 and 1 which encodes the probability of skipping a
      // trigger with this name. This is useful for reducing the probability
      // of high-frequency triggers from dominating trace finaization. If this
      // field is unset or zero, the trigger will *never* be skipped. If this
      // field is greater than or equal to 1, this trigger will *always* be
      // skipped i.e. it will be as if this trigger was never included in the
      // first place.
      // This probability check is applied *before* any other limits. For
      // example, if |max_per_24_h| is also set, first we will check if the
      // probability bar is met and only then will we check the |max_per_24_h|
      // limit.
      optional double skip_probability = 5;
    }
    // A list of triggers which are related to this configuration. If ANY
    // trigger is seen then an action will be performed based on |trigger_mode|.
    repeated Trigger triggers = 2;

    // Required and must be positive if a TriggerConfig is specified. This is
    // how long this TraceConfig should wait for a trigger to arrive. After this
    // period of time if no trigger is seen the TracingSession will be cleaned
    // up.
    optional uint32 trigger_timeout_ms = 3;
  }
  optional TriggerConfig trigger_config = 17;

  // When this is non-empty the perfetto command line tool will ignore the rest
  // of this TraceConfig and instead connect to the perfetto service as a
  // producer and send these triggers, potentially stopping or starting traces
  // that were previous configured to use a TriggerConfig.
  repeated string activate_triggers = 18;

  // Configuration for trace contents that reference earlier trace data. For
  // example, a data source might intern strings, and emit packets containing
  // {interned id : string} pairs. Future packets from that data source can then
  // use the interned ids instead of duplicating the raw string contents. The
  // trace parser will then need to use that interning table to fully interpret
  // the rest of the trace.
  message IncrementalStateConfig {
    // If nonzero, notify eligible data sources to clear their incremental state
    // periodically, with the given period. The notification is sent only to
    // data sources that have |handles_incremental_state_clear| set in their
    // DataSourceDescriptor. The notification requests that the data source
    // stops referring to past trace contents. This is particularly useful when
    // tracing in ring buffer mode, where it is not exceptional to overwrite old
    // trace data.
    //
    // Warning: this time-based global clearing is likely to be removed in the
    // future, to be replaced with a smarter way of sending the notifications
    // only when necessary.
    optional uint32 clear_period_ms = 1;
  }
  optional IncrementalStateConfig incremental_state_config = 21;

  // No longer needed as we unconditionally allow tracing on user builds.
  optional bool allow_user_build_tracing = 19 [deprecated = true];

  // If set the tracing service will ensure there is at most one tracing session
  // with this key.
  optional string unique_session_name = 22;

  // Compress trace with the given method. Best effort.
  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0;
    COMPRESSION_TYPE_DEFLATE = 1;
  }
  optional CompressionType compression_type = 24;

  // DEPRECATED, was compress_from_cli.
  reserved 37;

  // Android-only. Not for general use. If set, saves the trace into an
  // incident. This field is read by perfetto_cmd, rather than the tracing
  // service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message IncidentReportConfig {
    // In this message, either:
    //  * all of |destination_package|, |destination_class| and |privacy_level|
    //    must be set.
    //  * |skip_incidentd| must be explicitly set to true.

    optional string destination_package = 1;
    optional string destination_class = 2;
    // Level of filtering in the requested incident. See |Destination| in
    // frameworks/base/core/proto/android/privacy.proto.
    optional int32 privacy_level = 3;

    // If true, then skips saving the trace to incidentd.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want traces to go to incidentd even when they
    // usually would (e.g. configs deployed using statsd but only used for
    // inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |incident_report_config|, is prevent accidents where
    // |incident_report_config| is omitted by mistake.
    optional bool skip_incidentd = 5;

    // If true, do not write the trace into dropbox (i.e. incident only).
    // Otherwise, write to both dropbox and incident.
    // TODO(lalitm): remove this field as we no longer use Dropbox.
    optional bool skip_dropbox = 4 [deprecated = true];
  }
  optional IncidentReportConfig incident_report_config = 25;

  enum StatsdLogging {
    STATSD_LOGGING_UNSPECIFIED = 0;
    STATSD_LOGGING_ENABLED = 1;
    STATSD_LOGGING_DISABLED = 2;
  }

  // Android-only. Not for general use. If specified, sets the logging to statsd
  // of guardrails and checkpoints in the tracing service. perfetto_cmd sets
  // this to enabled (if not explicitly set in the config) when specifying
  // --upload.
  optional StatsdLogging statsd_logging = 31;

  // DEPRECATED. Was trace_uuid, use trace_uuid_msb and trace_uuid_lsb instead.
  reserved 26;

  // An identifier clients can use to tie this trace to other logging.
  // DEPRECATED as per v32. See TracePacket.trace_uuid for the authoritative
  // Trace UUID. If this field is set, the tracing service will respect the
  // requested UUID (i.e. TracePacket.trace_uuid == this field) but only if
  // gap-less snapshotting is not used.
  optional int64 trace_uuid_msb = 27 [deprecated = true];
  optional int64 trace_uuid_lsb = 28 [deprecated = true];

  // When set applies a post-filter to the trace contents using the filter
  // provided. The filter is applied at ReadBuffers() time and works both in the
  // case of IPC readback and write_into_file. This filter can be generated
  // using `tools/proto_filter -s schema.proto -F filter_out.bytes` or
  // `-T filter_out.escaped_string` (for .pbtx). See go/trace-filtering for
  // design.
  //
  // Introduced in Android S, but it was broken (b/195065199). Reintroduced in
  // Android T with a different field number. Updated in Android U with a new
  // bytecode version which supports string filtering.
  message TraceFilter {
    // =========================
    // Filter bytecode.
    // =========================

    // The bytecode as implemented in Android T.
    optional bytes bytecode = 1;

    // The bytecode as implemented in Android U. Adds support for string
    // filtering.
    optional bytes bytecode_v2 = 2;

    // =========================
    // String filtering
    // =========================

    // The principles and terminology of string filtering is heavily inspired by
    // iptables. A "rule" decide how strings should be filtered. Each rule
    // contains a "policy" which indicates the algorithm to use for filtering.
    // A "chain" is a list of rules which will be sequentially checked against
    // each string.
    //
    // The first rule which applies to the string terminates filtering for that
    // string. If no rules apply, the string is left unchanged.

    // A policy specifies which algorithm should be used for filtering the
    // string.
    enum StringFilterPolicy {
      SFP_UNSPECIFIED = 0;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, all matching groups are "redacted" (i.e. replaced with a
      // constant string) and filtering is terminated (i.e. no further rules are
      // checked). If it doesn't match, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_MATCH_REDACT_GROUPS = 1;

      // Like |SFP_MATCH_REDACT_GROUPS| but tries to do some pre-work before
      // checking the regex. Specifically, it tries to parse the string field as
      // an atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_REDACT_GROUPS = 2;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, filtering is terminated (i.e. no further rules are checked).
      // If it doesn't match, the string is left unchanged and the next rule in
      // chain is considered.
      SFP_MATCH_BREAK = 3;

      // Like |SFP_MATCH_BREAK| but tries to do some pre-work before checking
      // the regex. Specifically, it tries to parse the string field as an
      // atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_BREAK = 4;

      // Tries to repeatedly search (i.e. find substrings of) the string field
      // with |regex_pattern|. For each match, redacts any matching groups (i.e.
      // replaced with a constant string). Once there are no further matches,
      // filtering is terminated (i.e. no further rules are checked).
      //
      // Note that this is policy is a "search" policy not a "match" policy
      // unlike the above policies:
      //  * Match policies require matching the full string i.e. there is an
      //    implicit leading `^` and trailing `$`.
      //  * Search policies perform repeated partial matching of the string
      //    e.g.
      //      - String: `foo=aaa,bar=123,foo=bbb,baz=456`
      //      - Pattern: `foo=(\d+)`
      //      - Output: `foo=P6O,bar=123,foo=P6O,baz=456`
      //    where P6O is the redaction string
      //
      // All of this is only performed after some pre-work where we try to parse
      // the string field as an atrace tracepoint and check if the post-tgid
      // field starts with |atrace_post_tgid_starts_with|.
      //
      // If there are no partial matches, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS = 5;
    }

    // A rule specifies how strings should be filtered.
    message StringFilterRule {
      // The policy (i.e. algorithm) dictating how strings matching this rule
      // should be handled.
      optional StringFilterPolicy policy = 1;

      // The regex pattern used to match against each string.
      optional string regex_pattern = 2;

      // The string which should appear after the tgid in atrace tracepoint
      // strings.
      optional string atrace_payload_starts_with = 3;
    }

    // A chain is a list of rules which string will be sequentially checked
    // against.
    message StringFilterChain {
      repeated StringFilterRule rules = 1;
    }
    optional StringFilterChain string_filter_chain = 3;
  }
  // old field number for trace_filter
  reserved 32;
  optional TraceFilter trace_filter = 33;

  // Android-only. Not for general use. If set, reports the trace to the
  // Android framework. This field is read by perfetto_cmd, rather than the
  // tracing service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message AndroidReportConfig {
    // In this message, either:
    //  * |reporter_service_package| and |reporter_service_class| must be set.
    //  * |skip_reporting| must be explicitly set to true.

    optional string reporter_service_package = 1;
    optional string reporter_service_class = 2;

    // If true, then skips reporting the trace to Android framework.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want to report traces to the framework even
    // when they usually would (e.g. configs deployed using statsd but only
    // used for inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |framework_report_config|, is prevent accidents where
    // |framework_report_config| is omitted by mistake.
    optional bool skip_report = 3;

    // If true, will direct the Android framework to read the data in trace
    // file and pass it to the reporter class over a pipe instead of passing
    // the file descriptor directly.
    //
    // This flag is needed because the Android test framework does not
    // currently support priv-app helper apps (in terms of SELinux) and we
    // really don't want to add an allow rule for untrusted_app to receive
    // trace fds.
    //
    // Because of this, we instead will direct the framework to create a new
    // pipe and pass this to the reporter process instead. As the pipe is
    // created by the framework, we won't have any problems with SELinux
    // (system_server is already allowed to pass pipe fds, even
    // to untrusted apps).
    //
    // As the name suggests this option *MUST* only be used for testing.
    // Note that the framework will reject (and drop) files which are too
    // large both for simplicity and to be minimize the amount of data we
    // pass to a non-priv app (note that the framework will still check
    // manifest permissions even though SELinux permissions are worked around).
    optional bool use_pipe_in_framework_for_testing = 4;
  }
  optional AndroidReportConfig android_report_config = 34;

  // If set, delays the start of tracing by a random duration. The duration is
  // chosen from a uniform distribution between the specified minimum and
  // maximum.
  // Note: this delay is implemented by perfetto_cmd *not* by traced so will
  // not work if you communicate with traced directly over the consumer API.
  // Introduced in Android T.
  message CmdTraceStartDelay {
    optional uint32 min_delay_ms = 1;
    optional uint32 max_delay_ms = 2;
  }
  optional CmdTraceStartDelay cmd_trace_start_delay = 35;

  // When non-empty, ensures that for a each semaphore named `name at most
  // `max_other_session_count`` *other* sessions (whose value is taken of the
  // minimum of all values specified by this config or any already-running
  // session) can be be running.
  //
  // If a semaphore "acquisition" fails, EnableTracing will return an error
  // and the tracing session will not be started (or elgible to start in
  // the case of deferred sessions).
  //
  // This is easiest to explain with an example. Suppose the tracing service has
  // the following active tracing sessions:
  //   S1 = [{name=foo, max_other_session_count=2},
  //         {name=bar, max_other_session_count=0}]
  //   S2 = [{name=foo, max_other_session_count=1},
  //         {name=baz, max_other_session_count=1}]
  //
  // Then, for a new session, the following would be the expected behaviour of
  // EnableSession given the state of `session_semaphores`.
  //   Q: session_semaphores = []
  //   A: Allowed because it does not specify any semaphores. Will be allowed
  //      no matter the state of any other tracing session.
  //   Q: session_semaphores = [{name=baz, max_other_session_count=1}]
  //   A: Allowed because both S2 and this config specify
  //      max_other_session_count=1 for baz.
  //   Q: session_semaphores = [{name=foo, max_other_session_count=3}]
  //   A: Denied because S2 specified max_other_session_count=1 for foo and S1
  //      takes that slot.
  //   Q: session_semaphores = [{name=bar, max_other_session_count=0}]
  //   A: Denied because S1 takes the the slot specified by both S1 and
  //      this config.
  //
  // Introduced in 24Q3 (Android V).
  message SessionSemaphore {
    // The name of the semaphore. Acts as a unique identifier across all
    // tracing sessions (including the one being started).
    optional string name = 1;

    // The maximum number of *other* sesssions which specify the same semaphore
    // which can be active. The minimum of this value across all tracing
    // sessions and the value specified by the config is used when deciding
    // whether the tracing session can be started.
    optional uint64 max_other_session_count = 2;
  }
  repeated SessionSemaphore session_semaphores = 39;

  // Priority boost to be applied to the traced process, when the session is
  // running.
  optional PriorityBoostConfig priority_boost = 40;

  // When set to a value > 0, this tracing session will be started in
  // "exclusive mode". This has the following semantics:
  // - It can only be set by shell or root users.
  // - A new exclusive session will only be started if its priority is strictly
  //   higher than any other active tracing session.
  // - If a new exclusive session is started, all other existing tracing
  //   sessions (exclusive or not) are aborted.
  // - While an exclusive session is active, any new non-exclusive session (or
  //   any exclusive session with a lower or equal priority) will be rejected.
  //
  // Introduced in: perfetto v52.
  // Supported on: Android 25Q3+.
  optional uint32 exclusive_prio = 41;

  // If true && |write_into_file|, do NOT flush buffers when periodically write
  // them into file.
  //
  // By default, if |write_into_file| is set, each time we periodically write
  // buffers into file, we first issue a Flush() to all data source, forcing
  // them to commit their data into the tracing service. This helps us to always
  // write latest data to the file.
  //
  // Before this flag was introduced, the default behavior was NOT to flush
  // buffers when periodically write them into file. If true this flag
  // returns the old default behavior.
  //
  // Introduced in: perfetto v53.
  // Supported on: Android 25Q4+.
  optional bool no_flush_before_write_into_file = 42;
}

// End of protos/perfetto/config/trace_config.proto

// Begin of protos/perfetto/common/system_info.proto

message Utsname {
  optional string sysname = 1;
  optional string version = 2;
  optional string release = 3;
  optional string machine = 4;
}

// Next id: 16
message SystemInfo {
  optional Utsname utsname = 1;
  optional string android_build_fingerprint = 2;

  // The manufacturer of the product/hardware.
  // Source : "ro.product.manufacturer"
  // Introduced after Android W in Nov 2024 and is not supported on older
  // versions.
  optional string android_device_manufacturer = 14;

  // The SoC model from which trace is collected
  optional string android_soc_model = 9;

  // The guest SoC model from which trace is collected in case of VMs
  optional string android_guest_soc_model = 13;

  // The hardware reversion from android device
  optional string android_hardware_revision = 10;

  // The storage component from android_device. This field has been introduced
  // after Android W in Aug 2024 and is not supported on older versions.
  optional string android_storage_model = 11;

  // The RAM component information from android device. This field has been
  // introduced after Android W in Aug 2024 and is not supported on older
  // versions.
  optional string android_ram_model = 12;

  // The serial console information from android device.
  optional string android_serial_console = 15;

  // The version of traced (the same returned by `traced --version`).
  // This is a human readable string with and its format varies depending on
  // the build system and the repo (standalone vs AOSP).
  // This is intended for human debugging only.
  optional string tracing_service_version = 4;

  // The Android SDK vesion (e.g. 21 for L, 31 for S etc).
  // Introduced in Android T.
  optional uint64 android_sdk_version = 5;

  // Kernel page size - sysconf(_SC_PAGESIZE).
  optional uint32 page_size = 6;

  // Number of cpus - sysconf(_SC_NPROCESSORS_CONF).
  // Might be different to the number of online cpus.
  // Introduced in perfetto v44.
  optional uint32 num_cpus = 8;

  // The timezone offset from UTC, as per strftime("%z"), in minutes.
  // Introduced in v38 / Android V.
  optional int32 timezone_off_mins = 7;

  // Ticks per second - sysconf(_SC_CLK_TCK).
  // Not serialised as of perfetto v44.
  optional int64 hz = 3;
}

// End of protos/perfetto/common/system_info.proto

// Begin of protos/perfetto/common/trace_stats.proto

// Statistics for the internals of the tracing service.
//
// Next id: 19.
message TraceStats {
  // From TraceBuffer::Stats.
  //
  // Next id: 21.
  message BufferStats {
    // Size of the circular buffer in bytes.
    optional uint64 buffer_size = 12;

    // Num. bytes written into the circular buffer, including chunk headers.
    optional uint64 bytes_written = 1;

    // Num. bytes overwritten before they have been read (i.e. loss of data).
    optional uint64 bytes_overwritten = 13;

    // Total size of chunks that were fully read from the circular buffer by the
    // consumer. This may not be equal to |bytes_written| either in the middle
    // of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
    // size of the chunks read from the buffer, including chunk headers, which
    // will be different from the total size of packets returned to the
    // consumer.
    //
    // The current utilization of the trace buffer (mid-tracing) can be obtained
    // by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
    // adding the difference of |padding_bytes_written| and
    // |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
    // Note that this represents the total size of buffered data in the buffer,
    // yet this data may be spread non-contiguously through the buffer and may
    // be overridden before the utilization reaches 100%.
    optional uint64 bytes_read = 14;

    // Num. bytes that were allocated as padding between chunks in the circular
    // buffer.
    optional uint64 padding_bytes_written = 15;

    // Num. of padding bytes that were removed from the circular buffer when
    // they were overwritten.
    //
    // The difference between |padding_bytes_written| and
    // |padding_bytes_cleared| denotes the total size of padding currently
    // present in the buffer.
    optional uint64 padding_bytes_cleared = 16;

    // Num. chunks (!= packets) written into the buffer.
    optional uint64 chunks_written = 2;

    // Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
    // the same chunk with additional packets appended to the end.
    optional uint64 chunks_rewritten = 10;

    // Num. chunks overwritten before they have been read (i.e. loss of data).
    optional uint64 chunks_overwritten = 3;

    // Num. chunks discarded (i.e. loss of data). Can be > 0 only when a buffer
    // is configured with FillPolicy == DISCARD.
    optional uint64 chunks_discarded = 18;

    // Num. chunks (!= packets) that were fully read from the circular buffer by
    // the consumer. This may not be equal to |chunks_written| either in the
    // middle of tracing, or if |chunks_overwritten| is non-zero.
    optional uint64 chunks_read = 17;

    // Num. chunks that were committed out of order.
    optional uint64 chunks_committed_out_of_order = 11;

    // Num. times the ring buffer wrapped around.
    optional uint64 write_wrap_count = 4;

    // Num. out-of-band (OOB) patches that succeeded.
    optional uint64 patches_succeeded = 5;

    // Num. OOB patches that failed (e.g., the chunk to patch was gone).
    optional uint64 patches_failed = 6;

    // Num. readaheads (for large multi-chunk packet reads) that ended up in a
    // successful packet read.
    optional uint64 readaheads_succeeded = 7;

    // Num. readaheads aborted because of missing chunks in the sequence stream.
    // Note that a small number > 0 is totally expected: occasionally, when
    // issuing a read, the very last packet in a sequence might be incomplete
    // (because the producer is still writing it while we read). The read will
    // stop at that point, for that sequence, increasing this counter.
    optional uint64 readaheads_failed = 8;

    // Num. of violations of the SharedMemoryABI found while writing or reading
    // the buffer. This is an indication of either a bug in the producer(s) or
    // malicious producer(s).
    optional uint64 abi_violations = 9;

    // The fields below have been introduced in Android R.

    // Num. of times the service detected packet loss on a trace writer
    // sequence. This is usually caused by exhaustion of available chunks in the
    // writer process's SMB. Note that this relies on the client's TraceWriter
    // indicating this loss to the service -- packets lost for other reasons are
    // not reflected in this stat.
    optional uint64 trace_writer_packet_loss = 19;
  }

  // Stats for the TraceBuffer(s) of the current trace session.
  repeated BufferStats buffer_stats = 1;

  // Per TraceWriter stat. Each {producer, trace writer} tuple is publicly
  // visible as a unique sequence ID in the trace.
  message WriterStats {
    // This matches the TracePacket.trusted_packet_sequence_id and is used to
    // correlate the stats with the actual packet types.
    optional uint64 sequence_id = 1;

    // The buffer index (0..N, as defined in the TraceConfig).
    optional uint32 buffer = 4;

    // These two arrays have the same cardinality and match the cardinality of
    // chunk_payload_histogram_def + 1 (for the overflow bucket, see below).
    // `sum` contains the SUM(entries) and `counts` contains the COUNT(entries)
    // for each bucket.
    repeated uint64 chunk_payload_histogram_counts = 2 [packed = true];
    repeated int64 chunk_payload_histogram_sum = 3 [packed = true];
  }

  // The thresholds of each the `writer_stats` histogram buckets. This is
  // emitted only once as all WriterStats share the same bucket layout.
  // This field has the same cardinality of the
  // `writer_stats.chunk_payload_histogram_{counts,sum}` - 1.
  // (The -1 is because the last overflow bucket is not reported in the _def).
  // An array of values [10, 100, 1000] in the _def array means that there are
  // four buckets (3 + the implicit overflow bucket):
  // [0]: x <= 10; [1]: 100 < x <= 1000; [2]: 1000 < x <= 1000; [3]: x > 1000.
  repeated int64 chunk_payload_histogram_def = 17;
  repeated WriterStats writer_stats = 18;

  // Num. producers connected (whether they are involved in the current tracing
  // session or not).
  optional uint32 producers_connected = 2;

  // Num. producers ever seen for all trace sessions since startup (it's a good
  // proxy for inferring num. producers crashed / killed).
  optional uint64 producers_seen = 3;

  // Num. data sources registered for all trace sessions.
  optional uint32 data_sources_registered = 4;

  // Num. data sources ever seen for all trace sessions since startup.
  optional uint64 data_sources_seen = 5;

  // Num. concurrently active tracing sessions.
  optional uint32 tracing_sessions = 6;

  // Num. buffers for all tracing session (not just the current one). This will
  // be >= buffer_stats.size(), because the latter is only about the current
  // session.
  optional uint32 total_buffers = 7;

  // The fields below have been introduced in Android Q.

  // Num. chunks that were discarded by the service before attempting to commit
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 chunks_discarded = 8;

  // Num. patches that were discarded by the service before attempting to apply
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 patches_discarded = 9;

  // Packets that failed validation of the TrustedPacket. If this is > 0, there
  // is a bug in the producer.
  optional uint64 invalid_packets = 10;

  // This is set only when the TraceConfig specifies a TraceFilter.
  message FilterStats {
    optional uint64 input_packets = 1;
    optional uint64 input_bytes = 2;
    optional uint64 output_bytes = 3;
    optional uint64 errors = 4;
    optional uint64 time_taken_ns = 5;

    // The number of bytes discarded by the filter (i.e. output - input).
    // The array has one entry for each buffer defined in the config (unless no
    // packets for that buffer were seen and hence filtered).
    // Note: the SUM(bytes_discarded_per_buffer) will be <= but not == the total
    // (output_bytes - input_bytes) because the filter might also discard
    // server-generated synthetic packets, that have no buffer index.
    repeated uint64 bytes_discarded_per_buffer = 20;
  }
  optional FilterStats filter_stats = 11;

  // Count of Flush() requests (either from the Consumer, or self-induced
  // periodic flushes). The final Flush() is also included in the count.
  optional uint64 flushes_requested = 12;

  // The count of the Flush() requests that were completed successfully.
  // In a well behaving trace this should always be == `flush_requests`.
  optional uint64 flushes_succeeded = 13;

  // The count of the Flush() requests that failed (in most timed out).
  // In a well behaving trace this should always be == 0.
  optional uint64 flushes_failed = 14;

  enum FinalFlushOutcome {
    FINAL_FLUSH_UNSPECIFIED = 0;
    FINAL_FLUSH_SUCCEEDED = 1;
    FINAL_FLUSH_FAILED = 2;
  }
  optional FinalFlushOutcome final_flush_outcome = 15;
}

// End of protos/perfetto/common/trace_stats.proto

// Begin of protos/perfetto/trace/android/android_game_intervention_list.proto

message AndroidGameInterventionList {
  message GameModeInfo {
    optional uint32 mode = 1;
    optional bool use_angle = 2;
    optional float resolution_downscale = 3;
    optional float fps = 4;
  }
  message GamePackageInfo {
    optional string name = 1;
    optional uint64 uid = 2;
    optional uint32 current_mode = 3;
    repeated GameModeInfo game_mode_info = 4;
  }

  repeated GamePackageInfo game_packages = 1;

  // True when at least one error occurred when parsing
  // game_mode_intervention.list
  optional bool parse_error = 2;

  // Failed to open / read game_mode_intervention.list
  optional bool read_error = 3;
}

// End of protos/perfetto/trace/android/android_game_intervention_list.proto

// Begin of protos/perfetto/trace/android/android_log.proto

message AndroidLogPacket {
  message LogEvent {
    // The log buffer (e.g. MAIN, SYSTEM, RADIO) the event comes from.
    optional AndroidLogId log_id = 1;

    // PID (TGID), TID and UID of the task that emitted the event.
    optional int32 pid = 2;
    optional int32 tid = 3;
    optional int32 uid = 4;

    // Timestamp [ns]. The clock source is CLOCK_REALTIME, unlike many other
    // Perfetto trace events that instead use CLOCK_BOOTTIME. The trace
    // processor will take care of realigning clocks using the ClockSnapshot(s).
    optional uint64 timestamp = 5;

    // When log_id == LID_EVENTS, |tag| corresponds to the event name defined in
    // the second column of /system/etc/event-log-tags. For all other events,
    // |tag| is the app-specified argument passed to __android_log_write().
    optional string tag = 6;

    // Empty when log_id == LID_EVENTS.
    optional AndroidLogPriority prio = 7;

    // Empty when log_id == LID_EVENTS.
    optional string message = 8;

    message Arg {
      optional string name = 1;
      oneof value {
        int64 int_value = 2;
        float float_value = 3;
        string string_value = 4;
      }
    }
    // Only populated when log_id == LID_EVENTS.
    repeated Arg args = 9;
  }

  repeated LogEvent events = 1;

  // Stats are emitted only upon Flush() and are monotonic (i.e. they are
  // absolute counters since the beginning of the lifetime of the tracing
  // session and NOT relative to the previous Stats snapshot).
  message Stats {
    // Total number of log events seen, including errors and skipped entries
    // (num of events stored in the trace = total - failed - skipped).
    optional uint64 num_total = 1;

    // Parser failures.
    optional uint64 num_failed = 2;

    // Messages skipped due to filters.
    optional uint64 num_skipped = 3;
  }
  optional Stats stats = 2;
}

// End of protos/perfetto/trace/android/android_log.proto

// Begin of protos/perfetto/trace/android/android_system_property.proto

message AndroidSystemProperty {
  message PropertyValue {
    optional string name = 1;
    optional string value = 2;
  }

  repeated PropertyValue values = 1;
}

// End of protos/perfetto/trace/android/android_system_property.proto

// Begin of protos/perfetto/trace/android/app_wakelock_data.proto

// AppWakelockInfo describes the time-independent properties of a wakelock, such
// as the owning package or wakelock tag. This is interned to reduce trace size.
// Event bundles refer to interned wakelock info by the iid.
message AppWakelockInfo {
  // The interned id of this wakelock.
  optional int32 iid = 1;

  // The app-provided tag of the wakelock.
  optional string tag = 2;

  // The wakelock flags (such as partial vs full).
  optional int32 flags = 3;

  // The pid that created the wakelock.
  optional int32 owner_pid = 4;

  // The uid that created the wakelock.
  optional int32 owner_uid = 5;

  // The uid of the work source root (if present).
  optional int32 work_uid = 6;
}

// AppWakelockBundle describes one or more wakelock events. Events are written
// in two paired array, such that the details for event i are in intern_id[i]
// and encoded_ts[i].
message AppWakelockBundle {
  // The interned id for the WakelockInfo of the event.
  repeated uint32 intern_id = 1 [packed = true];

  // The timestamp and event type, encoded as:
  //   (event_time - packet_time) << 1 | (acquired ? 1 : 0)
  repeated uint64 encoded_ts = 2 [packed = true];

  // For writing single packets (mainly by tokenization).
  optional AppWakelockInfo info = 3;
  optional bool acquired = 4;
}

// End of protos/perfetto/trace/android/app_wakelock_data.proto

// Begin of protos/perfetto/trace/android/bluetooth_trace.proto

// Describes the packet type and direction. CMD and EVT are unidirectional, so
// no need to differentiate the direction.
enum BluetoothTracePacketType {
  HCI_CMD = 1;
  HCI_EVT = 2;
  HCI_ACL_RX = 3;
  HCI_ACL_TX = 4;
  HCI_SCO_RX = 5;
  HCI_SCO_TX = 6;
  HCI_ISO_RX = 7;
  HCI_ISO_TX = 8;
}

// Trace event for bluetooth
message BluetoothTraceEvent {
  // Packet type and direction
  optional BluetoothTracePacketType packet_type = 1;

  // Total count of the packets collected during the collection interval
  optional uint32 count = 2;

  // Total cumulative length of the packets collected during the collection
  // interval
  optional uint32 length = 3;

  // The collection interval in nanoseconds. This is the duration between the
  // first and last packets collected.
  optional uint32 duration = 4;

  // In case of CMD type, further breakdown of the type of command
  optional uint32 op_code = 5;

  // In the case of EVT type, further breakdown of the type of event
  optional uint32 event_code = 6;

  // When applicable for EVT type, further breakdown of event type into specific
  // subevent
  optional uint32 subevent_code = 7;

  // Associated handle for the bluetooth packet
  optional uint32 connection_handle = 8;
}

// End of protos/perfetto/trace/android/bluetooth_trace.proto

// Begin of protos/perfetto/trace/android/camera_event.proto

// A profiling event corresponding to a single camera frame. This message
// collects important details and timestamps involved in producing a single
// camera frame.
// Next ID: 17
message AndroidCameraFrameEvent {
  // Identifier for the CameraCaptureSession this frame originates from. See:
  // https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession
  optional uint64 session_id = 1;
  // Identifier for the camera sensor that is the source of this frame. This may
  // be either a physical or logical camera (up to vendor interpretation).
  optional uint32 camera_id = 2;
  // The frame number identifying this frame on this camera.
  optional int64 frame_number = 3;
  // Identifier for the CaptureRequest. See:
  // https://developer.android.com/reference/android/hardware/camera2/CaptureRequest
  //
  // If multiple cameras are streaming simultaneously, the request_id may be
  // used to identify which frames were captured in service of the same request.
  optional int64 request_id = 4;

  // The CLOCK_BOOTTIME timestamp at which the camera framework request is
  // received by the camera HAL pipeline. Note that this request may wait for
  // some time before processing actually begins. See also
  // request_processing_started_ns.
  optional int64 request_received_ns = 5;
  // The CLOCK_BOOTTIME timestamp at which the framework request is accepted for
  // processing by the camera HAL pipeline. This is the time at which the
  // pipeline actually begins to work on the request.
  optional int64 request_processing_started_ns = 6;

  // The CLOCK_BOOTTIME timestamp at which the sensor begins its exposure.
  optional int64 start_of_exposure_ns = 7;
  // The CLOCK_BOOTTIME timestamp corresponding to the sensor start of frame
  // event.
  optional int64 start_of_frame_ns = 8;
  // The CLOCK_BOOTTIME timestamp at which the camera HAL has sent all responses
  // for the frame.
  optional int64 responses_all_sent_ns = 9;

  // The error status, if any, reported to the camera framework. Any status
  // other than STATUS_OK indicates a dropped frame.
  // Next Enum: 6
  enum CaptureResultStatus {
    STATUS_UNSPECIFIED = 0;
    STATUS_OK = 1;
    // Early metadata was returned to the camera framework with an error.
    STATUS_EARLY_METADATA_ERROR = 2;
    // Final metadata was returned to the camera framework with an error.
    STATUS_FINAL_METADATA_ERROR = 3;
    // One or more buffers were returned to the camera framework with an error.
    STATUS_BUFFER_ERROR = 4;
    // The frame was dropped as a result of a flush operation.
    STATUS_FLUSH_ERROR = 5;
  }
  optional CaptureResultStatus capture_result_status = 10;

  // The number of sensor frames that were skipped between this frame and the
  // previous frame. Under normal operation, this should be zero. Any number
  // greater than zero indicates dropped sensor frames.
  optional int32 skipped_sensor_frames = 11;

  // The value of CONTROL_CAPTURE_INTENT. See:
  // https://developer.android.com/reference/android/hardware/camera2/CaptureRequest#CONTROL_CAPTURE_INTENT
  optional int32 capture_intent = 12;
  // The number of streams in the capture request.
  optional int32 num_streams = 13;

  // A profiling event corresponding to a single node processing within the
  // camera pipeline. Intuitively this corresponds to a single stage of
  // processing to produce a camera frame. Next ID: 6
  message CameraNodeProcessingDetails {
    optional int64 node_id = 1;
    // The timestamp at which node processing begins to run.
    optional int64 start_processing_ns = 2;
    // The timestamp at which node processing finishes running.
    optional int64 end_processing_ns = 3;
    // The delay between inputs becoming ready and the node actually beginning
    // to run.
    optional int64 scheduling_latency_ns = 4;
  }
  repeated CameraNodeProcessingDetails node_processing_details = 14;

  // These fields capture vendor-specific additions to this proto message. In
  // practice `vendor_data` typically contains a serialized message of the
  // vendor's design, and `vendor_data_version` is incremented each time there
  // is a backwards incompatible change made to the message.
  optional int32 vendor_data_version = 15;
  optional bytes vendor_data = 16;
}

// A profiling event that may be emitted periodically (i.e., at a slower rate
// than `AndroidCameraFrameEvent`s) to record fixed and aggregated camera
// session-specific values.
message AndroidCameraSessionStats {
  // Identifier for the CameraCaptureSession this frame originates from. See:
  // https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession
  optional uint64 session_id = 1;

  // Although vendor implementations may vary, camera pipeline processing is
  // typically arranged into a directed graph-like structure. This message is
  // used to record that graph.
  message CameraGraph {
    message CameraNode {
      optional int64 node_id = 1;
      // A list of inputs consumed by this node.
      repeated int64 input_ids = 2;
      // A list of outputs produced by this node.
      repeated int64 output_ids = 3;

      // These fields capture vendor-specific additions to this proto message.
      // In practice `vendor_data` typically contains a serialized message of
      // the vendor's design, and `vendor_data_version` is incremented each time
      // there is a backwards incompatible change made to the message.
      optional int32 vendor_data_version = 4;
      optional bytes vendor_data = 5;
    }
    repeated CameraNode nodes = 1;

    // An adjacency list describing connections between CameraNodes, mapping
    // nodes and their outputs to other nodes that consume them as inputs.
    message CameraEdge {
      // The pair of IDs identifying the node and output connected by this edge.
      optional int64 output_node_id = 1;
      optional int64 output_id = 2;

      // The pair of IDs identifying the node and input connected by this edge.
      optional int64 input_node_id = 3;
      optional int64 input_id = 4;

      // These fields capture vendor-specific additions to this proto message.
      // In practice `vendor_data` typically contains a serialized message of
      // the vendor's design, and `vendor_data_version` is incremented each time
      // there is a backwards incompatible change made to the message.
      optional int32 vendor_data_version = 5;
      optional bytes vendor_data = 6;
    }
    repeated CameraEdge edges = 2;
  }
  optional CameraGraph graph = 2;
}

// End of protos/perfetto/trace/android/camera_event.proto

// Begin of protos/perfetto/trace/android/cpu_per_uid_data.proto

message CpuPerUidData {
  // Number of clusters in the device. This will only be filled in the first
  // packet in a sequence.
  optional uint32 cluster_count = 1;

  // The UIDs for which we have data in this packet.
  repeated uint32 uid = 2 [packed = true];

  // List of times for {UID, cluster} tuples. This will be cluster_count
  // times as long as the UID list.
  //
  // Ordered like:
  // [{UID 0, cluster 0}, {UID 0, cluster 1}, {UID 0, cluster 2},
  //  {UID 1, cluster 0}, {UID 1, cluster 1}, {UID 1, cluster 2}, ...]
  //
  // Each value is an absolute count for the first packet in a sequence, and a
  // delta thereafter. UIDs for which all clusters have a zero delta are
  // omitted; a single non-zero value for any cluster for a UID will cause
  // values for all clusters to be recorded.
  repeated uint64 total_time_ms = 3 [packed = true];
}

// End of protos/perfetto/trace/android/cpu_per_uid_data.proto

// Begin of protos/perfetto/trace/android/frame_timeline_event.proto

// Generated by SurfaceFlinger's FrameTimeline (go/adaptive-scheduling-fr).
// Used in comparing the expected timeline of a frame to the actual timeline.
// Key terms:
//    1) DisplayFrame - represents SurfaceFlinger's work on a frame(composited)
//    2) SurfaceFrame - represents App's work on its frame
//    3) Timeline = start to end of a component's(app/SF) work on a frame.
// SurfaceFlinger composites frames from many apps together, so
//    One DisplayFrame can map to N SurfaceFrame(s)
// This relationship can be reconstructed by using
//    DisplayFrame.token = SurfaceFrame.display_frame_token
message FrameTimelineEvent {
  // Specifies the reason(s) most likely to have caused the jank.
  // Used as a bitmask.
  enum JankType {
    JANK_UNSPECIFIED = 0;
    JANK_NONE = 1;
    JANK_SF_SCHEDULING = 2;
    JANK_PREDICTION_ERROR = 4;
    JANK_DISPLAY_HAL = 8;
    JANK_SF_CPU_DEADLINE_MISSED = 16;
    JANK_SF_GPU_DEADLINE_MISSED = 32;
    JANK_APP_DEADLINE_MISSED = 64;
    JANK_BUFFER_STUFFING = 128;
    JANK_UNKNOWN = 256;
    JANK_SF_STUFFING = 512;
    JANK_DROPPED = 1024;
    JANK_NON_ANIMATING = 2048;
    JANK_APP_RESYNCED_JITTER = 4096;
    JANK_DISPLAY_NOT_ON = 8192;
  };

  // Specifies the severity of a jank.
  enum JankSeverityType {
    SEVERITY_UNKNOWN = 0;
    SEVERITY_NONE = 1;
    SEVERITY_PARTIAL = 2;
    SEVERITY_FULL = 3;
  }

  // Specifies how a frame was presented on screen w.r.t. timing.
  // Can be different for SurfaceFrame and DisplayFrame.
  enum PresentType {
    PRESENT_UNSPECIFIED = 0;
    PRESENT_ON_TIME = 1;
    PRESENT_LATE = 2;
    PRESENT_EARLY = 3;
    PRESENT_DROPPED = 4;
    PRESENT_UNKNOWN = 5;
  };

  // Specifies if the predictions for the frame are still valid, expired or
  // unknown.
  enum PredictionType {
    PREDICTION_UNSPECIFIED = 0;
    PREDICTION_VALID = 1;
    PREDICTION_EXPIRED = 2;
    PREDICTION_UNKNOWN = 3;
  };

  // Indicates the start of expected timeline slice for SurfaceFrames.
  message ExpectedSurfaceFrameStart {
    // Cookie used to correlate between the start and end messages of the same
    // frame. Since all values except the ts are same for start and end, cookie
    // helps in preventing redundant data transmission.
    // The same cookie is used only by start and end messages of a single frame
    // and is otherwise unique.
    optional int64 cookie = 1;

    // Token received by the app for its work. Can be shared between multiple
    // layers of the same app (example: pip mode).
    optional int64 token = 2;
    // The corresponding DisplayFrame token is required to link the App's work
    // with SurfaceFlinger's work. Many SurfaceFrames can be mapped to a single
    // DisplayFrame.
    // this.display_frame_token = DisplayFrame.token
    optional int64 display_frame_token = 3;

    // Pid of the app. Used in creating the timeline tracks (and slices) inside
    // the respective process track group.
    optional int32 pid = 4;
    optional string layer_name = 5;
  };

  // Indicates the start of actual timeline slice for SurfaceFrames. Also
  // includes the jank information.
  message ActualSurfaceFrameStart {
    // Cookie used to correlate between the start and end messages of the same
    // frame. Since all values except the ts are same for start and end, cookie
    // helps in preventing redundant data transmission.
    // The same cookie is used only by start and end messages of a single frame
    // and is otherwise unique.
    optional int64 cookie = 1;

    // Token received by the app for its work. Can be shared between multiple
    // layers of the same app (example: pip mode).
    optional int64 token = 2;
    // The corresponding DisplayFrame token is required to link the App's work
    // with SurfaceFlinger's work. Many SurfaceFrames can be mapped to a single
    // DisplayFrame.
    // this.display_frame_token = DisplayFrame.token
    optional int64 display_frame_token = 3;

    // Pid of the app. Used in creating the timeline tracks (and slices) inside
    // the respective process track group.
    optional int32 pid = 4;
    optional string layer_name = 5;

    optional PresentType present_type = 6;
    optional bool on_time_finish = 7;
    optional bool gpu_composition = 8;
    // A bitmask of JankType. More than one reason can be attributed to a janky
    // frame.
    optional int32 jank_type = 9;
    optional PredictionType prediction_type = 10;
    optional bool is_buffer = 11;
    optional JankSeverityType jank_severity_type = 12;
    optional float present_delay_millis = 13;
    optional float vsync_resynced_jitter_millis = 14;
    optional float jank_severity_score = 15;

    // experimental value for jank_type. Do not consider in jank analysis.
    optional int32 jank_type_experimental = 16;

    // experimental value for present_type. Do not consider in jank analysis.
    optional PresentType present_type_experimental = 17;
  };

  // Indicates the start of expected timeline slice for DisplayFrames.
  message ExpectedDisplayFrameStart {
    // Cookie used to correlate between the start and end messages of the same
    // frame. Since all values except the ts are same for start and end, cookie
    // helps in preventing redundant data transmission.
    // The same cookie is used only by start and end messages of a single frame
    // and is otherwise unique.
    optional int64 cookie = 1;

    // Token received by SurfaceFlinger for its work
    // this.token = SurfaceFrame.display_frame_token
    optional int64 token = 2;

    // Pid of SurfaceFlinger. Used in creating the timeline tracks (and slices)
    // inside the SurfaceFlinger process group.
    optional int32 pid = 3;
  };

  // Indicates the start of actual timeline slice for DisplayFrames. Also
  // includes the jank information.
  message ActualDisplayFrameStart {
    // Cookie used to correlate between the start and end messages of the same
    // frame. Since all values except the ts are same for start and end, cookie
    // helps in preventing redundant data transmission.
    // The same cookie is used only by start and end messages of a single frame
    // and is otherwise unique.
    optional int64 cookie = 1;

    // Token received by SurfaceFlinger for its work
    // this.token = SurfaceFrame.display_frame_token
    optional int64 token = 2;

    // Pid of SurfaceFlinger. Used in creating the timeline tracks (and slices)
    // inside the SurfaceFlinger process group.
    optional int32 pid = 3;

    optional PresentType present_type = 4;
    optional bool on_time_finish = 5;
    optional bool gpu_composition = 6;
    // A bitmask of JankType. More than one reason can be attributed to a janky
    // frame.
    optional int32 jank_type = 7;
    optional PredictionType prediction_type = 8;
    optional JankSeverityType jank_severity_type = 9;

    optional float present_delay_millis = 10;
    optional float jank_severity_score = 11;

    // experimental value for jank_type. Do not consider in jank analysis.
    optional int32 jank_type_experimental = 12;

    // experimental value for present_type. Do not consider in jank analysis.
    optional PresentType present_type_experimental = 13;
  };

  // FrameEnd just sends the cookie to indicate that the corresponding
  // <display/surface>frame slice's end.
  message FrameEnd {
    optional int64 cookie = 1;
  };

  oneof event {
    ExpectedDisplayFrameStart expected_display_frame_start = 1;
    ActualDisplayFrameStart actual_display_frame_start = 2;

    ExpectedSurfaceFrameStart expected_surface_frame_start = 3;
    ActualSurfaceFrameStart actual_surface_frame_start = 4;

    FrameEnd frame_end = 5;
  }
}

// End of protos/perfetto/trace/android/frame_timeline_event.proto

// Begin of protos/perfetto/trace/android/gpu_mem_event.proto

// Generated by Android's GpuService.
message GpuMemTotalEvent {
  optional uint32 gpu_id = 1;
  optional uint32 pid = 2;
  optional uint64 size = 3;
}

// End of protos/perfetto/trace/android/gpu_mem_event.proto

// Begin of protos/perfetto/trace/android/graphics_frame_event.proto

// Generated by Android's SurfaceFlinger.
message GraphicsFrameEvent {
  enum BufferEventType {
    UNSPECIFIED = 0;
    DEQUEUE = 1;
    QUEUE = 2;
    POST = 3;
    ACQUIRE_FENCE = 4;
    LATCH = 5;
    // HWC will compose this buffer
    HWC_COMPOSITION_QUEUED = 6;
    // renderEngine composition
    FALLBACK_COMPOSITION = 7;
    PRESENT_FENCE = 8;
    RELEASE_FENCE = 9;
    MODIFY = 10;
    DETACH = 11;
    ATTACH = 12;
    CANCEL = 13;
  }

  message BufferEvent {
    optional uint32 frame_number = 1;
    optional BufferEventType type = 2;
    optional string layer_name = 3;
    // If no duration is set, the event is an instant event.
    optional uint64 duration_ns = 4;
    // Unique buffer identifier.
    optional uint32 buffer_id = 5;
  }

  optional BufferEvent buffer_event = 1;
}

// End of protos/perfetto/trace/android/graphics_frame_event.proto

// Begin of protos/perfetto/trace/android/initial_display_state.proto

message InitialDisplayState {
  // Same values as android.view.Display.STATE_*
  optional int32 display_state = 1;
  optional double brightness = 2;
}

// End of protos/perfetto/trace/android/initial_display_state.proto

// Begin of protos/perfetto/trace/android/kernel_wakelock_data.proto

message KernelWakelockData {
  message Wakelock {
    enum Type {
      WAKELOCK_TYPE_UNKNOWN = 0;
      WAKELOCK_TYPE_KERNEL = 1;
      WAKELOCK_TYPE_NATIVE = 2;
    }

    // Interning id.
    optional uint32 wakelock_id = 1;

    // Name of the wakelock.
    optional string wakelock_name = 2;

    // Type of the wakelock. We record data about both true kernel wakelocks
    // and "native" wakelocks which are taken in userspace but are more
    // conceptually similar to kernel wakelocks than normal userspace ones.
    optional Type wakelock_type = 3;
  }

  // This is only emitted when we encounter new wakelocks.
  repeated Wakelock wakelock = 1;

  // Interning id.
  repeated uint32 wakelock_id = 2 [packed = true];

  // If we interned the wakelock name in this packet, this is the total time
  // the wakelock has been held.
  // If not, it's a delta from the last time we saw it.
  repeated uint64 time_held_millis = 3 [packed = true];

  optional uint64 error_flags = 4;
}

// End of protos/perfetto/trace/android/kernel_wakelock_data.proto

// Begin of protos/perfetto/trace/android/network_trace.proto

enum TrafficDirection {
  DIR_UNSPECIFIED = 0;
  DIR_INGRESS = 1;
  DIR_EGRESS = 2;
}

// NetworkPacketEvent records the details of a single packet sent or received
// on the network (in Linux kernel terminology, one sk_buff struct).
message NetworkPacketEvent {
  // The direction traffic is flowing for this event.
  optional TrafficDirection direction = 1;

  // The name of the network interface if available (e.g. 'rmnet0').
  optional string network_interface = 2;

  // The length of the packet in bytes (wire_size - L2_header_size). Ignored
  // when using NetworkPacketEvent as the ctx in either NetworkPacketBundle or
  // NetworkPacketContext.
  optional uint32 length = 3;

  // The Linux user id associated with the packet's socket.
  optional uint32 uid = 4;

  // The Android network tag associated with the packet's socket.
  optional uint32 tag = 5;

  // The packet's IP protocol (TCP=6, UDP=17, etc).
  optional uint32 ip_proto = 6;

  // The packet's TCP flags as a bitmask (FIN=0x1, SYN=0x2, RST=0x4, etc).
  optional uint32 tcp_flags = 7;

  // The local udp/tcp port of the packet.
  optional uint32 local_port = 8;

  // The remote udp/tcp port of the packet.
  optional uint32 remote_port = 9;

  // The 1-byte ICMP type identifier.
  optional uint32 icmp_type = 10;

  // The 1-byte ICMP code identifier.
  optional uint32 icmp_code = 11;
}

// NetworkPacketBundle bundles one or more packets sharing the same attributes.
message NetworkPacketBundle {
  oneof packet_context {
    // The intern id for looking up the associated packet context.
    uint64 iid = 1;

    // The inlined context for events in this bundle.
    NetworkPacketEvent ctx = 2;
  }

  // The timestamp of the i-th packet encoded as the nanoseconds since the
  // enclosing TracePacket's timestamp.
  repeated uint64 packet_timestamps = 3 [packed = true];

  // The length of the i-th packet in bytes (wire_size - L2_header_size).
  repeated uint32 packet_lengths = 4 [packed = true];

  // Total number of packets in the bundle (when above aggregation_threshold).
  optional uint32 total_packets = 5;

  // Duration between first and last packet (when above aggregation_threshold).
  optional uint64 total_duration = 6;

  // Total packet length in bytes (when above aggregation_threshold).
  optional uint64 total_length = 7;
}

// An internable packet context.
message NetworkPacketContext {
  optional uint64 iid = 1;
  optional NetworkPacketEvent ctx = 2;
}

// End of protos/perfetto/trace/android/network_trace.proto

// Begin of protos/perfetto/trace/android/packages_list.proto

message PackagesList {
  message PackageInfo {
    optional string name = 1;
    optional uint64 uid = 2;
    optional bool debuggable = 3;
    optional bool profileable_from_shell = 4;
    optional int64 version_code = 5;
  }

  repeated PackageInfo packages = 1;

  // At least one error occurred parsing the packages.list.
  optional bool parse_error = 2;

  // Failed to open / read packages.list.
  optional bool read_error = 3;
}

// End of protos/perfetto/trace/android/packages_list.proto

// Begin of protos/perfetto/trace/android/pixel_modem_events.proto

message PixelModemEvents {
  // Pigweed-format dehydrated events.
  repeated bytes events = 1;

  // Timestamps of the events, converted to CLOCK_BOOTTIME. The first
  // timestamp is the absolute timestamp of the first event. Subsequent
  // timestamps are deltas from the previous timestamp.
  // The nth entry from `events` gets the nth entry here.
  repeated uint64 event_time_nanos = 2;
}

// NB: this is not emitted in the trace but can be prepended later.
message PixelModemTokenDatabase {
  // Pigweed-format database to allow event rehydration.
  optional bytes database = 1;
}

// End of protos/perfetto/trace/android/pixel_modem_events.proto

// Begin of protos/perfetto/trace/android/protolog.proto

/* represents a single log entry */
message ProtoLogMessage {
  /* log statement identifier, created from message string and log level. */
  optional fixed64 message_id = 1;
  /* string parameters passed to the log call that have been interned. */
  repeated uint32 str_param_iids = 2;
  /* integer parameters passed to the log call. */
  repeated sint64 sint64_params = 3;
  /* floating point parameters passed to the log call. */
  repeated double double_params = 4;
  /* boolean parameters passed to the log call. */
  repeated int32 boolean_params = 5;
  // id of the interned stacktrace string
  // (only dumped if explicitly confuigured to do so)
  optional uint32 stacktrace_iid = 6;
}

/* contains all the data required to fully decode the protolog messages */
message ProtoLogViewerConfig {
  message MessageData {
    // the id of the message that is logged in a ProtoLogMessage
    optional fixed64 message_id = 1;
    // the string representation of the message
    optional string message = 2;
    // the level of the message
    optional ProtoLogLevel level = 3;
    // the id of the log group this message belongs to
    optional uint32 group_id = 4;
    // path to the file where the message was logged
    optional string location = 5;
  }

  /* information about a ProtoLog log group */
  message Group {
    optional uint32 id = 1;
    optional string name = 2;
    optional string tag = 3;
  }

  repeated MessageData messages = 1;
  repeated Group groups = 2;
}

// End of protos/perfetto/trace/android/protolog.proto

// Begin of protos/perfetto/trace/android/shell_transition.proto

// ShellTransition messages record information about the shell transitions in
// the system. This is used to track the animations that are created and execute
// through the shell transition system.
message ShellTransition {
  // The unique identifier of the transition.
  optional int32 id = 1;

  // The time the transition was created on the WM side
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 create_time_ns = 2;
  // The time the transition was sent from the WM side to shell
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 send_time_ns = 3;
  // The time the transition was dispatched by shell to execute
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 dispatch_time_ns = 4;
  // If the transition merge was accepted by the transition handler, this
  // contains the time the transition was merged into transition with id
  // `merge_target`.
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 merge_time_ns = 5;
  // The time shell proposed the transition should be merged to the transition
  // handler into transition with id `merge_target`.
  // (using SystemClock.elapsedRealtimeNanos()).
  optional int64 merge_request_time_ns = 6;
  // If the transition was aborted on the shell side, this is the time that
  // occurred.
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 shell_abort_time_ns = 7;
  // If the transition was aborted on the wm side, this is the time that
  // occurred.
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 wm_abort_time_ns = 8;
  // The time WM considers the transition to be complete.
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 finish_time_ns = 9;

  // The id of the transaction that WM proposed to use as the starting
  // transaction. It contains all the layer changes required to setup the
  // transition and should be executed right at the start of the transition
  // by the transition handler.
  optional uint64 start_transaction_id = 10;
  // The if of the transaction that WM proposed to use as the finish
  // transaction. It contains all the layer changes required to set the final
  // state of the transition.
  optional uint64 finish_transaction_id = 11;

  // The id of the handler that executed the transition. A HandlerMappings
  // message in the trace will contain the mapping of id to a string
  // representation of the handler.
  optional int32 handler = 12;
  // The transition type of this transition (e.g. TO_FRONT, OPEN, CLOSE).
  optional int32 type = 13;

  // The list of targets that are part of this transition.
  repeated Target targets = 14;
  // The id of the transition we have requested to merge or have merged this
  // transition into.
  optional int32 merge_target = 15;

  // The flags set on this transition.
  optional int32 flags = 16;
  // The time the starting window was removed. Tracked because this can
  // happen after the transition finishes, but the app may not yet be visible
  // until the starting window is removed. So in a sense the transition is not
  // finished until the starting window is removed. (b/284302118)
  // (using SystemClock.elapsedRealtimeNanos())
  optional int64 starting_window_remove_time_ns = 17;

  // Contains the information about the windows targeted in a transition.
  message Target {
    // The transition mode of this target (e.g. TO_FRONT, CLOSE...)
    optional int32 mode = 1;
    // The layer id of this target.
    optional int32 layer_id = 2;
    // The window id of this target.
    optional int32 window_id = 3;
    // The flags set on this target.
    optional int32 flags = 4;
  }
}

// Contains mappings from handler ids to string representation of the handlers.
message ShellHandlerMappings {
  repeated ShellHandlerMapping mapping = 1;
}

message ShellHandlerMapping {
  // The id of the handler used in the ShellTransition message.
  optional int32 id = 1;
  // A human readable and meaningful string representation of the handler.
  optional string name = 2;
}

// End of protos/perfetto/trace/android/shell_transition.proto

// Begin of protos/perfetto/trace/android/graphics/rect.proto

message RectProto {
  optional int32 left = 1;
  optional int32 top = 2;
  optional int32 right = 3;
  optional int32 bottom = 4;
}

// End of protos/perfetto/trace/android/graphics/rect.proto

// Begin of protos/perfetto/trace/android/surfaceflinger_common.proto

message RegionProto {
  // Previously: uint64 id
  reserved 1;
  repeated RectProto rect = 2;
}

message SizeProto {
  optional int32 w = 1;
  optional int32 h = 2;
}

message TransformProto {
  optional float dsdx = 1;
  optional float dtdx = 2;
  optional float dsdy = 3;
  optional float dtdy = 4;
  optional int32 type = 5;
}

message ColorProto {
  optional float r = 1;
  optional float g = 2;
  optional float b = 3;
  optional float a = 4;
}

message InputWindowInfoProto {
  optional uint32 layout_params_flags = 1;
  optional int32 layout_params_type = 2;
  optional RectProto frame = 3;
  optional RegionProto touchable_region = 4;

  optional int32 surface_inset = 5;
  optional bool visible = 6;
  optional bool can_receive_keys = 7 [deprecated = true];
  optional bool focusable = 8;
  optional bool has_wallpaper = 9;

  optional float global_scale_factor = 10;
  optional float window_x_scale = 11 [deprecated = true];
  optional float window_y_scale = 12 [deprecated = true];

  optional int32 crop_layer_id = 13;
  optional bool replace_touchable_region_with_crop = 14;
  optional RectProto touchable_region_crop = 15;
  optional TransformProto transform = 16;
  optional uint32 input_config = 17;
}

message BlurRegion {
  optional uint32 blur_radius = 1;
  optional uint32 corner_radius_tl = 2 [deprecated = true];
  optional uint32 corner_radius_tr = 3 [deprecated = true];
  optional uint32 corner_radius_bl = 4 [deprecated = true];
  optional float corner_radius_br = 5 [deprecated = true];
  optional float corner_radius_tlx = 11;
  optional float corner_radius_tly = 12;
  optional float corner_radius_trx = 13;
  optional float corner_radius_try = 14;
  optional float corner_radius_blx = 15;
  optional float corner_radius_bly = 16;
  optional float corner_radius_brx = 17;
  optional float corner_radius_bry = 18;
  optional float alpha = 6;
  optional int32 left = 7;
  optional int32 top = 8;
  optional int32 right = 9;
  optional int32 bottom = 10;
}

message ColorTransformProto {
  // This will be a 4x4 matrix of float values
  repeated float val = 1 [packed = true];
}

enum TrustedOverlay {
  UNSET = 0;
  DISABLED = 1;
  ENABLED = 2;
};
message BoxShadowSettings {
  message BoxShadowParams {
    optional float blur_radius = 1;
    optional float spread_radius = 2;
    optional int32 color = 3;
    optional float offset_x = 4;
    optional float offset_y = 5;
  }
  repeated BoxShadowParams box_shadows = 1;
}

message BorderSettings {
  optional float stroke_width = 1;
  optional int32 color = 2;
}
// End of protos/perfetto/trace/android/surfaceflinger_common.proto

// Begin of protos/perfetto/trace/android/surfaceflinger_layers.proto

// Message used by Winscope to process legacy trace files.
// Represents a file full of surface flinger trace entries.
// Encoded, it should start with 0x4c 0x59 0x52 0x54 0x52 0x41 0x43 0x45
// (.LYRTRACE), such that they can be easily identified.
message LayersTraceFileProto {
  // constant; MAGIC_NUMBER = (long) MAGIC_NUMBER_H << 32 |
  // MagicNumber.MAGIC_NUMBER_L (this is needed because enums have to be 32 bits
  // and there's no nice way to put 64bit constants into .proto files.
  enum MagicNumber {
    INVALID = 0;
    // LYRT (little-endian ASCII)
    MAGIC_NUMBER_L = 0x5452594c;
    // RACE (little-endian ASCII)
    MAGIC_NUMBER_H = 0x45434152;
  }

  // Must be the first field, set to value in MagicNumber
  optional fixed64 magic_number = 1;

  repeated LayersSnapshotProto entry = 2;

  // Offset between real-time clock and elapsed time clock in nanoseconds.
  // Calculated as: systemTime(SYSTEM_TIME_REALTIME) -
  // systemTime(SYSTEM_TIME_MONOTONIC)
  optional fixed64 real_to_elapsed_time_offset_nanos = 3;
}

message LayersSnapshotProto {
  // elapsed realtime in nanos since boot of when this entry was logged
  optional sfixed64 elapsed_realtime_nanos = 1;

  // SurfaceFlinger's stage where the snapshot was triggered.
  // Currently either "visibleRegionsDirty" or "bufferLatched".
  optional string where = 2;

  optional LayersProto layers = 3;

  // Blob for the current HWC information for all layers, reported by dumpsys.
  // Example:
  //   "maxDownScale: 4, maxFullWidth: 8192, HWState: 1, AssignedState: 3, ..."
  optional string hwc_blob = 4;

  // Excludes state sent during composition like visible region and composition
  // type.
  optional bool excludes_composition_state = 5;

  // Number of missed entries since the last entry was recorded.
  optional uint32 missed_entries = 6;

  repeated DisplayProto displays = 7;

  optional int64 vsync_id = 8;
}

// Contains a list of all layers.
message LayersProto {
  repeated LayerProto layers = 1;
}

message DisplayProto {
  optional uint64 id = 1;
  // Display descriptor, e.g. "Built-In Screen"
  optional string name = 2;
  optional uint32 layer_stack = 3;
  optional SizeProto size = 4;
  optional RectProto layer_stack_space_rect = 5;
  optional TransformProto transform = 6;
  optional bool is_virtual = 7;
  optional double dpi_x = 8;
  optional double dpi_y = 9;
}

// Must match definition in the IComposerClient HAL
enum HwcCompositionType {
  // Invalid composition type
  HWC_TYPE_UNSPECIFIED = 0;
  // Layer was composited by the client into the client target buffer
  HWC_TYPE_CLIENT = 1;
  // Layer was composited by the device through hardware overlays
  HWC_TYPE_DEVICE = 2;
  // Layer was composited by the device using a color
  HWC_TYPE_SOLID_COLOR = 3;
  // Similar to DEVICE, but the layer position may have been asynchronously set
  // through setCursorPosition
  HWC_TYPE_CURSOR = 4;
  // Layer was composited by the device via a sideband stream
  HWC_TYPE_SIDEBAND = 5;
  // Layer was composited by hardware optimized for display decoration
  HWC_TYPE_DISPLAY_DECORATION = 6;
}

// Information about each layer.
message LayerProto {
  // unique id per layer.
  optional int32 id = 1;
  // unique name per layer.
  // Example: "Wallpaper".
  optional string name = 2;
  // list of children this layer may have. May be empty.
  repeated int32 children = 3 [packed = true];
  // list of layers that are z order relative to this layer.
  repeated int32 relatives = 4 [packed = true];
  // The type of layer.
  // Examples: "ContainerLayer", "BufferStateLayer".
  optional string type = 5;
  optional RegionProto transparent_region = 6;
  optional RegionProto visible_region = 7;
  optional RegionProto damage_region = 8;
  optional uint32 layer_stack = 9;
  // The layer's z order. Can be z order in layer stack, relative to parent,
  // or relative to another layer specified in zOrderRelative.
  optional int32 z = 10;
  // The layer's position on the display.
  optional PositionProto position = 11;
  // The layer's requested position.
  optional PositionProto requested_position = 12;
  // The layer's size.
  optional SizeProto size = 13;
  // The layer's crop in its own bounds.
  optional RectProto crop = 14;
  // The layer's crop in its parent's bounds.
  optional RectProto final_crop = 15 [deprecated = true];
  optional bool is_opaque = 16;
  optional bool invalidate = 17;
  // Composition states's dataspace.
  // Examples: "STANDARD_BT709", "STANDARD_BT601_625".
  // See full enum in
  // frameworks/native/libs/nativewindow/include/android/data_space.h
  optional string dataspace = 18;
  // Buffer's pixel format
  // Examples: "PIXEL_FORMAT_TRANSLUCENT", "PIXEL_FORMAT_RGBA_8888".
  // See full enum in frameworks/native/libs/ui/include/ui/PixelFormat.h
  optional string pixel_format = 19;
  // The layer's actual color.
  optional ColorProto color = 20;
  // The layer's requested color.
  optional ColorProto requested_color = 21;
  // Can be any combination of
  //    hidden = 0x01
  //    opaque = 0x02,
  //    secure = 0x80,
  optional uint32 flags = 22;
  // The layer's actual transform
  optional TransformProto transform = 23;
  // The layer's requested transform.
  optional TransformProto requested_transform = 24;
  // The parent layer. This value can be null if there is no parent.
  optional int32 parent = 25;
  // The layer that this layer has a z order relative to. This value can be
  // null.
  optional int32 z_order_relative_of = 26;
  // This value can be null if there's nothing to draw.
  optional ActiveBufferProto active_buffer = 27;
  // The number of frames available.
  optional int32 queued_frames = 28;
  optional bool refresh_pending = 29;
  // The layer's composer backend destination frame
  optional RectProto hwc_frame = 30;
  // The layer's composer backend source crop
  optional FloatRectProto hwc_crop = 31;
  // The layer's composer backend transform
  optional int32 hwc_transform = 32;
  optional int32 window_type = 33 [deprecated = true];
  optional int32 app_id = 34 [deprecated = true];
  // The layer's composition type
  optional HwcCompositionType hwc_composition_type = 35;
  // If it's a buffer layer, indicate if the content is protected
  optional bool is_protected = 36;
  // Current frame number being rendered.
  optional uint64 curr_frame = 37;
  // A list of barriers that the layer is waiting to update state.
  repeated BarrierLayerProto barrier_layer = 38;
  // If active_buffer is not null, record its transform.
  optional TransformProto buffer_transform = 39;
  optional int32 effective_scaling_mode = 40;
  // Layer's corner radius
  optional float corner_radius = 41 [deprecated = true];
  // Metadata map. May be empty.
  map<int32, string> metadata = 42;

  optional TransformProto effective_transform = 43;
  optional FloatRectProto source_bounds = 44;
  optional FloatRectProto bounds = 45;
  optional FloatRectProto screen_bounds = 46;

  optional InputWindowInfoProto input_window_info = 47;

  // Crop used to draw the rounded corner.
  optional FloatRectProto corner_radius_crop = 48;

  // length of the shadow to draw around the layer, it may be set on the
  // layer or set by a parent layer.
  optional float shadow_radius = 49;
  optional ColorTransformProto color_transform = 50;

  optional bool is_relative_of = 51;
  // Layer's background blur radius in pixels.
  optional int32 background_blur_radius = 52;

  optional uint32 owner_uid = 53;

  // Regions of a layer, where blur should be applied.
  repeated BlurRegion blur_regions = 54;

  optional bool is_trusted_overlay = 55;

  // Corner radius explicitly set on layer rather than inherited
  optional float requested_corner_radius = 56 [deprecated = true];

  optional RectProto destination_frame = 57;

  optional uint32 original_id = 58;

  optional TrustedOverlay trusted_overlay = 59;

  // Layer's scale during background blur, relative to 1.0f=100%
  optional float background_blur_scale = 60;

  // Layer's corner radius.
  optional CornerRadiiProto corner_radii = 61;

  // Corner radius explicitly set on layer rather than inherited
  optional CornerRadiiProto requested_corner_radii = 62;

  // Corner radius explicity set as drawn by client
  optional CornerRadiiProto client_drawn_corner_radii = 63;

  // Priority value of the layer set by the system.
  optional int32 system_content_priority = 64;

  // Settings which specify how shadows should be drawn for a layer.
  optional BoxShadowSettings box_shadow_settings = 65;

  // Settings which specify how an outline should be drawn for a layer.
  optional BorderSettings border_settings = 66;

  // "True" corner radii of the layer computed by SurfaceFlinger.
  optional CornerRadiiProto effective_radii = 67;
}

message PositionProto {
  optional float x = 1;
  optional float y = 2;
}

message FloatRectProto {
  optional float left = 1;
  optional float top = 2;
  optional float right = 3;
  optional float bottom = 4;
}

message CornerRadiiProto {
  optional float tl = 1;
  optional float tr = 2;
  optional float bl = 3;
  optional float br = 4;
}

message ActiveBufferProto {
  optional uint32 width = 1;
  optional uint32 height = 2;
  optional uint32 stride = 3;
  optional int32 format = 4;
  optional uint64 usage = 5;
}

message BarrierLayerProto {
  // layer id the barrier is waiting on.
  optional int32 id = 1;
  // frame number the barrier is waiting on.
  optional uint64 frame_number = 2;
}

// End of protos/perfetto/trace/android/surfaceflinger_layers.proto

// Begin of protos/perfetto/trace/android/surfaceflinger_transactions.proto

// Message used by Winscope to process legacy trace files.
// Represents a file full of surface flinger transactions.
// Encoded, it should start with 0x54 0x4E 0x58 0x54 0x52 0x41 0x43 0x45
// (.TNXTRACE), such that they can be easily identified.
message TransactionTraceFile {
  // constant; MAGIC_NUMBER = (long) MAGIC_NUMBER_H << 32 |
  // MagicNumber.MAGIC_NUMBER_L (this is needed because enums have to be 32 bits
  // and there's no nice way to put 64bit constants into .proto files.
  enum MagicNumber {
    INVALID = 0;
    // TNXT (little-endian ASCII)
    MAGIC_NUMBER_L = 0x54584E54;
    // RACE (little-endian ASCII)
    MAGIC_NUMBER_H = 0x45434152;
  }

  // Must be the first field, set to value in MagicNumber
  optional fixed64 magic_number = 1;
  repeated TransactionTraceEntry entry = 2;

  // offset between real-time clock and elapsed time clock in nanoseconds.
  // Calculated as: systemTime(SYSTEM_TIME_REALTIME) -
  // systemTime(SYSTEM_TIME_MONOTONIC)
  optional fixed64 real_to_elapsed_time_offset_nanos = 3;
  optional uint32 version = 4;
}

message TransactionTraceEntry {
  optional int64 elapsed_realtime_nanos = 1;
  optional int64 vsync_id = 2;
  repeated TransactionState transactions = 3;
  repeated LayerCreationArgs added_layers = 4;
  repeated uint32 destroyed_layers = 5;
  repeated DisplayState added_displays = 6;
  repeated int32 removed_displays = 7;
  repeated uint32 destroyed_layer_handles = 8;
  optional bool displays_changed = 9;
  repeated DisplayInfo displays = 10;
}

message DisplayInfo {
  optional uint32 layer_stack = 1;
  optional int32 display_id = 2;
  optional int32 logical_width = 3;
  optional int32 logical_height = 4;
  optional Transform transform_inverse = 5;
  optional Transform transform = 6;
  optional bool receives_input = 7;
  optional bool is_secure = 8;
  optional bool is_primary = 9;
  optional bool is_virtual = 10;
  optional int32 rotation_flags = 11;
  optional int32 transform_hint = 12;
}

message LayerCreationArgs {
  optional uint32 layer_id = 1;
  optional string name = 2;
  optional uint32 flags = 3;
  optional uint32 parent_id = 4;
  optional uint32 mirror_from_id = 5;
  optional bool add_to_root = 6;
  optional uint32 layer_stack_to_mirror = 7;
}

message Transform {
  optional float dsdx = 1;
  optional float dtdx = 2;
  optional float dtdy = 3;
  optional float dsdy = 4;
  optional float tx = 5;
  optional float ty = 6;
}

message TransactionBarrier {
  optional string barrier_token = 1;
  optional uint32 kind = 2;
}

message TransactionState {
  optional int32 pid = 1;
  optional int32 uid = 2;
  optional int64 vsync_id = 3;
  optional int32 input_event_id = 4;
  optional int64 post_time = 5;
  optional uint64 transaction_id = 6;
  repeated LayerState layer_changes = 7;
  repeated DisplayState display_changes = 8;
  repeated uint64 merged_transaction_ids = 9;
  optional uint64 apply_token = 10;
  repeated TransactionBarrier transaction_barriers = 11;
}

// Keep insync with layer_state_t
message LayerState {
  optional uint32 layer_id = 1;
  // Changes are split into ChangesLsb and ChangesMsb. First 32 bits are in
  // ChangesLsb and the next 32 bits are in ChangesMsb. This is needed because
  // enums have to be 32 bits and there's no nice way to put 64bit constants
  // into .proto files.
  enum ChangesLsb {
    eChangesLsbNone = 0;
    ePositionChanged = 0x00000001;
    eLayerChanged = 0x00000002;
    // unused = 0x00000004;
    eAlphaChanged = 0x00000008;

    eMatrixChanged = 0x00000010;
    eTransparentRegionChanged = 0x00000020;
    eFlagsChanged = 0x00000040;
    eLayerStackChanged = 0x00000080;

    eReleaseBufferListenerChanged = 0x00000400;
    eShadowRadiusChanged = 0x00000800;

    eBufferCropChanged = 0x00002000;
    eRelativeLayerChanged = 0x00004000;
    eReparent = 0x00008000;

    eColorChanged = 0x00010000;
    eBufferTransformChanged = 0x00040000;
    eTransformToDisplayInverseChanged = 0x00080000;

    eCropChanged = 0x00100000;
    eBufferChanged = 0x00200000;
    eAcquireFenceChanged = 0x00400000;
    eDataspaceChanged = 0x00800000;

    eHdrMetadataChanged = 0x01000000;
    eSurfaceDamageRegionChanged = 0x02000000;
    eApiChanged = 0x04000000;
    eSidebandStreamChanged = 0x08000000;

    eColorTransformChanged = 0x10000000;
    eHasListenerCallbacksChanged = 0x20000000;
    eInputInfoChanged = 0x40000000;
    // 0x80000000; (proto stores enums as signed int)
    eCornerRadiusChanged = -2147483648;
  };
  enum ChangesMsb {
    eChangesMsbNone = 0;
    eDestinationFrameChanged = 0x1;
    eCachedBufferChanged = 0x2;
    eBackgroundColorChanged = 0x4;
    eMetadataChanged = 0x8;
    eColorSpaceAgnosticChanged = 0x10;
    eFrameRateSelectionPriority = 0x20;
    eFrameRateChanged = 0x40;
    eBackgroundBlurRadiusChanged = 0x80;
    eProducerDisconnect = 0x100;
    eFixedTransformHintChanged = 0x200;
    eFrameNumberChanged = 0x400;
    eBlurRegionsChanged = 0x800;
    eAutoRefreshChanged = 0x1000;
    eStretchChanged = 0x2000;
    eTrustedOverlayChanged = 0x4000;
    eDropInputModeChanged = 0x8000;
    eClientDrawnCornerRadiusChanged = 0x00010000;
    eSystemContentPriorityChanged = 0x00020000;
    eBoxShadowSettingsChanged = 0x00040000;
    eBorderSettingsChanged = 0x00080000;
  };
  optional uint64 what = 2;
  optional float x = 3;
  optional float y = 4;
  optional int32 z = 5;
  optional uint32 w = 6;
  optional uint32 h = 7;
  optional uint32 layer_stack = 8;

  enum Flags {
    eFlagsNone = 0;
    eLayerHidden = 0x01;
    eLayerOpaque = 0x02;
    eLayerSkipScreenshot = 0x40;
    eLayerSecure = 0x80;
    eEnableBackpressure = 0x100;
    eLayerIsDisplayDecoration = 0x200;
  };
  optional uint32 flags = 9;
  optional uint32 mask = 10;

  message Matrix22 {
    optional float dsdx = 1;
    optional float dtdx = 2;
    optional float dtdy = 3;
    optional float dsdy = 4;
  };

  message CornerRadii {
    optional float tl = 1;
    optional float tr = 2;
    optional float bl = 3;
    optional float br = 4;
  }
  optional Matrix22 matrix = 11;
  optional float corner_radius = 12 [deprecated = true];
  optional uint32 background_blur_radius = 13;
  optional uint32 parent_id = 14;
  optional uint32 relative_parent_id = 15;

  optional float alpha = 16;
  message Color3 {
    optional float r = 1;
    optional float g = 2;
    optional float b = 3;
  }
  optional Color3 color = 17;
  optional RegionProto transparent_region = 18;
  optional uint32 transform = 19;
  optional bool transform_to_display_inverse = 20;
  optional RectProto crop = 21;

  message BufferData {
    optional uint64 buffer_id = 1;
    optional uint32 width = 2;
    optional uint32 height = 3;
    optional uint64 frame_number = 4;

    enum BufferDataChange {
      BufferDataChangeNone = 0;
      fenceChanged = 0x01;
      frameNumberChanged = 0x02;
      cachedBufferChanged = 0x04;
    }
    optional uint32 flags = 5;
    optional uint64 cached_buffer_id = 6;

    enum PixelFormat {
      PIXEL_FORMAT_UNKNOWN = 0;
      PIXEL_FORMAT_CUSTOM = -4;
      PIXEL_FORMAT_TRANSLUCENT = -3;
      PIXEL_FORMAT_TRANSPARENT = -2;
      PIXEL_FORMAT_OPAQUE = -1;
      PIXEL_FORMAT_RGBA_8888 = 1;
      PIXEL_FORMAT_RGBX_8888 = 2;
      PIXEL_FORMAT_RGB_888 = 3;
      PIXEL_FORMAT_RGB_565 = 4;
      PIXEL_FORMAT_BGRA_8888 = 5;
      PIXEL_FORMAT_RGBA_5551 = 6;
      PIXEL_FORMAT_RGBA_4444 = 7;
      PIXEL_FORMAT_RGBA_FP16 = 22;
      PIXEL_FORMAT_RGBA_1010102 = 43;
      PIXEL_FORMAT_R_8 = 0x38;
    }
    optional PixelFormat pixel_format = 7;
    optional uint64 usage = 8;
  }
  optional BufferData buffer_data = 22;
  optional int32 api = 23;
  optional bool has_sideband_stream = 24;
  optional ColorTransformProto color_transform = 25;
  repeated BlurRegion blur_regions = 26;

  message WindowInfo {
    optional uint32 layout_params_flags = 1;
    optional int32 layout_params_type = 2;
    optional RegionProto touchable_region = 3;
    optional int32 surface_inset = 4;
    // unused
    optional bool focusable = 5;
    // unused
    optional bool has_wallpaper = 6;
    optional float global_scale_factor = 7;
    optional uint32 crop_layer_id = 8;
    optional bool replace_touchable_region_with_crop = 9;
    optional RectProto touchable_region_crop = 10;
    optional Transform transform = 11;
    optional uint32 input_config = 12;
  }
  optional WindowInfo window_info_handle = 27;
  optional float bg_color_alpha = 28;
  optional int32 bg_color_dataspace = 29;
  optional bool color_space_agnostic = 30;
  optional float shadow_radius = 31;
  optional int32 frame_rate_selection_priority = 32;
  optional float frame_rate = 33;
  optional int32 frame_rate_compatibility = 34;
  optional int32 change_frame_rate_strategy = 35;
  optional uint32 fixed_transform_hint = 36;
  optional uint64 frame_number = 37;
  optional bool auto_refresh = 38;
  // unused
  optional bool is_trusted_overlay = 39;
  optional RectProto buffer_crop = 40;
  optional RectProto destination_frame = 41;

  enum DropInputMode {
    NONE = 0;
    ALL = 1;
    OBSCURED = 2;
  };
  optional DropInputMode drop_input_mode = 42;

  optional TrustedOverlay trusted_overlay = 43;

  optional float background_blur_scale = 44;

  optional CornerRadii corner_radii = 45;

  optional CornerRadii client_drawn_corner_radii = 46;

  optional int32 system_content_priority = 47;

  optional BoxShadowSettings box_shadow_settings = 48;

  optional BorderSettings border_settings = 49;
}

message DisplayState {
  enum Changes {
    eChangesNone = 0;
    eSurfaceChanged = 0x01;
    eLayerStackChanged = 0x02;
    eDisplayProjectionChanged = 0x04;
    eDisplaySizeChanged = 0x08;
    eFlagsChanged = 0x10;
  };
  optional int32 id = 1;
  optional uint32 what = 2;
  optional uint32 flags = 3;
  optional uint32 layer_stack = 4;
  optional uint32 orientation = 5;
  optional RectProto layer_stack_space_rect = 6;
  optional RectProto oriented_display_space_rect = 7;
  optional uint32 width = 8;
  optional uint32 height = 9;
}

// End of protos/perfetto/trace/android/surfaceflinger_transactions.proto

// Begin of protos/perfetto/trace/android/user_list.proto

message UserList {
  message UserInfo {
    optional string type = 1;
    optional uint64 uid = 2;
  }

  repeated UserInfo users = 1;

  // At least one error occurred parsing the user.list.
  optional bool parse_error = 2;

  // Failed to open / read user.list.
  optional bool read_error = 3;
}

// End of protos/perfetto/trace/android/user_list.proto

// Begin of protos/perfetto/trace/android/winscope_extensions.proto

message WinscopeExtensions {
  extensions 1 to 6;
}

// End of protos/perfetto/trace/android/winscope_extensions.proto

// Begin of protos/perfetto/trace/chrome/chrome_benchmark_metadata.proto

// This message is not intended to be written by the chrome on the device.
// It's emitted on the host by the telemetry benchmark infrastructure (it's a
// part of the trace that's written by the telemetry tracing agent).
message ChromeBenchmarkMetadata {
  // Time when the benchmark execution started (host unixtime in microseconds).
  optional int64 benchmark_start_time_us = 1;

  // Time when this particular story was run (host unixtime in microseconds).
  optional int64 story_run_time_us = 2;

  // Name of benchmark.
  optional string benchmark_name = 3;

  // Description of benchmark.
  optional string benchmark_description = 4;

  // Optional label.
  optional string label = 5;

  // Name of story.
  optional string story_name = 6;

  // List of story tags.
  repeated string story_tags = 7;

  // Index of the story run (>0 if the same story was run several times).
  optional int32 story_run_index = 8;

  // Whether this run failed.
  optional bool had_failures = 9;
}

// End of protos/perfetto/trace/chrome/chrome_benchmark_metadata.proto

// Begin of protos/perfetto/trace/chrome/chrome_metadata.proto

// Metadata for chrome traces.
message ChromeMetadataPacket {
  optional BackgroundTracingMetadata background_tracing_metadata = 1;

  // Version code of Chrome used by Android's Play Store. This field is only set
  // on Android.
  optional int32 chrome_version_code = 2;

  // Comma separated list of enabled categories for tracing. The list of
  // possible category strings are listed in code
  // base/trace_event/builtin_categories.h.
  optional string enabled_categories = 3;

  // Finch name and group based on the ActiveGroupId.
  message FinchHash {
    optional uint32 name = 1;
    optional uint32 group = 2;
  }

  // List of Finch study/groups that apply to this trace.
  repeated FinchHash field_trial_hashes = 4;
}

// Metadata related to background tracing scenarios, states and triggers.
message BackgroundTracingMetadata {
  // Information about a trigger rule defined in the experiment config.
  message TriggerRule {
    enum TriggerType {
      TRIGGER_UNSPECIFIED = 0;

      // Traces are triggered by specific range of values of an UMA histogram.
      MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = 1;

      // Traces are triggered by specific named events in chromium codebase,
      // like "second-update-failure".
      MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = 2;
    }
    optional TriggerType trigger_type = 1;

    // Configuration of histogram trigger.
    message HistogramRule {
      // UMA histogram name hash, same as HistogramEventProto.name_hash.
      optional fixed64 histogram_name_hash = 1;

      // Range of values of the histogram that activates trigger.
      optional int64 histogram_min_trigger = 2;
      optional int64 histogram_max_trigger = 3;
    }
    optional HistogramRule histogram_rule = 2;

    // Configuration of named trigger.
    message NamedRule {
      enum EventType {
        UNSPECIFIED = 0;
        SESSION_RESTORE = 1;
        NAVIGATION = 2;
        STARTUP = 3;
        REACHED_CODE = 4;
        CONTENT_TRIGGER = 5;

        TEST_RULE = 1000;
      }
      optional EventType event_type = 1;

      // If |event_type| is CONTENT_TRIGGER, then this stores the hash of the
      // content-trigger that actually fired.
      optional fixed64 content_trigger_name_hash = 2;
    }
    optional NamedRule named_rule = 3;

    // Hash of the rule name.
    optional fixed32 name_hash = 4;
  }

  // Specifies the rule that caused the trace to be uploaded.
  optional TriggerRule triggered_rule = 1;

  // List of all active triggers in current session, when trace was triggered.
  repeated TriggerRule active_rules = 2;

  // Hash of the scenario name.
  optional fixed32 scenario_name_hash = 3;
}

// End of protos/perfetto/trace/chrome/chrome_metadata.proto

// Begin of protos/perfetto/trace/chrome/chrome_trace_event.proto

message ChromeTracedValue {
  enum NestedType {
    DICT = 0;
    ARRAY = 1;
  }
  optional NestedType nested_type = 1;

  repeated string dict_keys = 2;
  repeated ChromeTracedValue dict_values = 3;
  repeated ChromeTracedValue array_values = 4;
  optional int32 int_value = 5;
  optional double double_value = 6;
  optional bool bool_value = 7;
  optional string string_value = 8;
}

message ChromeStringTableEntry {
  optional string value = 1;
  optional int32 index = 2;
}

// Deprecated, use TrackEvent protos instead.
message ChromeTraceEvent {
  message Arg {
    optional string name = 1;

    oneof value {
      bool bool_value = 2;
      uint64 uint_value = 3;
      int64 int_value = 4;
      double double_value = 5;
      string string_value = 6;
      // Pointers are stored in a separate type as the JSON output treats them
      // differently from other uint64 values.
      uint64 pointer_value = 7;
      string json_value = 8;
      ChromeTracedValue traced_value = 10;
    }

    // Takes precedence over |name| if set,
    // and is an index into |string_table|.
    optional uint32 name_index = 9;
  }

  optional string name = 1;
  optional int64 timestamp = 2;
  optional int32 phase = 3;
  optional int32 thread_id = 4;
  optional int64 duration = 5;
  optional int64 thread_duration = 6;
  optional string scope = 7;
  optional uint64 id = 8;
  optional uint32 flags = 9;
  optional string category_group_name = 10;
  optional int32 process_id = 11;
  optional int64 thread_timestamp = 12;
  optional uint64 bind_id = 13;

  repeated Arg args = 14;

  // Takes precedence over respectively |name| and
  // |category_group_name_index| if set,
  // and are indices into |string_table|.
  optional uint32 name_index = 15;
  optional uint32 category_group_name_index = 16;
}

message ChromeMetadata {
  optional string name = 1;

  oneof value {
    string string_value = 2;
    bool bool_value = 3;
    int64 int_value = 4;
    string json_value = 5;
  }
}

// Subtraces produced in legacy json format by Chrome tracing agents not yet
// updated to support the new binary format, e.g. ETW and CrOS ARC.
// TODO(eseckler): Update these agents to become perfetto producers.
message ChromeLegacyJsonTrace {
  enum TraceType {
    USER_TRACE = 0;

    // Deprecated.
    SYSTEM_TRACE = 1;
  }
  optional TraceType type = 1;
  optional string data = 2;
}

message ChromeEventBundle {
  // Deprecated, use TrackEvent protos instead.
  repeated ChromeTraceEvent trace_events = 1 [deprecated = true];
  // TODO(ssid): This should be deprecated in favor of ChromeMetadataPacket
  // which contains typed fields.
  repeated ChromeMetadata metadata = 2;
  // ftrace output from CrOS and Cast system tracing agents.
  // TODO(eseckler): Replace system traces with native perfetto service.
  repeated string legacy_ftrace_output = 4;
  repeated ChromeLegacyJsonTrace legacy_json_trace = 5;

  // Contents of a string table that's valid for
  // the whole ChromeEventBundle entry.
  repeated ChromeStringTableEntry string_table = 3 [deprecated = true];
}

// End of protos/perfetto/trace/chrome/chrome_trace_event.proto

// Begin of protos/perfetto/trace/chrome/chrome_trigger.proto

// Information about a specific trigger during a background tracing scenario
// Associated packet timestamps are useful to delimitate a scenario range in a
// trace. Triggers are also useful for filtering traces.
message ChromeTrigger {
  // Name of the trigger which was received.
  optional string trigger_name = 1;
  // SHA1 hash of the trigger name.
  optional fixed32 trigger_name_hash = 2;
  // Flow id which should terminate on this trigger.
  optional fixed64 flow_id = 3;
}

// End of protos/perfetto/trace/chrome/chrome_trigger.proto

// Begin of protos/perfetto/trace/chrome/v8.proto

// These are the protos for the V8 data source.
//
// All events are associated to a V8 isolate instance. There can be multiple
// instances associated to a given thread, although this is rare.
//
// Generated code in V8 is allocated in the V8 heap (in a special executeable
// section), this means that code can be garbage collected (when no longer used)
// or can be moved around (e.g. during heap compactation). This means that a
// given callsite might correspond to function `A` at one point in time and to
// function `B` later on.
// In addition V8 code has various levels of optimization, so a function might
// have multiple associated code snippets.
//
// V8 does not track code deletion, so we have to indirectly infer it by
// detecting code overlaps, if a newer code creation event overlaps with older
// code we need to asume that the old code was deleted. Code moves are logged,
// and there is an event to track those.

// Strings used by V8 can have different encodings, instead of coverting to a
// common encoding (e.g. UTF-8) on device is expensive. Instead we send the
// "raw" string and do the convestion at trace ingestion time.
//
// ATTENTION: There is some overhead in using a message (as opossed to having
// the `oneof encoded_string`` direcly embedded in the message), so use this
// message in places were these extra bytes don't matter that much.
// Next id: 5
message V8String {
  oneof encoded_string {
    // ISO/IEC 8859-1:1998 encoding aka latin1
    // https://en.wikipedia.org/wiki/ISO/IEC_8859-1
    bytes latin1 = 1;
    // UTF-16 Little Endian Encoding
    bytes utf16_le = 2;
    // UTF-16 Big Endian Encoding
    bytes utf16_be = 3;
  }
}

// Interned version of V8String
message InternedV8String {
  optional uint64 iid = 1;
  // We inline the fields in V8String here to save some bytes in the serialized
  // proto format. Interning is about saving bytes so this makes sense here.
  oneof encoded_string {
    // ISO/IEC 8859-1:1998 encoding aka latin1
    // https://en.wikipedia.org/wiki/ISO/IEC_8859-1
    bytes latin1 = 2;
    // UTF-16 Little Endian Encoding
    bytes utf16_le = 3;
    // UTF-16 Big Endian Encoding
    bytes utf16_be = 4;
  }
}

// Represents a script that was compiled to generate code. Some V8 code is
// generated out of scripts and will reference a V8Script other types of code
// will not (e.g. builtins).
message InternedV8JsScript {
  optional uint64 iid = 1;
  // Unique in a given isolate
  optional int32 script_id = 2;

  enum Type {
    TYPE_UNKNOWN = 0;
    TYPE_NORMAL = 1;
    TYPE_EVAL = 2;
    TYPE_MODULE = 3;
    TYPE_NATIVE = 4;
    TYPE_EXTENSION = 5;
    TYPE_INSPECTOR = 6;
  }

  optional Type type = 3;
  optional V8String name = 4;
  // Actual source of the script
  optional V8String source = 5;
}

message InternedV8WasmScript {
  optional uint64 iid = 1;
  // Unique in a given isolate
  optional int32 script_id = 2;

  optional string url = 3;
  // Raw transferred wasm native module wire bytes.
  optional bytes wire_bytes = 4;
}

message InternedV8JsFunction {
  enum Kind {
    KIND_UNKNOWN = 0;
    KIND_NORMAL_FUNCTION = 1;
    KIND_MODULE = 2;
    KIND_ASYNC_MODULE = 3;
    KIND_BASE_CONSTRUCTOR = 4;
    KIND_DEFAULT_BASE_CONSTRUCTOR = 5;
    KIND_DEFAULT_DERIVED_CONSTRUCTOR = 6;
    KIND_DERIVED_CONSTRUCTOR = 7;
    KIND_GETTER_FUNCTION = 8;
    KIND_STATIC_GETTER_FUNCTION = 9;
    KIND_SETTER_FUNCTION = 10;
    KIND_STATIC_SETTER_FUNCTION = 11;
    KIND_ARROW_FUNCTION = 12;
    KIND_ASYNC_ARROW_FUNCTION = 13;
    KIND_ASYNC_FUNCTION = 14;
    KIND_ASYNC_CONCISE_METHOD = 15;
    KIND_STATIC_ASYNC_CONCISE_METHOD = 16;
    KIND_ASYNC_CONCISE_GENERATOR_METHOD = 17;
    KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = 18;
    KIND_ASYNC_GENERATOR_FUNCTION = 19;
    KIND_GENERATOR_FUNCTION = 20;
    KIND_CONCISE_GENERATOR_METHOD = 21;
    KIND_STATIC_CONCISE_GENERATOR_METHOD = 22;
    KIND_CONCISE_METHOD = 23;
    KIND_STATIC_CONCISE_METHOD = 24;
    KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = 25;
    KIND_CLASS_STATIC_INITIALIZER_FUNCTION = 26;
    KIND_INVALID = 27;
  }
  optional uint64 iid = 1;
  optional uint64 v8_js_function_name_iid = 2;
  optional uint64 v8_js_script_iid = 3;

  optional bool is_toplevel = 4;
  optional Kind kind = 5;

  // Where in the script source this function is defined. This is counted in
  // bytes not characters.
  optional uint32 byte_offset = 6;
  optional uint32 line = 7;
  optional uint32 column = 8;
}

// A V8 Isolate instance. A V8 Isolate represents an isolated instance of the V8
// engine.
message InternedV8Isolate {
  optional uint64 iid = 1;

  optional uint32 pid = 2;

  // Process unique isolate id.
  optional int32 isolate_id = 3;

  // A code range is a virtual memory cage that may contain executable code.
  // Depending on the Isolate settings the Isolate might have one or not.
  // See:
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/code-range.h
  // If the isolate defines code range this will be tracked here.
  message CodeRange {
    optional uint64 base_address = 1;
    optional uint64 size = 2;
    // Used when short builtin calls are enabled, where embedded builtins are
    // copied into the CodeRange so calls can be nearer.
    optional uint64 embedded_blob_code_copy_start_address = 3;
    // Whether this code range is shared with other Isolates in the same process
    optional bool is_process_wide = 4;
  }
  optional CodeRange code_range = 4;
  // The embedded blob holds code for built in functions that are precompiled in
  // the V8 library.
  optional uint64 embedded_blob_code_start_address = 5;
  optional uint64 embedded_blob_code_size = 6;
}

message V8JsCode {
  enum Tier {
    TIER_UNKNOWN = 0;
    TIER_IGNITION = 1;
    TIER_SPARKPLUG = 2;
    TIER_MAGLEV = 3;
    TIER_TURBOSHAFT = 4;
    TIER_TURBOFAN = 5;
  }
  optional uint64 v8_isolate_iid = 1;
  optional uint32 tid = 2;
  optional uint64 v8_js_function_iid = 3;
  optional Tier tier = 4;

  optional uint64 instruction_start = 5;
  optional uint64 instruction_size_bytes = 6;
  oneof instructions {
    bytes machine_code = 7;
    bytes bytecode = 8;
  }
}

message V8InternalCode {
  enum Type {
    TYPE_UNKNOWN = 0;
    TYPE_BYTECODE_HANDLER = 1;
    TYPE_FOR_TESTING = 2;
    TYPE_BUILTIN = 3;
    TYPE_WASM_FUNCTION = 4;
    TYPE_WASM_TO_CAPI_FUNCTION = 5;
    TYPE_WASM_TO_JS_FUNCTION = 6;
    TYPE_JS_TO_WASM_FUNCTION = 7;
    TYPE_JS_TO_JS_FUNCTION = 8;
    TYPE_C_WASM_ENTRY = 9;
  }
  optional uint64 v8_isolate_iid = 1;
  optional uint32 tid = 2;
  optional string name = 3;
  optional Type type = 4;
  optional int32 builtin_id = 5;

  optional uint64 instruction_start = 6;
  optional uint64 instruction_size_bytes = 7;
  optional bytes machine_code = 8;
}

message V8WasmCode {
  enum Tier {
    TIER_UNKNOWN = 0;
    TIER_LIFTOFF = 1;
    TIER_TURBOFAN = 2;
  }
  optional uint64 v8_isolate_iid = 1;
  optional uint32 tid = 2;
  optional uint64 v8_wasm_script_iid = 3;
  optional string function_name = 4;

  optional Tier tier = 5;
  optional int32 code_offset_in_module = 6;

  optional uint64 instruction_start = 7;
  optional uint64 instruction_size_bytes = 8;
  optional bytes machine_code = 9;
}

message V8RegExpCode {
  optional uint64 v8_isolate_iid = 1;
  optional uint32 tid = 2;
  optional V8String pattern = 3;

  optional uint64 instruction_start = 4;
  optional uint64 instruction_size_bytes = 5;
  optional bytes machine_code = 6;
}

// Move event for V8 code (JS / Wasm / Internal / Regexp) that was relocated in
// memory by V8's GC.
message V8CodeMove {
  optional uint64 isolate_iid = 1;
  optional uint32 tid = 2;
  optional uint64 from_instruction_start_address = 3;
  optional uint64 to_instruction_start_address = 4;
  optional uint64 instruction_size_bytes = 5;
  oneof to_instructions {
    bytes to_machine_code = 6;
    bytes to_bytecode = 7;
  }
}

message V8CodeDefaults {
  optional uint32 tid = 1;
}

// End of protos/perfetto/trace/chrome/v8.proto

// Begin of protos/perfetto/trace/clock_snapshot.proto

// A snapshot of clock readings to allow for trace alignment.
message ClockSnapshot {
  message Clock {
    // DEPRECATED. This enum has moved to ../common/builtin_clock.proto.
    enum BuiltinClocks {
      UNKNOWN = 0;
      REALTIME = 1;
      REALTIME_COARSE = 2;
      MONOTONIC = 3;
      MONOTONIC_COARSE = 4;
      MONOTONIC_RAW = 5;
      BOOTTIME = 6;
      BUILTIN_CLOCK_MAX_ID = 63;

      reserved 7, 8;
    }

    // Clock IDs have the following semantic:
    // [1, 63]:    Builtin types, see BuiltinClock from
    //             ../common/builtin_clock.proto.
    // [64, 127]:  User-defined clocks. These clocks are sequence-scoped. They
    //             are only valid within the same |trusted_packet_sequence_id|
    //             (i.e. only for TracePacket(s) emitted by the same TraceWriter
    //             that emitted the clock snapshot).
    // [128, MAX]: Reserved for future use. The idea is to allow global clock
    //             IDs and setting this ID to hash(full_clock_name) & ~127.
    optional uint32 clock_id = 1;

    // Absolute timestamp. Unit is ns unless specified otherwise by the
    // unit_multiplier_ns field below.
    optional uint64 timestamp = 2;

    // When true each TracePacket's timestamp should be interpreted as a delta
    // from the last TracePacket's timestamp (referencing this clock) emitted by
    // the same packet_sequence_id. Should only be used for user-defined
    // sequence-local clocks. The first packet timestamp after each
    // ClockSnapshot that contains this clock is relative to the |timestamp| in
    // the ClockSnapshot.
    optional bool is_incremental = 3;

    // Allows to specify a custom unit different than the default (ns) for this
    // clock domain.
    //
    // * A multiplier of 1000 means that a timestamp = 3 should be interpreted
    //   as 3000 ns = 3 us.
    // * All snapshots for the same clock within a trace need to use the same
    //   unit.
    // * `unit_multiplier_ns` is *not* supported for the `primary_trace_clock`.
    optional uint64 unit_multiplier_ns = 4;
  }
  repeated Clock clocks = 1;

  // The authoritative clock domain for the trace. Defaults to BOOTTIME, but can
  // be overridden in TraceConfig's builtin_data_sources. Trace processor will
  // attempt to translate packet/event timestamps from various data sources (and
  // their chosen clock domains) to this domain during import.
  optional BuiltinClock primary_trace_clock = 2;
}

// End of protos/perfetto/trace/clock_snapshot.proto

// Begin of protos/perfetto/trace/etw/etw.proto

// Proto definition based on the Thread_v2 CSwitch class definition
// See: https://learn.microsoft.com/en-us/windows/win32/etw/cswitch
message CSwitchEtwEvent {
  // New thread ID after the switch.
  optional uint32 new_thread_id = 1;

  // Previous thread ID.
  optional uint32 old_thread_id = 2;

  // Thread priority of the new thread.
  optional sint32 new_thread_priority = 3;

  // Thread priority of the previous thread.
  optional sint32 old_thread_priority = 4;

  // The index of the C-state that was last used by the processor. A value of 0
  // represents the lightest idle state with higher values representing deeper
  // C-states.
  optional uint32 previous_c_state = 5;

  // Wait reason for the previous thread. The ordering is important as based on
  // the OldThreadWaitReason definition from the link above. The following are
  // the possible values:
  enum OldThreadWaitReason {
    EXECUTIVE = 0;
    FREE_PAGE = 1;
    PAGE_IN = 2;
    POOL_ALLOCATION = 3;
    DELAY_EXECUTION = 4;
    SUSPEND = 5;
    USER_REQUEST = 6;
    WR_EXECUTIVE = 7;
    WR_FREE_PAGE = 8;
    WR_PAGE_IN = 9;
    WR_POOL_ALLOCATION = 10;
    WR_DELAY_EXECUTION = 11;
    WR_SUSPENDED = 12;
    WR_USER_REQUEST = 13;
    WR_EVENT_PAIR = 14;
    WR_QUEUE = 15;
    WR_LPC_RECEIVER = 16;
    WR_LPC_REPLY = 17;
    WR_VIRTUAL_MEMORY = 18;
    WR_PAGE_OUT = 19;
    WR_RENDEZ_VOUS = 20;
    WR_KEYED_EVENT = 21;
    WR_TERMINATED = 22;
    WR_PROCESS_IN_SWAP = 23;
    WR_CPU_RATE_CONTROL = 24;
    WR_CALLOUT_STACK = 25;
    WR_KERNEL = 26;
    WR_RESOURCE = 27;
    WR_PUSH_LOCK = 28;
    WR_MUTEX = 29;
    WR_QUANTUM_END = 30;
    WR_DISPATCH_INT = 31;
    WR_PREEMPTED = 32;
    WR_YIELD_EXECUTION = 33;
    WR_FAST_MUTEX = 34;
    WR_GUARD_MUTEX = 35;
    WR_RUNDOWN = 36;
    MAXIMUM_WAIT_REASON = 37;
  }

  oneof old_thread_wait_reason_enum_or_int {
    OldThreadWaitReason old_thread_wait_reason = 6;
    int32 old_thread_wait_reason_int = 11;
  }

  // Wait mode for the previous thread. The ordering is important as based on
  // the OldThreadWaitMode definition from the link above. The following are the
  // possible values:
  enum OldThreadWaitMode {
    KERNEL_MODE = 0;
    USER_MODE = 1;
  }

  oneof old_thread_wait_mode_enum_or_int {
    OldThreadWaitMode old_thread_wait_mode = 7;
    int32 old_thread_wait_mode_int = 12;
  }

  // State of the previous thread. The ordering is important as based on the
  // OldThreadState definition from the link above. The following are the
  // possible state values:
  enum OldThreadState {
    INITIALIZED = 0;
    READY = 1;
    RUNNING = 2;
    STANDBY = 3;
    TERMINATED = 4;
    WAITING = 5;
    TRANSITION = 6;
    DEFERRED_READY = 7;
  }

  oneof old_thread_state_enum_or_int {
    OldThreadState old_thread_state = 8;
    sint32 old_thread_state_int = 13;
  }

  // Ideal wait time of the previous thread.
  optional sint32 old_thread_wait_ideal_processor = 9;

  // Wait time for the new thread.
  optional uint32 new_thread_wait_time = 10;
}

// Proto definition based on the Thread_v2 CSwitch class definition
// See: https://learn.microsoft.com/en-us/windows/win32/etw/readythread
message ReadyThreadEtwEvent {
  // The thread identifier of the thread being readied for execution.
  optional uint32 t_thread_id = 1;

  // The reason for the priority boost. The ordering is important as based on
  // the AdjustReason definition from the link above.
  enum AdjustReason {
    IGNORE_THE_INCREMENT = 0;
    // Apply the increment, which will decay incrementally at the end of each
    // quantum.
    APPLY_INCREMENT = 1;
    // Apply the increment as a boost that will decay in its entirety at quantum
    // (typically for priority donation).
    APPLY_INCREMENT_BOOST = 2;
  }

  oneof adjust_reason_enum_or_int {
    AdjustReason adjust_reason = 2;
    int32 adjust_reason_int = 5;
  }

  //  The value by which the priority is being adjusted.
  optional sint32 adjust_increment = 3;

  enum TraceFlag {
    TRACE_FLAG_UNSPECIFIED = 0;
    // The thread has been readied from DPC (deferred procedure call).
    THREAD_READIED = 0x1;
    // The kernel stack is currently swapped out.
    KERNEL_STACK_SWAPPED_OUT = 0x2;
    // The process address space is swapped out.
    PROCESS_ADDRESS_SWAPPED_OUT = 0x4;
  }

  oneof flag_enum_or_int {
    TraceFlag flag = 4;
    int32 flag_int = 6;
  }
}

// Proto definition based on the type of MemInfoArgs_V1, found here and observed
// on local traces using tracerpt:
// https://github.com/repnz/etw-providers-docs/blob/master/Manifests-Win10-17134/Microsoft-Windows-Kernel-Memory.xml
message MemInfoEtwEvent {
  // Number of memory priorities on the system.
  optional uint32 priority_levels = 1;

  // Number of pages in the zero list.
  optional uint64 zero_page_count = 2;

  // Number of pages in the free list.
  optional uint64 free_page_count = 3;

  // Number of pages in the modified list.
  optional uint64 modified_page_count = 4;

  // Number of modified non-paged pool pages.
  optional uint64 modified_no_write_page_count = 5;

  // Number of bad pages.
  optional uint64 bad_page_count = 6;

  // Number of standby pages by memory priority.
  repeated uint64 standby_page_counts = 7;

  // Number of repurposed pages by memory priority.
  repeated uint64 repurposed_page_counts = 8;

  // Modified paged pages.
  optional uint64 modified_page_count_page_file = 9;
  // Pool page counts.
  optional uint64 paged_pool_page_count = 10;
  optional uint64 non_paged_pool_page_count = 11;

  // Memory Descriptor List page count.
  optional uint64 mdl_page_count = 12;

  // Commit weight.
  optional uint64 commit_page_count = 13;
}

// Proto definition based on the `FileIo_Create` class definition.
message FileIoCreateEtwEvent {
  optional uint64 irp_ptr = 1;
  optional uint64 file_object = 2;
  optional uint32 ttid = 3;
  optional uint32 create_options = 4;
  optional uint32 file_attributes = 5;
  optional uint32 share_access = 6;
  optional string open_path = 7;
}

// Proto definition based on the `FileIo_DirEnum` class definition.
message FileIoDirEnumEtwEvent {
  optional uint64 irp_ptr = 1;
  optional uint64 file_object = 2;
  optional uint64 file_key = 3;
  optional uint32 ttid = 4;
  optional uint32 length = 5;
  optional uint32 info_class = 6;
  optional uint32 file_index = 7;
  optional string file_name = 8;
}

// Proto definition based on the `FileIo_Info` class definition.
message FileIoInfoEtwEvent {
  optional uint64 irp_ptr = 1;
  optional uint64 file_object = 2;
  optional uint64 file_key = 3;
  optional uint64 extra_info = 4;
  optional uint32 ttid = 5;
  optional uint32 info_class = 6;
}

// Proto definition based on the `FileIo_ReadWrite` class definition.
message FileIoReadWriteEtwEvent {
  optional uint64 offset = 1;
  optional uint64 irp_ptr = 2;
  optional uint64 file_object = 3;
  optional uint64 file_key = 4;
  optional uint32 ttid = 5;
  optional uint32 io_size = 6;
  optional uint32 io_flags = 7;
}

// Proto definition based on the `FileIo_SimpleOp` class definition.
message FileIoSimpleOpEtwEvent {
  optional uint64 irp_ptr = 1;
  optional uint64 file_object = 2;
  optional uint64 file_key = 3;
  optional uint32 ttid = 4;
}

// Proto definition based on the `FileIo_OpEnd` class definition.
message FileIoOpEndEtwEvent {
  optional uint64 irp_ptr = 1;
  optional uint64 extra_info = 2;
  optional uint32 nt_status = 3;
}

// End of protos/perfetto/trace/etw/etw.proto

// Begin of protos/perfetto/trace/etw/etw_event.proto

message EtwTraceEvent {
  optional uint64 timestamp = 1;
  optional uint32 cpu = 4;
  optional uint32 thread_id = 5;

  oneof event {
    CSwitchEtwEvent c_switch = 2;
    ReadyThreadEtwEvent ready_thread = 3;
    MemInfoEtwEvent mem_info = 6;
    FileIoCreateEtwEvent file_io_create = 7;
    FileIoDirEnumEtwEvent file_io_dir_enum = 8;
    FileIoInfoEtwEvent file_io_info = 9;
    FileIoReadWriteEtwEvent file_io_read_write = 10;
    FileIoSimpleOpEtwEvent file_io_simple_op = 11;
    FileIoOpEndEtwEvent file_io_op_end = 12;
  }
}

// End of protos/perfetto/trace/etw/etw_event.proto

// Begin of protos/perfetto/trace/etw/etw_event_bundle.proto

// The result of tracing one or more etw event uses per-processor buffers where
// an in-use buffer is assigned to each processor at all times. Therefore,
// collecting multiple events they should already be synchronized.
message EtwTraceEventBundle {
  optional uint32 cpu = 1;
  repeated EtwTraceEvent event = 2;
}
// End of protos/perfetto/trace/etw/etw_event_bundle.proto

// Begin of protos/perfetto/trace/evdev.proto

// Records an event in the evdev protocol, as used by Linux and some other *nix
// kernels to report events from human interface devices.
//
// Next ID: 3
message EvdevEvent {
  // The device's unique ID number. This need not be the number of its
  // /dev/input/event node.
  optional uint32 device_id = 1;

  oneof event {
    InputEvent input_event = 2;
  }

  // Proto version of Linux's struct input_event. The meaning of types and codes
  // are described in the Linux kernel documentation at
  // https://www.kernel.org/doc/html/latest/input/event-codes.html.
  //
  // Next ID: 5
  message InputEvent {
    // The monotonic timestamp at which the event occurred, as reported by the
    // kernel, in integer nanoseconds. If omitted, assume that it hasn't changed
    // since the previous event.
    optional uint64 kernel_timestamp = 1;

    // The code grouping for this event, used to distinguish signals, absolute
    // and relative axis changes, and other types of event.
    optional uint32 type = 2;
    // The precise type of the event, such as the axis code for absolute and
    // relative events.
    optional uint32 code = 3;
    // The new value of the axis described by type and code.
    optional sint32 value = 4;
  }
}

// End of protos/perfetto/trace/evdev.proto

// Begin of protos/perfetto/common/descriptor.proto

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
message FileDescriptorSet {
  repeated FileDescriptorProto file = 1;
}

// Describes a complete .proto file.
message FileDescriptorProto {
  // file name, relative to root of source tree
  optional string name = 1;
  // e.g. "foo", "foo.bar", etc.
  optional string package = 2;

  // Names of files imported by this file.
  repeated string dependency = 3;
  // Indexes of the public imported files in the dependency list above.
  repeated int32 public_dependency = 10;
  // Indexes of the weak imported files in the dependency list.
  // For Google-internal migration only. Do not use.
  repeated int32 weak_dependency = 11;

  // All top-level definitions in this file.
  repeated DescriptorProto message_type = 4;
  repeated EnumDescriptorProto enum_type = 5;
  repeated FieldDescriptorProto extension = 7;

  reserved 6;
  reserved 8;
  reserved 9;
  reserved 12;
}

// Describes a message type.
message DescriptorProto {
  optional string name = 1;

  repeated FieldDescriptorProto field = 2;
  repeated FieldDescriptorProto extension = 6;

  repeated DescriptorProto nested_type = 3;
  repeated EnumDescriptorProto enum_type = 4;

  reserved 5;

  repeated OneofDescriptorProto oneof_decl = 8;

  reserved 7;

  // Range of reserved tag numbers. Reserved tag numbers may not be used by
  // fields or extension ranges in the same message. Reserved ranges may
  // not overlap.
  message ReservedRange {
    // Inclusive.
    optional int32 start = 1;
    // Exclusive.
    optional int32 end = 2;
  }
  repeated ReservedRange reserved_range = 9;
  // Reserved field names, which may not be used by fields in the same message.
  // A given name may only be reserved once.
  repeated string reserved_name = 10;
}

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
  // "foo.(bar.baz).moo".
  message NamePart {
    optional string name_part = 1;
    optional bool is_extension = 2;
  }
  repeated NamePart name = 2;

  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
}

message FieldOptions {
  // The packed option can be enabled for repeated primitive fields to enable
  // a more efficient representation on the wire. Rather than repeatedly
  // writing the tag and type for each element, the entire array is encoded as
  // a single length-delimited blob. In proto3, only explicit setting it to
  // false will avoid using packed encoding.
  optional bool packed = 2;

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;
}

// Describes a field within a message.
message FieldDescriptorProto {
  enum Type {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    TYPE_DOUBLE = 1;
    TYPE_FLOAT = 2;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    TYPE_INT64 = 3;
    TYPE_UINT64 = 4;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    TYPE_INT32 = 5;
    TYPE_FIXED64 = 6;
    TYPE_FIXED32 = 7;
    TYPE_BOOL = 8;
    TYPE_STRING = 9;
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    TYPE_GROUP = 10;
    // Length-delimited aggregate.
    TYPE_MESSAGE = 11;

    // New in version 2.
    TYPE_BYTES = 12;
    TYPE_UINT32 = 13;
    TYPE_ENUM = 14;
    TYPE_SFIXED32 = 15;
    TYPE_SFIXED64 = 16;
    // Uses ZigZag encoding.
    TYPE_SINT32 = 17;
    // Uses ZigZag encoding.
    TYPE_SINT64 = 18;
  };

  enum Label {
    // 0 is reserved for errors
    LABEL_OPTIONAL = 1;
    LABEL_REQUIRED = 2;
    LABEL_REPEATED = 3;
  };

  optional string name = 1;
  optional int32 number = 3;
  optional Label label = 4;

  // If type_name is set, this need not be set.  If both this and type_name
  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  optional Type type = 5;

  // For message and enum types, this is the name of the type.  If the name
  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  // rules are used to find the type (i.e. first the nested types within this
  // message are searched, then within the parent, on up to the root
  // namespace).
  optional string type_name = 6;

  // For extensions, this is the name of the type being extended.  It is
  // resolved in the same manner as type_name.
  optional string extendee = 2;

  // For numeric types, contains the original text representation of the value.
  // For booleans, "true" or "false".
  // For strings, contains the default text contents (not escaped in any way).
  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  // TODO(kenton):  Base-64 encode?
  optional string default_value = 7;

  optional FieldOptions options = 8;

  // If set, gives the index of a oneof in the containing type's oneof_decl
  // list.  This field is a member of that oneof.
  optional int32 oneof_index = 9;

  reserved 10;
}

// Describes a oneof.
message OneofDescriptorProto {
  optional string name = 1;
  optional OneofOptions options = 2;
}

// Describes an enum type.
message EnumDescriptorProto {
  optional string name = 1;

  repeated EnumValueDescriptorProto value = 2;

  reserved 3;
  reserved 4;

  // Reserved enum value names, which may not be reused. A given name may only
  // be reserved once.
  repeated string reserved_name = 5;
}

// Describes a value within an enum.
message EnumValueDescriptorProto {
  optional string name = 1;
  optional int32 number = 2;

  reserved 3;
}

message OneofOptions {
  reserved 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

// End of protos/perfetto/common/descriptor.proto

// Begin of protos/perfetto/trace/extension_descriptor.proto

// This message contains descriptors used to parse extension fields of
// TrackEvent.
//
// See docs/design-docs/extensions.md for more details.
message ExtensionDescriptor {
  optional FileDescriptorSet extension_set = 1;
}

// End of protos/perfetto/trace/extension_descriptor.proto

// Begin of protos/perfetto/trace/filesystem/inode_file_map.proto

// Represents the mapping between inode numbers in a block device and their path
// on the filesystem
message InodeFileMap {
  // Representation of Entry
  message Entry {
    optional uint64 inode_number = 1;

    // The path to the file, e.g. "etc/file.xml"
    // List of strings for multiple hardlinks
    repeated string paths = 2;

    // The file type
    enum Type {
      UNKNOWN = 0;
      FILE = 1;
      DIRECTORY = 2;
    }
    optional Type type = 3;
  }

  optional uint64 block_device_id = 1;

  // The mount points of the block device, e.g. ["system"].
  repeated string mount_points = 2;

  // The list of all the entries from the block device
  repeated Entry entries = 3;
}

// End of protos/perfetto/trace/filesystem/inode_file_map.proto

// Begin of protos/perfetto/trace/ftrace/android_fs.proto

message AndroidFsDatareadEndFtraceEvent {
  optional int32 bytes = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
}
message AndroidFsDatareadStartFtraceEvent {
  optional int32 bytes = 1;
  optional string cmdline = 2;
  optional int64 i_size = 3;
  optional uint64 ino = 4;
  optional int64 offset = 5;
  optional string pathbuf = 6;
  optional int32 pid = 7;
}
message AndroidFsDatawriteEndFtraceEvent {
  optional int32 bytes = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
}
message AndroidFsDatawriteStartFtraceEvent {
  optional int32 bytes = 1;
  optional string cmdline = 2;
  optional int64 i_size = 3;
  optional uint64 ino = 4;
  optional int64 offset = 5;
  optional string pathbuf = 6;
  optional int32 pid = 7;
}
message AndroidFsFsyncEndFtraceEvent {
  optional int32 bytes = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
}
message AndroidFsFsyncStartFtraceEvent {
  optional string cmdline = 1;
  optional int64 i_size = 2;
  optional uint64 ino = 3;
  optional string pathbuf = 4;
  optional int32 pid = 5;
}

// End of protos/perfetto/trace/ftrace/android_fs.proto

// Begin of protos/perfetto/trace/ftrace/bcl_exynos.proto

message BclIrqTriggerFtraceEvent {
  optional int32 id = 1;
  optional int32 throttle = 2;
  optional int32 cpu0_limit = 3;
  optional int32 cpu1_limit = 4;
  optional int32 cpu2_limit = 5;
  optional int32 tpu_limit = 6;
  optional int32 gpu_limit = 7;
  optional int32 voltage = 8;
  optional int32 capacity = 9;
}

// End of protos/perfetto/trace/ftrace/bcl_exynos.proto

// Begin of protos/perfetto/trace/ftrace/binder.proto

message BinderTransactionFtraceEvent {
  optional int32 debug_id = 1;
  optional int32 target_node = 2;
  optional int32 to_proc = 3;
  optional int32 to_thread = 4;
  optional int32 reply = 5;
  optional uint32 code = 6;
  optional uint32 flags = 7;
}
message BinderTransactionReceivedFtraceEvent {
  optional int32 debug_id = 1;
}
message BinderSetPriorityFtraceEvent {
  optional int32 proc = 1;
  optional int32 thread = 2;
  optional uint32 old_prio = 3;
  optional uint32 new_prio = 4;
  optional uint32 desired_prio = 5;
}
message BinderLockFtraceEvent {
  optional string tag = 1;
}
message BinderLockedFtraceEvent {
  optional string tag = 1;
}
message BinderUnlockFtraceEvent {
  optional string tag = 1;
}
message BinderTransactionAllocBufFtraceEvent {
  optional uint64 data_size = 1;
  optional int32 debug_id = 2;
  optional uint64 offsets_size = 3;
  optional uint64 extra_buffers_size = 4;
}
message BinderCommandFtraceEvent {
  optional uint32 cmd = 1;
}
message BinderReturnFtraceEvent {
  optional uint32 cmd = 1;
}

// End of protos/perfetto/trace/ftrace/binder.proto

// Begin of protos/perfetto/trace/ftrace/block.proto

message BlockRqIssueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockBioBackmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioBounceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 error = 4;
  optional string rwbs = 5;
}
message BlockBioFrontmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioQueueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional string rwbs = 6;
}
message BlockDirtyBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockGetrqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockPlugFtraceEvent {
  optional string comm = 1;
}
message BlockRqAbortFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockRqCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
  optional int32 error = 7;
}
message BlockRqInsertFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockRqRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional uint32 nr_bios = 6;
  optional string rwbs = 7;
}
message BlockRqRequeueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockSleeprqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockSplitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 new_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockTouchBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockUnplugFtraceEvent {
  optional int32 nr_rq = 1;
  optional string comm = 2;
}
message BlockIoStartFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional uint32 ioprio = 5;
  optional string rwbs = 6;
  optional string comm = 7;
  optional string cmd = 8;
}
message BlockIoDoneFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional uint32 ioprio = 5;
  optional string rwbs = 6;
  optional string comm = 7;
  optional string cmd = 8;
}

// End of protos/perfetto/trace/ftrace/block.proto

// Begin of protos/perfetto/trace/ftrace/cgroup.proto

message CgroupAttachTaskFtraceEvent {
  optional int32 dst_root = 1;
  optional int32 dst_id = 2;
  optional int32 pid = 3;
  optional string comm = 4;
  optional string cname = 5;
  optional int32 dst_level = 6;
  optional string dst_path = 7;
}
message CgroupMkdirFtraceEvent {
  optional int32 root = 1;
  optional int32 id = 2;
  optional string cname = 3;
  optional int32 level = 4;
  optional string path = 5;
}
message CgroupRemountFtraceEvent {
  optional int32 root = 1;
  optional uint32 ss_mask = 2;
  optional string name = 3;
}
message CgroupRmdirFtraceEvent {
  optional int32 root = 1;
  optional int32 id = 2;
  optional string cname = 3;
  optional int32 level = 4;
  optional string path = 5;
}
message CgroupTransferTasksFtraceEvent {
  optional int32 dst_root = 1;
  optional int32 dst_id = 2;
  optional int32 pid = 3;
  optional string comm = 4;
  optional string cname = 5;
  optional int32 dst_level = 6;
  optional string dst_path = 7;
}
message CgroupDestroyRootFtraceEvent {
  optional int32 root = 1;
  optional uint32 ss_mask = 2;
  optional string name = 3;
}
message CgroupReleaseFtraceEvent {
  optional int32 root = 1;
  optional int32 id = 2;
  optional string cname = 3;
  optional int32 level = 4;
  optional string path = 5;
}
message CgroupRenameFtraceEvent {
  optional int32 root = 1;
  optional int32 id = 2;
  optional string cname = 3;
  optional int32 level = 4;
  optional string path = 5;
}
message CgroupSetupRootFtraceEvent {
  optional int32 root = 1;
  optional uint32 ss_mask = 2;
  optional string name = 3;
}

// End of protos/perfetto/trace/ftrace/cgroup.proto

// Begin of protos/perfetto/trace/ftrace/clk.proto

message ClkEnableFtraceEvent {
  optional string name = 1;
}
message ClkDisableFtraceEvent {
  optional string name = 1;
}
message ClkSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 rate = 2;
}

// End of protos/perfetto/trace/ftrace/clk.proto

// Begin of protos/perfetto/trace/ftrace/cma.proto

message CmaAllocStartFtraceEvent {
  optional uint32 align = 1;
  optional uint32 count = 2;
  optional string name = 3;
}
message CmaAllocInfoFtraceEvent {
  optional uint32 align = 1;
  optional uint32 count = 2;
  optional uint32 err_iso = 3;
  optional uint32 err_mig = 4;
  optional uint32 err_test = 5;
  optional string name = 6;
  optional uint64 nr_mapped = 7;
  optional uint64 nr_migrated = 8;
  optional uint64 nr_reclaimed = 9;
  optional uint64 pfn = 10;
}
message CmaAllocFinishFtraceEvent {
  optional string name = 1;
  optional uint64 pfn = 2;
  optional uint64 page = 3;
  optional uint64 count = 4;
  optional uint32 align = 5;
  optional int32 errorno = 6;
}

// End of protos/perfetto/trace/ftrace/cma.proto

// Begin of protos/perfetto/trace/ftrace/compaction.proto

message MmCompactionBeginFtraceEvent {
  optional uint64 zone_start = 1;
  optional uint64 migrate_pfn = 2;
  optional uint64 free_pfn = 3;
  optional uint64 zone_end = 4;
  optional uint32 sync = 5;
}
message MmCompactionDeferCompactionFtraceEvent {
  optional int32 nid = 1;
  optional uint32 idx = 2;
  optional int32 order = 3;
  optional uint32 considered = 4;
  optional uint32 defer_shift = 5;
  optional int32 order_failed = 6;
}
message MmCompactionDeferredFtraceEvent {
  optional int32 nid = 1;
  optional uint32 idx = 2;
  optional int32 order = 3;
  optional uint32 considered = 4;
  optional uint32 defer_shift = 5;
  optional int32 order_failed = 6;
}
message MmCompactionDeferResetFtraceEvent {
  optional int32 nid = 1;
  optional uint32 idx = 2;
  optional int32 order = 3;
  optional uint32 considered = 4;
  optional uint32 defer_shift = 5;
  optional int32 order_failed = 6;
}
message MmCompactionEndFtraceEvent {
  optional uint64 zone_start = 1;
  optional uint64 migrate_pfn = 2;
  optional uint64 free_pfn = 3;
  optional uint64 zone_end = 4;
  optional uint32 sync = 5;
  optional int32 status = 6;
}
message MmCompactionFinishedFtraceEvent {
  optional int32 nid = 1;
  optional uint32 idx = 2;
  optional int32 order = 3;
  optional int32 ret = 4;
}
message MmCompactionIsolateFreepagesFtraceEvent {
  optional uint64 start_pfn = 1;
  optional uint64 end_pfn = 2;
  optional uint64 nr_scanned = 3;
  optional uint64 nr_taken = 4;
}
message MmCompactionIsolateMigratepagesFtraceEvent {
  optional uint64 start_pfn = 1;
  optional uint64 end_pfn = 2;
  optional uint64 nr_scanned = 3;
  optional uint64 nr_taken = 4;
}
message MmCompactionKcompactdSleepFtraceEvent {
  optional int32 nid = 1;
}
message MmCompactionKcompactdWakeFtraceEvent {
  optional int32 nid = 1;
  optional int32 order = 2;
  optional uint32 classzone_idx = 3;
  optional uint32 highest_zoneidx = 4;
}
message MmCompactionMigratepagesFtraceEvent {
  optional uint64 nr_migrated = 1;
  optional uint64 nr_failed = 2;
}
message MmCompactionSuitableFtraceEvent {
  optional int32 nid = 1;
  optional uint32 idx = 2;
  optional int32 order = 3;
  optional int32 ret = 4;
}
message MmCompactionTryToCompactPagesFtraceEvent {
  optional int32 order = 1;
  optional uint32 gfp_mask = 2;
  optional uint32 mode = 3;
  optional int32 prio = 4;
}
message MmCompactionWakeupKcompactdFtraceEvent {
  optional int32 nid = 1;
  optional int32 order = 2;
  optional uint32 classzone_idx = 3;
  optional uint32 highest_zoneidx = 4;
}

// End of protos/perfetto/trace/ftrace/compaction.proto

// Begin of protos/perfetto/trace/ftrace/cpm_trace.proto

message ParamSetValueCpmFtraceEvent {
  optional string body = 1;
  optional uint32 value = 2;
  optional int64 timestamp = 3;
}

// End of protos/perfetto/trace/ftrace/cpm_trace.proto

// Begin of protos/perfetto/trace/ftrace/cpuhp.proto

message CpuhpExitFtraceEvent {
  optional uint32 cpu = 1;
  optional int32 idx = 2;
  optional int32 ret = 3;
  optional int32 state = 4;
}
message CpuhpMultiEnterFtraceEvent {
  optional uint32 cpu = 1;
  optional uint64 fun = 2;
  optional int32 idx = 3;
  optional int32 target = 4;
}
message CpuhpEnterFtraceEvent {
  optional uint32 cpu = 1;
  optional uint64 fun = 2;
  optional int32 idx = 3;
  optional int32 target = 4;
}
message CpuhpLatencyFtraceEvent {
  optional uint32 cpu = 1;
  optional int32 ret = 2;
  optional uint32 state = 3;
  optional uint64 time = 4;
}
message CpuhpPauseFtraceEvent {
  optional uint32 active_cpus = 1;
  optional uint32 cpus = 2;
  optional uint32 pause = 3;
  optional uint32 time = 4;
}

// End of protos/perfetto/trace/ftrace/cpuhp.proto

// Begin of protos/perfetto/trace/ftrace/cros_ec.proto

message CrosEcSensorhubDataFtraceEvent {
  optional int64 current_time = 1;
  optional int64 current_timestamp = 2;
  optional int64 delta = 3;
  optional uint32 ec_fifo_timestamp = 4;
  optional uint32 ec_sensor_num = 5;
  optional int64 fifo_timestamp = 6;
}

// End of protos/perfetto/trace/ftrace/cros_ec.proto

// Begin of protos/perfetto/trace/ftrace/dcvsh.proto

message DcvshFreqFtraceEvent {
  optional uint64 cpu = 1;
  optional uint64 freq = 2;
}

// End of protos/perfetto/trace/ftrace/dcvsh.proto

// Begin of protos/perfetto/trace/ftrace/devfreq.proto

message DevfreqFrequencyFtraceEvent {
  optional string dev_name = 1;
  optional uint64 freq = 2;
  optional uint64 prev_freq = 3;
  optional uint64 busy_time = 4;
  optional uint64 total_time = 5;
}

// End of protos/perfetto/trace/ftrace/devfreq.proto

// Begin of protos/perfetto/trace/ftrace/dma_fence.proto

message DmaFenceInitFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message DmaFenceEmitFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message DmaFenceSignaledFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message DmaFenceWaitStartFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message DmaFenceWaitEndFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}

// End of protos/perfetto/trace/ftrace/dma_fence.proto

// Begin of protos/perfetto/trace/ftrace/dmabuf_heap.proto

message DmaHeapStatFtraceEvent {
  optional uint64 inode = 1;
  optional int64 len = 2;
  optional uint64 total_allocated = 3;
}

// End of protos/perfetto/trace/ftrace/dmabuf_heap.proto

// Begin of protos/perfetto/trace/ftrace/dpu.proto

message DpuTracingMarkWriteFtraceEvent {
  optional int32 pid = 1;
  optional string trace_name = 2;
  optional uint32 trace_begin = 3;
  optional string name = 4;
  optional uint32 type = 5;
  optional int32 value = 6;
}
message DpuDsiCmdFifoStatusFtraceEvent {
  optional uint32 header = 1;
  optional uint32 payload = 2;
}
message DpuDsiRxFtraceEvent {
  optional uint32 cmd = 1;
  optional uint32 rx_buf = 2;
}
message DpuDsiTxFtraceEvent {
  optional uint32 type = 1;
  optional uint32 tx_buf = 2;
  optional uint32 last = 3;
  optional uint32 delay_ms = 4;
}
message DpuDispDpuUnderrunFtraceEvent {
  optional int32 id = 1;
  optional int32 frames_pending = 2;
  optional int32 vsync_count = 3;
}
message DpuDispVblankIrqEnableFtraceEvent {
  optional int32 id = 1;
  optional int32 output_id = 2;
  optional int32 enable = 3;
}

// End of protos/perfetto/trace/ftrace/dpu.proto

// Begin of protos/perfetto/trace/ftrace/drm.proto

message DrmVblankEventFtraceEvent {
  optional int32 crtc = 1;
  optional uint32 high_prec = 2;
  optional uint32 seq = 3;
  optional int64 time = 4;
}
message DrmVblankEventDeliveredFtraceEvent {
  optional int32 crtc = 1;
  optional uint64 file = 2;
  optional uint32 seq = 3;
}

// End of protos/perfetto/trace/ftrace/drm.proto

// Begin of protos/perfetto/trace/ftrace/dwc3.proto

message Dwc3AllocRequestFtraceEvent {
  optional string name = 1;
  optional uint64 req = 2;
  optional uint32 actual = 3;
  optional uint32 length = 4;
  optional int32 status = 5;
  optional int32 zero = 6;
  optional int32 short_not_ok = 7;
  optional int32 no_interrupt = 8;
}
message Dwc3CompleteTrbFtraceEvent {
  optional string name = 1;
  optional uint64 trb = 2;
  optional uint32 allocated = 3;
  optional uint32 queued = 4;
  optional uint32 bpl = 5;
  optional uint32 bph = 6;
  optional uint32 size = 7;
  optional uint32 ctrl = 8;
  optional uint32 type = 9;
  optional uint32 enqueue = 10;
  optional uint32 dequeue = 11;
}
message Dwc3CtrlReqFtraceEvent {
  optional uint32 bRequestType = 1;
  optional uint32 bRequest = 2;
  optional uint32 wValue = 3;
  optional uint32 wIndex = 4;
  optional uint32 wLength = 5;
  optional string str = 6;
}
message Dwc3EpDequeueFtraceEvent {
  optional string name = 1;
  optional uint64 req = 2;
  optional uint32 actual = 3;
  optional uint32 length = 4;
  optional int32 status = 5;
  optional int32 zero = 6;
  optional int32 short_not_ok = 7;
  optional int32 no_interrupt = 8;
}
message Dwc3EpQueueFtraceEvent {
  optional string name = 1;
  optional uint64 req = 2;
  optional uint32 actual = 3;
  optional uint32 length = 4;
  optional int32 status = 5;
  optional int32 zero = 6;
  optional int32 short_not_ok = 7;
  optional int32 no_interrupt = 8;
}
message Dwc3EventFtraceEvent {
  optional uint32 event = 1;
  optional uint32 ep0state = 2;
  optional string str = 3;
}
message Dwc3FreeRequestFtraceEvent {
  optional string name = 1;
  optional uint64 req = 2;
  optional uint32 actual = 3;
  optional uint32 length = 4;
  optional int32 status = 5;
  optional int32 zero = 6;
  optional int32 short_not_ok = 7;
  optional int32 no_interrupt = 8;
}
message Dwc3GadgetEpCmdFtraceEvent {
  optional string name = 1;
  optional uint32 cmd = 2;
  optional uint32 param0 = 3;
  optional uint32 param1 = 4;
  optional uint32 param2 = 5;
  optional int32 cmd_status = 6;
}
message Dwc3GadgetEpDisableFtraceEvent {
  optional string name = 1;
  optional uint32 maxpacket = 2;
  optional uint32 maxpacket_limit = 3;
  optional uint32 max_streams = 4;
  optional uint32 maxburst = 5;
  optional uint32 flags = 6;
  optional uint32 direction = 7;
  optional uint32 trb_enqueue = 8;
  optional uint32 trb_dequeue = 9;
}
message Dwc3GadgetEpEnableFtraceEvent {
  optional string name = 1;
  optional uint32 maxpacket = 2;
  optional uint32 maxpacket_limit = 3;
  optional uint32 max_streams = 4;
  optional uint32 maxburst = 5;
  optional uint32 flags = 6;
  optional uint32 direction = 7;
  optional uint32 trb_enqueue = 8;
  optional uint32 trb_dequeue = 9;
}
message Dwc3GadgetGenericCmdFtraceEvent {
  optional uint32 cmd = 1;
  optional uint32 param = 2;
  optional int32 status = 3;
}
message Dwc3GadgetGivebackFtraceEvent {
  optional string name = 1;
  optional uint64 req = 2;
  optional uint32 actual = 3;
  optional uint32 length = 4;
  optional int32 status = 5;
  optional int32 zero = 6;
  optional int32 short_not_ok = 7;
  optional int32 no_interrupt = 8;
}
message Dwc3PrepareTrbFtraceEvent {
  optional string name = 1;
  optional uint64 trb = 2;
  optional uint32 allocated = 3;
  optional uint32 queued = 4;
  optional uint32 bpl = 5;
  optional uint32 bph = 6;
  optional uint32 size = 7;
  optional uint32 ctrl = 8;
  optional uint32 type = 9;
  optional uint32 enqueue = 10;
  optional uint32 dequeue = 11;
}
message Dwc3ReadlFtraceEvent {
  optional uint64 base = 1;
  optional uint32 offset = 2;
  optional uint32 value = 3;
  optional string msg = 4;
}
message Dwc3WritelFtraceEvent {
  optional uint64 base = 1;
  optional uint32 offset = 2;
  optional uint32 value = 3;
  optional string msg = 4;
}

// End of protos/perfetto/trace/ftrace/dwc3.proto

// Begin of protos/perfetto/trace/ftrace/ext4.proto

message Ext4DaWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DaWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4SyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int32 datasync = 4;
}
message Ext4SyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4AllocDaBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 data_blocks = 3;
  optional uint32 meta_blocks = 4;
}
message Ext4AllocateBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 len = 4;
  optional uint32 logical = 5;
  optional uint32 lleft = 6;
  optional uint32 lright = 7;
  optional uint64 goal = 8;
  optional uint64 pleft = 9;
  optional uint64 pright = 10;
  optional uint32 flags = 11;
}
message Ext4AllocateInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 dir = 3;
  optional uint32 mode = 4;
}
message Ext4BeginOrderedTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 new_size = 3;
}
message Ext4CollapseRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4DaReleaseSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 freed_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional uint32 mode = 8;
}
message Ext4DaReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 reserved_data_blocks = 4;
  optional int32 reserved_meta_blocks = 5;
  optional uint32 mode = 6;
  optional int32 md_needed = 7;
}
message Ext4DaUpdateReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 used_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional int32 quota_claim = 8;
  optional uint32 mode = 9;
}
message Ext4DaWritePagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 first_page = 3;
  optional int64 nr_to_write = 4;
  optional int32 sync_mode = 5;
  optional uint64 b_blocknr = 6;
  optional uint32 b_size = 7;
  optional uint32 b_state = 8;
  optional int32 io_done = 9;
  optional int32 pages_written = 10;
}
message Ext4DaWritePagesExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DirectIOEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
}
message Ext4DirectIOExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
  optional int32 ret = 6;
}
message Ext4DiscardBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 blk = 2;
  optional uint64 count = 3;
}
message Ext4DiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 len = 3;
  optional uint32 needed = 4;
}
message Ext4DropInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 drop = 3;
}
message Ext4EsCacheExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint32 status = 6;
}
message Ext4EsFindDelayedExtentRangeEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsFindDelayedExtentRangeExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsInsertExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsLookupExtentEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsLookupExtentExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
  optional int32 found = 7;
}
message Ext4EsRemoveExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 lblk = 3;
  optional int64 len = 4;
}
message Ext4EsShrinkFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional uint64 scan_time = 3;
  optional int32 nr_skipped = 4;
  optional int32 retried = 5;
}
message Ext4EsShrinkCountFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanEnterFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanExitFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 nlink = 3;
}
message Ext4ExtConvertToInitializedEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
}
message Ext4ExtConvertToInitializedFastpathFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
  optional uint32 i_lblk = 8;
  optional uint32 i_len = 9;
  optional uint64 i_pblk = 10;
}
message Ext4ExtHandleUnwrittenExtentsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 flags = 3;
  optional uint32 lblk = 4;
  optional uint64 pblk = 5;
  optional uint32 len = 6;
  optional uint32 allocated = 7;
  optional uint64 newblk = 8;
}
message Ext4ExtInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional int32 ret = 4;
}
message Ext4ExtLoadExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
}
message Ext4ExtMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4ExtMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4ExtPutInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 start = 5;
}
message Ext4ExtRemoveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
}
message Ext4ExtRemoveSpaceDoneFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
  optional int64 partial = 6;
  optional uint32 eh_entries = 7;
  optional uint32 pc_lblk = 8;
  optional uint64 pc_pclu = 9;
  optional int32 pc_state = 10;
}
message Ext4ExtRmIdxFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
}
message Ext4ExtRmLeafFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 partial = 3;
  optional uint32 start = 4;
  optional uint32 ee_lblk = 5;
  optional uint64 ee_pblk = 6;
  optional int32 ee_len = 7;
  optional uint32 pc_lblk = 8;
  optional uint64 pc_pclu = 9;
  optional int32 pc_state = 10;
}
message Ext4ExtShowExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
  optional uint32 len = 5;
}
message Ext4FallocateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
  optional int64 pos = 6;
}
message Ext4FallocateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 blocks = 4;
  optional int32 ret = 5;
}
message Ext4FindDelallocRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int32 reverse = 5;
  optional int32 found = 6;
  optional uint32 found_blk = 7;
}
message Ext4ForgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional int32 is_metadata = 4;
  optional uint32 mode = 5;
}
message Ext4FreeBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint64 count = 4;
  optional int32 flags = 5;
  optional uint32 mode = 6;
}
message Ext4FreeInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 uid = 3;
  optional uint32 gid = 4;
  optional uint64 blocks = 5;
  optional uint32 mode = 6;
}
message Ext4GetImpliedClusterAllocExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 flags = 2;
  optional uint32 lblk = 3;
  optional uint64 pblk = 4;
  optional uint32 len = 5;
  optional int32 ret = 6;
}
message Ext4GetReservedClusterAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
}
message Ext4IndMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4IndMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4InsertRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4InvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalStartFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
  optional int32 rsv_blocks = 4;
  optional int32 nblocks = 5;
  optional int32 revoke_creds = 6;
}
message Ext4JournalStartReservedFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
}
message Ext4JournalledInvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalledWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4LoadInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
}
message Ext4LoadInodeBitmapFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MarkInodeDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 ip = 3;
}
message Ext4MbBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbBuddyBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbDiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 needed = 2;
}
message Ext4MbNewGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbNewInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbReleaseGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 pa_pstart = 2;
  optional uint32 pa_len = 3;
}
message Ext4MbReleaseInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 count = 4;
}
message Ext4MballocAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 goal_logical = 7;
  optional int32 goal_start = 8;
  optional uint32 goal_group = 9;
  optional int32 goal_len = 10;
  optional uint32 result_logical = 11;
  optional int32 result_start = 12;
  optional uint32 result_group = 13;
  optional int32 result_len = 14;
  optional uint32 found = 15;
  optional uint32 groups = 16;
  optional uint32 buddy = 17;
  optional uint32 flags = 18;
  optional uint32 tail = 19;
  optional uint32 cr = 20;
}
message Ext4MballocDiscardFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocFreeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocPreallocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 result_logical = 7;
  optional int32 result_start = 8;
  optional uint32 result_group = 9;
  optional int32 result_len = 10;
}
message Ext4OtherInodeUpdateTimeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 orig_ino = 3;
  optional uint32 uid = 4;
  optional uint32 gid = 5;
  optional uint32 mode = 6;
}
message Ext4PunchHoleFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}
message Ext4ReadBlockBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
  optional uint32 prefetch = 3;
}
message Ext4ReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4ReleasepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4RemoveBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int64 partial = 5;
  optional uint64 ee_pblk = 6;
  optional uint32 ee_lblk = 7;
  optional uint32 ee_len = 8;
  optional uint32 pc_lblk = 9;
  optional uint64 pc_pclu = 10;
  optional int32 pc_state = 11;
}
message Ext4RequestBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 len = 3;
  optional uint32 logical = 4;
  optional uint32 lleft = 5;
  optional uint32 lright = 6;
  optional uint64 goal = 7;
  optional uint64 pleft = 8;
  optional uint64 pright = 9;
  optional uint32 flags = 10;
}
message Ext4RequestInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 dir = 2;
  optional uint32 mode = 3;
}
message Ext4SyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 wait = 2;
}
message Ext4TrimAllFreeFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TrimExtentFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TruncateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4TruncateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4UnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int64 size = 4;
}
message Ext4UnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4WriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4WriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4WritepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4WritepagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 nr_to_write = 3;
  optional int64 pages_skipped = 4;
  optional int64 range_start = 5;
  optional int64 range_end = 6;
  optional uint64 writeback_index = 7;
  optional int32 sync_mode = 8;
  optional uint32 for_kupdate = 9;
  optional uint32 range_cyclic = 10;
}
message Ext4WritepagesResultFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
  optional int32 pages_written = 4;
  optional int64 pages_skipped = 5;
  optional uint64 writeback_index = 6;
  optional int32 sync_mode = 7;
}
message Ext4ZeroRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}

// End of protos/perfetto/trace/ftrace/ext4.proto

// Begin of protos/perfetto/trace/ftrace/f2fs.proto

message F2fsDoSubmitBioFtraceEvent {
  optional uint64 dev = 1;
  optional int32 btype = 2;
  optional uint32 sync = 3;
  optional uint64 sector = 4;
  optional uint32 size = 5;
}
message F2fsEvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsFallocateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 mode = 3;
  optional int64 offset = 4;
  optional int64 len = 5;
  optional int64 size = 6;
  optional uint64 blocks = 7;
  optional int32 ret = 8;
}
message F2fsGetDataBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 iblock = 3;
  optional uint64 bh_start = 4;
  optional uint64 bh_size = 5;
  optional int32 ret = 6;
}
message F2fsGetVictimFtraceEvent {
  optional uint64 dev = 1;
  optional int32 type = 2;
  optional int32 gc_type = 3;
  optional int32 alloc_mode = 4;
  optional int32 gc_mode = 5;
  optional uint32 victim = 6;
  optional uint32 ofs_unit = 7;
  optional uint32 pre_victim = 8;
  optional uint32 prefree = 9;
  optional uint32 free = 10;
  optional uint32 cost = 11;
}
message F2fsIgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsIgetExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsNewInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 blkaddr = 4;
  optional int32 type = 5;
  optional int32 dir = 6;
  optional int32 dirty = 7;
  optional int32 uptodate = 8;
}
message F2fsReserveNewBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 nid = 2;
  optional uint32 ofs_in_node = 3;
}
message F2fsSetPageDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
  optional int32 uptodate = 7;
}
message F2fsSubmitWritePageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional uint64 index = 4;
  optional uint32 block = 5;
}
message F2fsSyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsSyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 need_cp = 3;
  optional int32 datasync = 4;
  optional int32 ret = 5;
  optional int32 cp_reason = 6;
}
message F2fsSyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 dirty = 2;
  optional int32 wait = 3;
}
message F2fsTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsTruncateBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateDataBlocksRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 ofs = 4;
  optional int32 free = 5;
}
message F2fsTruncateInodeBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateInodeBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateNodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncatePartialNodesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional int32 depth = 4;
  optional int32 err = 5;
}
message F2fsUnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional string name = 5;
}
message F2fsUnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsVmPageMkwriteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
  optional int32 uptodate = 7;
}
message F2fsWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message F2fsWriteCheckpointFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 is_umount = 2;
  optional string msg = 3;
  optional int32 reason = 4;
}
message F2fsWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message F2fsIostatFtraceEvent {
  optional uint64 app_bio = 1;
  optional uint64 app_brio = 2;
  optional uint64 app_dio = 3;
  optional uint64 app_drio = 4;
  optional uint64 app_mio = 5;
  optional uint64 app_mrio = 6;
  optional uint64 app_rio = 7;
  optional uint64 app_wio = 8;
  optional uint64 dev = 9;
  optional uint64 fs_cdrio = 10;
  optional uint64 fs_cp_dio = 11;
  optional uint64 fs_cp_mio = 12;
  optional uint64 fs_cp_nio = 13;
  optional uint64 fs_dio = 14;
  optional uint64 fs_discard = 15;
  optional uint64 fs_drio = 16;
  optional uint64 fs_gc_dio = 17;
  optional uint64 fs_gc_nio = 18;
  optional uint64 fs_gdrio = 19;
  optional uint64 fs_mio = 20;
  optional uint64 fs_mrio = 21;
  optional uint64 fs_nio = 22;
  optional uint64 fs_nrio = 23;
}
message F2fsIostatLatencyFtraceEvent {
  optional uint32 d_rd_avg = 1;
  optional uint32 d_rd_cnt = 2;
  optional uint32 d_rd_peak = 3;
  optional uint32 d_wr_as_avg = 4;
  optional uint32 d_wr_as_cnt = 5;
  optional uint32 d_wr_as_peak = 6;
  optional uint32 d_wr_s_avg = 7;
  optional uint32 d_wr_s_cnt = 8;
  optional uint32 d_wr_s_peak = 9;
  optional uint64 dev = 10;
  optional uint32 m_rd_avg = 11;
  optional uint32 m_rd_cnt = 12;
  optional uint32 m_rd_peak = 13;
  optional uint32 m_wr_as_avg = 14;
  optional uint32 m_wr_as_cnt = 15;
  optional uint32 m_wr_as_peak = 16;
  optional uint32 m_wr_s_avg = 17;
  optional uint32 m_wr_s_cnt = 18;
  optional uint32 m_wr_s_peak = 19;
  optional uint32 n_rd_avg = 20;
  optional uint32 n_rd_cnt = 21;
  optional uint32 n_rd_peak = 22;
  optional uint32 n_wr_as_avg = 23;
  optional uint32 n_wr_as_cnt = 24;
  optional uint32 n_wr_as_peak = 25;
  optional uint32 n_wr_s_avg = 26;
  optional uint32 n_wr_s_cnt = 27;
  optional uint32 n_wr_s_peak = 28;
}
message F2fsBackgroundGcFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 wait_ms = 2;
  optional uint32 prefree = 3;
  optional uint32 free = 4;
}
message F2fsGcBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 sync = 2;
  optional uint32 background = 3;
  optional int64 dirty_nodes = 4;
  optional int64 dirty_dents = 5;
  optional int64 dirty_imeta = 6;
  optional uint32 free_sec = 7;
  optional uint32 free_seg = 8;
  optional int32 reserved_seg = 9;
  optional uint32 prefree_seg = 10;
  optional int32 gc_type = 11;
  optional uint32 no_bg_gc = 12;
  optional uint32 nr_free_secs = 13;
}
message F2fsGcEndFtraceEvent {
  optional uint64 dev = 1;
  optional int32 ret = 2;
  optional int32 seg_freed = 3;
  optional int32 sec_freed = 4;
  optional int64 dirty_nodes = 5;
  optional int64 dirty_dents = 6;
  optional int64 dirty_imeta = 7;
  optional uint32 free_sec = 8;
  optional uint32 free_seg = 9;
  optional int32 reserved_seg = 10;
  optional uint32 prefree_seg = 11;
}

// End of protos/perfetto/trace/ftrace/f2fs.proto

// Begin of protos/perfetto/trace/ftrace/fastrpc.proto

message FastrpcDmaStatFtraceEvent {
  optional int32 cid = 1;
  optional int64 len = 2;
  optional uint64 total_allocated = 3;
}
message FastrpcDmaFreeFtraceEvent {
  optional int32 cid = 1;
  optional uint64 phys = 2;
  optional uint64 size = 3;
}
message FastrpcDmaAllocFtraceEvent {
  optional int32 cid = 1;
  optional uint64 phys = 2;
  optional uint64 size = 3;
  optional uint64 attr = 4;
  optional int32 mflags = 5;
}
message FastrpcDmaUnmapFtraceEvent {
  optional int32 cid = 1;
  optional uint64 phys = 2;
  optional uint64 size = 3;
}
message FastrpcDmaMapFtraceEvent {
  optional int32 cid = 1;
  optional int32 fd = 2;
  optional uint64 phys = 3;
  optional uint64 size = 4;
  optional uint64 len = 5;
  optional uint32 attr = 6;
  optional int32 mflags = 7;
}

// End of protos/perfetto/trace/ftrace/fastrpc.proto

// Begin of protos/perfetto/trace/ftrace/fence.proto

message FenceInitFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message FenceDestroyFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message FenceEnableSignalFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}
message FenceSignaledFtraceEvent {
  optional uint32 context = 1;
  optional string driver = 2;
  optional uint32 seqno = 3;
  optional string timeline = 4;
}

// End of protos/perfetto/trace/ftrace/fence.proto

// Begin of protos/perfetto/trace/ftrace/filemap.proto

message MmFilemapAddToPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}
message MmFilemapDeleteFromPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}

// End of protos/perfetto/trace/ftrace/filemap.proto

// Begin of protos/perfetto/trace/ftrace/fs.proto

message DoSysOpenFtraceEvent {
  optional string filename = 1;
  optional int32 flags = 2;
  optional int32 mode = 3;
}
message OpenExecFtraceEvent {
  optional string filename = 1;
}

// End of protos/perfetto/trace/ftrace/fs.proto

// Begin of protos/perfetto/trace/ftrace/ftrace.proto

message PrintFtraceEvent {
  optional uint64 ip = 1;
  optional string buf = 2;
}
message FuncgraphEntryFtraceEvent {
  optional int32 depth = 1;
  optional uint64 func = 2;
}
message FuncgraphExitFtraceEvent {
  optional uint64 calltime = 1;
  optional int32 depth = 2;
  optional uint64 func = 3;
  optional uint64 overrun = 4;
  optional uint64 rettime = 5;
}

// End of protos/perfetto/trace/ftrace/ftrace.proto

// Begin of protos/perfetto/trace/ftrace/g2d.proto

message G2dTracingMarkWriteFtraceEvent {
  optional int32 pid = 1;
  optional string name = 4;
  optional uint32 type = 5;
  optional int32 value = 6;
}

// End of protos/perfetto/trace/ftrace/g2d.proto

// Begin of protos/perfetto/trace/ftrace/generic.proto

// This generic proto is used to output events in the trace
// when a specific proto for that event does not exist.
message GenericFtraceEvent {
  message Field {
    optional string name = 1;
    oneof value {
      string str_value = 3;
      int64 int_value = 4;
      uint64 uint_value = 5;
    }
  }

  optional string event_name = 1;
  repeated Field field = 2;
}

message KprobeEvent {
  enum KprobeType {
    KPROBE_TYPE_UNKNOWN = 0;
    KPROBE_TYPE_BEGIN = 1;
    KPROBE_TYPE_END = 2;
    KPROBE_TYPE_INSTANT = 3;
  }
  optional string name = 1;
  optional KprobeType type = 2;
}

// End of protos/perfetto/trace/ftrace/generic.proto

// Begin of protos/perfetto/trace/ftrace/google_icc_trace.proto

message GoogleIccEventFtraceEvent {
  optional string event = 1;
  optional uint64 timestamp = 2;
}

// End of protos/perfetto/trace/ftrace/google_icc_trace.proto

// Begin of protos/perfetto/trace/ftrace/google_irm_trace.proto

message GoogleIrmEventFtraceEvent {
  optional string event = 1;
  optional uint64 timestamp = 2;
}

// End of protos/perfetto/trace/ftrace/google_irm_trace.proto

// Begin of protos/perfetto/trace/ftrace/gpu_mem.proto

message GpuMemTotalFtraceEvent {
  optional uint32 gpu_id = 1;
  optional uint32 pid = 2;
  optional uint64 size = 3;
}

// End of protos/perfetto/trace/ftrace/gpu_mem.proto

// Begin of protos/perfetto/trace/ftrace/gpu_scheduler.proto

message DrmSchedJobFtraceEvent {
  optional uint64 entity = 1;
  optional uint64 fence = 2;
  optional int32 hw_job_count = 3;
  optional uint64 id = 4;
  optional uint32 job_count = 5;
  optional string name = 6;
}
message DrmRunJobFtraceEvent {
  optional uint64 entity = 1;
  optional uint64 fence = 2;
  optional int32 hw_job_count = 3;
  optional uint64 id = 4;
  optional uint32 job_count = 5;
  optional string name = 6;
}
message DrmSchedProcessJobFtraceEvent {
  optional uint64 fence = 1;
}
message DrmSchedJobAddDepFtraceEvent {
  optional uint64 fence_context = 1;
  optional uint64 fence_seqno = 2;
  optional uint64 ctx = 3;
  optional uint64 seqno = 4;
}
message DrmSchedJobDoneFtraceEvent {
  optional uint64 fence_context = 1;
  optional uint64 fence_seqno = 2;
}
message DrmSchedJobQueueFtraceEvent {
  optional string name = 1;
  optional uint32 job_count = 2;
  optional int32 hw_job_count = 3;
  optional string dev = 4;
  optional uint64 fence_context = 5;
  optional uint64 fence_seqno = 6;
  optional uint64 client_id = 7;
}
message DrmSchedJobRunFtraceEvent {
  optional string name = 1;
  optional uint32 job_count = 2;
  optional int32 hw_job_count = 3;
  optional string dev = 4;
  optional uint64 fence_context = 5;
  optional uint64 fence_seqno = 6;
  optional uint64 client_id = 7;
}
message DrmSchedJobUnschedulableFtraceEvent {
  optional uint64 fence_context = 1;
  optional uint64 fence_seqno = 2;
  optional uint64 ctx = 3;
  optional uint64 seqno = 4;
}

// End of protos/perfetto/trace/ftrace/gpu_scheduler.proto

// Begin of protos/perfetto/trace/ftrace/hyp.proto

message HypEnterFtraceEvent {}
message HypExitFtraceEvent {}
message HostHcallFtraceEvent {
  optional uint32 id = 1;
  optional uint32 invalid = 2;
}
message HostSmcFtraceEvent {
  optional uint64 id = 1;
  optional uint32 forwarded = 2;
}
message HostMemAbortFtraceEvent {
  optional uint64 esr = 1;
  optional uint64 addr = 2;
}
message HostFfaCallFtraceEvent {
  optional uint64 func_id = 1;
  optional uint64 res_a1 = 2;
  optional uint64 res_a2 = 3;
  optional uint64 res_a3 = 4;
  optional uint64 res_a4 = 5;
  optional int32 handled = 6;
  optional int32 err = 7;
}
message IommuIdmapFtraceEvent {
  optional uint64 from = 1;
  optional uint64 to = 2;
  optional int32 prot = 3;
}
message PsciMemProtectFtraceEvent {
  optional uint64 count = 1;
  optional uint64 was = 2;
}

// End of protos/perfetto/trace/ftrace/hyp.proto

// Begin of protos/perfetto/trace/ftrace/hypervisor.proto

message HypervisorHostHcallFtraceEvent {
  optional uint32 id = 1;
  optional uint32 invalid = 2;
}
message HypervisorHostSmcFtraceEvent {
  optional uint64 id = 1;
  optional uint32 forwarded = 2;
}
message HypervisorHypExitFtraceEvent {}
message HypervisorIommuIdmapFtraceEvent {
  optional uint64 from = 1;
  optional uint64 to = 2;
  optional int32 prot = 3;
}
message HypervisorPsciMemProtectFtraceEvent {
  optional uint64 count = 1;
  optional uint64 was = 2;
}
message HypervisorHostMemAbortFtraceEvent {
  optional uint64 esr = 1;
  optional uint64 addr = 2;
}
message HypervisorHypEnterFtraceEvent {}
message HypervisorIommuIdmapCompleteFtraceEvent {
  optional uint32 map = 1;
}
message HypervisorVcpuIllegalTrapFtraceEvent {
  optional uint64 esr = 1;
}

// End of protos/perfetto/trace/ftrace/hypervisor.proto

// Begin of protos/perfetto/trace/ftrace/i2c.proto

message I2cReadFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 msg_nr = 2;
  optional uint32 addr = 3;
  optional uint32 flags = 4;
  optional uint32 len = 5;
}
message I2cWriteFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 msg_nr = 2;
  optional uint32 addr = 3;
  optional uint32 flags = 4;
  optional uint32 len = 5;
  optional uint32 buf = 6;
}
message I2cResultFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 nr_msgs = 2;
  optional int32 ret = 3;
}
message I2cReplyFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 msg_nr = 2;
  optional uint32 addr = 3;
  optional uint32 flags = 4;
  optional uint32 len = 5;
  optional uint32 buf = 6;
}
message SmbusReadFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 flags = 2;
  optional uint32 addr = 3;
  optional uint32 command = 4;
  optional uint32 protocol = 5;
}
message SmbusWriteFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 addr = 2;
  optional uint32 flags = 3;
  optional uint32 command = 4;
  optional uint32 len = 5;
  optional uint32 protocol = 6;
}
message SmbusResultFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 addr = 2;
  optional uint32 flags = 3;
  optional uint32 read_write = 4;
  optional uint32 command = 5;
  optional int32 res = 6;
  optional uint32 protocol = 7;
}
message SmbusReplyFtraceEvent {
  optional int32 adapter_nr = 1;
  optional uint32 addr = 2;
  optional uint32 flags = 3;
  optional uint32 command = 4;
  optional uint32 len = 5;
  optional uint32 protocol = 6;
}

// End of protos/perfetto/trace/ftrace/i2c.proto

// Begin of protos/perfetto/trace/ftrace/ion.proto

message IonStatFtraceEvent {
  optional uint32 buffer_id = 1;
  optional int64 len = 2;
  optional uint64 total_allocated = 3;
}

// End of protos/perfetto/trace/ftrace/ion.proto

// Begin of protos/perfetto/trace/ftrace/ipi.proto

message IpiEntryFtraceEvent {
  optional string reason = 1;
}
message IpiExitFtraceEvent {
  optional string reason = 1;
}
message IpiRaiseFtraceEvent {
  optional uint32 target_cpus = 1;
  optional string reason = 2;
}

// End of protos/perfetto/trace/ftrace/ipi.proto

// Begin of protos/perfetto/trace/ftrace/irq.proto

message SoftirqEntryFtraceEvent {
  optional uint32 vec = 1;
}
message SoftirqExitFtraceEvent {
  optional uint32 vec = 1;
}
message SoftirqRaiseFtraceEvent {
  optional uint32 vec = 1;
}
message IrqHandlerEntryFtraceEvent {
  optional int32 irq = 1;
  optional string name = 2;
  optional uint32 handler = 3;
}
message IrqHandlerExitFtraceEvent {
  optional int32 irq = 1;
  optional int32 ret = 2;
}

// End of protos/perfetto/trace/ftrace/irq.proto

// Begin of protos/perfetto/trace/ftrace/irq_vectors.proto

message LocalTimerEntryFtraceEvent {
  optional int32 vector = 1;
}
message LocalTimerExitFtraceEvent {
  optional int32 vector = 1;
}

// End of protos/perfetto/trace/ftrace/irq_vectors.proto

// Begin of protos/perfetto/trace/ftrace/kgsl.proto

message KgslGpuFrequencyFtraceEvent {
  optional uint32 gpu_freq = 1;
  optional uint32 gpu_id = 2;
}
message KgslAdrenoCmdbatchQueuedFtraceEvent {
  optional uint32 id = 1;
  optional uint32 timestamp = 2;
  optional uint32 queued = 3;
  optional uint32 flags = 4;
  optional uint32 prio = 5;
}
message KgslAdrenoCmdbatchSubmittedFtraceEvent {
  optional uint32 id = 1;
  optional uint32 timestamp = 2;
  optional int64 inflight = 3;
  optional uint32 flags = 4;
  optional uint64 ticks = 5;
  optional uint64 secs = 6;
  optional uint64 usecs = 7;
  optional int32 prio = 8;
  optional int32 rb_id = 9;
  optional uint32 rptr = 10;
  optional uint32 wptr = 11;
  optional int32 q_inflight = 12;
  optional int32 dispatch_queue = 13;
}
message KgslAdrenoCmdbatchSyncFtraceEvent {
  optional uint32 id = 1;
  optional uint32 timestamp = 2;
  optional uint64 ticks = 3;
  optional int32 prio = 4;
}
message KgslAdrenoCmdbatchRetiredFtraceEvent {
  optional uint32 id = 1;
  optional uint32 timestamp = 2;
  optional int64 inflight = 3;
  optional uint32 recovery = 4;
  optional uint32 flags = 5;
  optional uint64 start = 6;
  optional uint64 retire = 7;
  optional int32 prio = 8;
  optional int32 rb_id = 9;
  optional uint32 rptr = 10;
  optional uint32 wptr = 11;
  optional int32 q_inflight = 12;
  optional uint64 fault_recovery = 13;
  optional uint32 dispatch_queue = 14;
  optional uint64 submitted_to_rb = 15;
  optional uint64 retired_on_gmu = 16;
  optional uint64 active = 17;
}

// End of protos/perfetto/trace/ftrace/kgsl.proto

// Begin of protos/perfetto/trace/ftrace/kmem.proto

message AllocPagesIommuEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message DmaAllocContiguousRetryFtraceEvent {
  optional int32 tries = 1;
}
message IommuMapRangeFtraceEvent {
  optional uint64 chunk_size = 1;
  optional uint64 len = 2;
  optional uint64 pa = 3;
  optional uint64 va = 4;
}
message IommuSecPtblMapRangeEndFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IommuSecPtblMapRangeStartFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IonAllocBufferEndFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonAllocBufferFailFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferFallbackFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferStartFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonCpAllocRetryFtraceEvent {
  optional int32 tries = 1;
}
message IonCpSecureBufferEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonCpSecureBufferStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonPrefetchingFtraceEvent {
  optional uint64 len = 1;
}
message IonSecureCmaAddToPoolEndFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAddToPoolStartFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAllocateEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaAllocateStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaShrinkPoolEndFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message IonSecureCmaShrinkPoolStartFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message KfreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message KmallocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmallocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheAllocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmemCacheAllocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheFreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message MigratePagesEndFtraceEvent {
  optional int32 mode = 1;
}
message MigratePagesStartFtraceEvent {
  optional int32 mode = 1;
}
message MigrateRetryFtraceEvent {
  optional int32 tries = 1;
}
message MmPageAllocFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional int32 migratetype = 2;
  optional uint32 order = 3;
  optional uint64 page = 4;
  optional uint64 pfn = 5;
}
message MmPageAllocExtfragFtraceEvent {
  optional int32 alloc_migratetype = 1;
  optional int32 alloc_order = 2;
  optional int32 fallback_migratetype = 3;
  optional int32 fallback_order = 4;
  optional uint64 page = 5;
  optional int32 change_ownership = 6;
  optional uint64 pfn = 7;
}
message MmPageAllocZoneLockedFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message MmPageFreeFtraceEvent {
  optional uint32 order = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPageFreeBatchedFtraceEvent {
  optional int32 cold = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPagePcpuDrainFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message RssStatFtraceEvent {
  optional int32 member = 1;
  optional int64 size = 2;
  optional uint32 curr = 3;
  optional uint32 mm_id = 4;
}
message IonHeapShrinkFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}
message IonHeapGrowFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}
message IonBufferCreateFtraceEvent {
  optional uint64 addr = 1;
  optional uint64 len = 2;
}
message IonBufferDestroyFtraceEvent {
  optional uint64 addr = 1;
  optional uint64 len = 2;
}
message MmAllocContigMigrateRangeInfoFtraceEvent {
  optional uint64 start = 1;
  optional uint64 end = 2;
  optional uint64 nr_migrated = 3;
  optional uint64 nr_reclaimed = 4;
  optional uint64 nr_mapped = 5;
  optional int32 migratetype = 6;
}
message DmabufRssStatFtraceEvent {
  optional uint64 rss = 1;
  optional int64 rss_delta = 2;
  optional uint64 i_ino = 3;
}

// End of protos/perfetto/trace/ftrace/kmem.proto

// Begin of protos/perfetto/trace/ftrace/kvm.proto

message KvmAccessFaultFtraceEvent {
  optional uint64 ipa = 1;
}
message KvmAckIrqFtraceEvent {
  optional uint32 irqchip = 1;
  optional uint32 pin = 2;
}
message KvmAgeHvaFtraceEvent {
  optional uint64 end = 1;
  optional uint64 start = 2;
}
message KvmAgePageFtraceEvent {
  optional uint64 gfn = 1;
  optional uint64 hva = 2;
  optional uint32 level = 3;
  optional uint32 referenced = 4;
}
message KvmArmClearDebugFtraceEvent {
  optional uint32 guest_debug = 1;
}
message KvmArmSetDreg32FtraceEvent {
  optional string name = 1;
  optional uint32 value = 2;
}
message KvmArmSetRegsetFtraceEvent {
  optional int32 len = 1;
  optional string name = 2;
}
message KvmArmSetupDebugFtraceEvent {
  optional uint32 guest_debug = 1;
  optional uint64 vcpu = 2;
}
message KvmEntryFtraceEvent {
  optional uint64 vcpu_pc = 1;
}
message KvmExitFtraceEvent {
  optional uint32 esr_ec = 1;
  optional int32 ret = 2;
  optional uint64 vcpu_pc = 3;
}
message KvmFpuFtraceEvent {
  optional uint32 load = 1;
}
message KvmGetTimerMapFtraceEvent {
  optional int32 direct_ptimer = 1;
  optional int32 direct_vtimer = 2;
  optional int32 emul_ptimer = 3;
  optional uint64 vcpu_id = 4;
}
message KvmGuestFaultFtraceEvent {
  optional uint64 hsr = 1;
  optional uint64 hxfar = 2;
  optional uint64 ipa = 3;
  optional uint64 vcpu_pc = 4;
}
message KvmHandleSysRegFtraceEvent {
  optional uint64 hsr = 1;
}
message KvmHvcArm64FtraceEvent {
  optional uint64 imm = 1;
  optional uint64 r0 = 2;
  optional uint64 vcpu_pc = 3;
}
message KvmIrqLineFtraceEvent {
  optional int32 irq_num = 1;
  optional int32 level = 2;
  optional uint32 type = 3;
  optional int32 vcpu_idx = 4;
}
message KvmMmioFtraceEvent {
  optional uint64 gpa = 1;
  optional uint32 len = 2;
  optional uint32 type = 3;
  optional uint64 val = 4;
}
message KvmMmioEmulateFtraceEvent {
  optional uint64 cpsr = 1;
  optional uint64 instr = 2;
  optional uint64 vcpu_pc = 3;
}
message KvmSetGuestDebugFtraceEvent {
  optional uint32 guest_debug = 1;
  optional uint64 vcpu = 2;
}
message KvmSetIrqFtraceEvent {
  optional uint32 gsi = 1;
  optional int32 irq_source_id = 2;
  optional int32 level = 3;
}
message KvmSetSpteHvaFtraceEvent {
  optional uint64 hva = 1;
}
message KvmSetWayFlushFtraceEvent {
  optional uint32 cache = 1;
  optional uint64 vcpu_pc = 2;
}
message KvmSysAccessFtraceEvent {
  optional uint32 CRm = 1;
  optional uint32 CRn = 2;
  optional uint32 Op0 = 3;
  optional uint32 Op1 = 4;
  optional uint32 Op2 = 5;
  optional uint32 is_write = 6;
  optional string name = 7;
  optional uint64 vcpu_pc = 8;
}
message KvmTestAgeHvaFtraceEvent {
  optional uint64 hva = 1;
}
message KvmTimerEmulateFtraceEvent {
  optional uint32 should_fire = 1;
  optional int32 timer_idx = 2;
}
message KvmTimerHrtimerExpireFtraceEvent {
  optional int32 timer_idx = 1;
}
message KvmTimerRestoreStateFtraceEvent {
  optional uint64 ctl = 1;
  optional uint64 cval = 2;
  optional int32 timer_idx = 3;
}
message KvmTimerSaveStateFtraceEvent {
  optional uint64 ctl = 1;
  optional uint64 cval = 2;
  optional int32 timer_idx = 3;
}
message KvmTimerUpdateIrqFtraceEvent {
  optional uint32 irq = 1;
  optional int32 level = 2;
  optional uint64 vcpu_id = 3;
}
message KvmToggleCacheFtraceEvent {
  optional uint32 now = 1;
  optional uint64 vcpu_pc = 2;
  optional uint32 was = 3;
}
message KvmUnmapHvaRangeFtraceEvent {
  optional uint64 end = 1;
  optional uint64 start = 2;
}
message KvmUserspaceExitFtraceEvent {
  optional uint32 reason = 1;
}
message KvmVcpuWakeupFtraceEvent {
  optional uint64 ns = 1;
  optional uint32 valid = 2;
  optional uint32 waited = 3;
}
message KvmWfxArm64FtraceEvent {
  optional uint32 is_wfe = 1;
  optional uint64 vcpu_pc = 2;
}
message TrapRegFtraceEvent {
  optional string fn = 1;
  optional uint32 is_write = 2;
  optional int32 reg = 3;
  optional uint64 write_value = 4;
}
message VgicUpdateIrqPendingFtraceEvent {
  optional uint32 irq = 1;
  optional uint32 level = 2;
  optional uint64 vcpu_id = 3;
}

// End of protos/perfetto/trace/ftrace/kvm.proto

// Begin of protos/perfetto/trace/ftrace/lowmemorykiller.proto

message LowmemoryKillFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int64 pagecache_size = 3;
  optional int64 pagecache_limit = 4;
  optional int64 free = 5;
}

// End of protos/perfetto/trace/ftrace/lowmemorykiller.proto

// Begin of protos/perfetto/trace/ftrace/lwis.proto

message LwisTracingMarkWriteFtraceEvent {
  optional string lwis_name = 1;
  optional uint32 type = 2;
  optional int32 pid = 3;
  optional string func_name = 4;
  optional int64 value = 5;
}

// End of protos/perfetto/trace/ftrace/lwis.proto

// Begin of protos/perfetto/trace/ftrace/mali.proto

message MaliTracingMarkWriteFtraceEvent {
  optional string name = 1;
  optional int32 pid = 2;
  optional uint32 type = 3;
  optional int32 value = 4;
}
message MaliMaliKCPUCQSSETFtraceEvent {
  optional uint32 id = 1;
  optional uint64 info_val1 = 2;
  optional uint64 info_val2 = 3;
  optional uint32 kctx_id = 4;
  optional int32 kctx_tgid = 5;
}
message MaliMaliKCPUCQSWAITSTARTFtraceEvent {
  optional uint32 id = 1;
  optional uint64 info_val1 = 2;
  optional uint64 info_val2 = 3;
  optional uint32 kctx_id = 4;
  optional int32 kctx_tgid = 5;
}
message MaliMaliKCPUCQSWAITENDFtraceEvent {
  optional uint32 id = 1;
  optional uint64 info_val1 = 2;
  optional uint64 info_val2 = 3;
  optional uint32 kctx_id = 4;
  optional int32 kctx_tgid = 5;
}
message MaliMaliKCPUFENCESIGNALFtraceEvent {
  optional uint64 info_val1 = 1;
  optional uint64 info_val2 = 2;
  optional int32 kctx_tgid = 3;
  optional uint32 kctx_id = 4;
  optional uint32 id = 5;
}
message MaliMaliKCPUFENCEWAITSTARTFtraceEvent {
  optional uint64 info_val1 = 1;
  optional uint64 info_val2 = 2;
  optional int32 kctx_tgid = 3;
  optional uint32 kctx_id = 4;
  optional uint32 id = 5;
}
message MaliMaliKCPUFENCEWAITENDFtraceEvent {
  optional uint64 info_val1 = 1;
  optional uint64 info_val2 = 2;
  optional int32 kctx_tgid = 3;
  optional uint32 kctx_id = 4;
  optional uint32 id = 5;
}
message MaliMaliCSFINTERRUPTSTARTFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliCSFINTERRUPTENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLMCUONRECHECKFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLSHADERSPENDONFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUINSLEEPFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUOFFFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONGLBREINITPENDFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONHALTFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONHWCNTDISABLEFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONHWCNTENABLEFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONPENDHALTFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONPENDSLEEPFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUONSLEEPINITIATEFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUPENDOFFFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUPENDONRELOADFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCUPOWERDOWNFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliMaliPMMCURESETWAITFtraceEvent {
  optional int32 kctx_tgid = 1;
  optional uint32 kctx_id = 2;
  optional uint64 info_val = 3;
}
message MaliGpuPowerStateFtraceEvent {
  optional uint64 change_ns = 1;
  optional int32 from_state = 2;
  optional int32 to_state = 3;
}

// End of protos/perfetto/trace/ftrace/mali.proto

// Begin of protos/perfetto/trace/ftrace/mdss.proto

message MdpCmdKickoffFtraceEvent {
  optional uint32 ctl_num = 1;
  optional int32 kickoff_cnt = 2;
}
message MdpCommitFtraceEvent {
  optional uint32 num = 1;
  optional uint32 play_cnt = 2;
  optional uint32 clk_rate = 3;
  optional uint64 bandwidth = 4;
}
message MdpPerfSetOtFtraceEvent {
  optional uint32 pnum = 1;
  optional uint32 xin_id = 2;
  optional uint32 rd_lim = 3;
  optional uint32 is_vbif_rt = 4;
}
message MdpSsppChangeFtraceEvent {
  optional uint32 num = 1;
  optional uint32 play_cnt = 2;
  optional uint32 mixer = 3;
  optional uint32 stage = 4;
  optional uint32 flags = 5;
  optional uint32 format = 6;
  optional uint32 img_w = 7;
  optional uint32 img_h = 8;
  optional uint32 src_x = 9;
  optional uint32 src_y = 10;
  optional uint32 src_w = 11;
  optional uint32 src_h = 12;
  optional uint32 dst_x = 13;
  optional uint32 dst_y = 14;
  optional uint32 dst_w = 15;
  optional uint32 dst_h = 16;
}
message TracingMarkWriteFtraceEvent {
  optional int32 pid = 1;
  optional string trace_name = 2;
  optional uint32 trace_begin = 3;
}
message MdpCmdPingpongDoneFtraceEvent {
  optional uint32 ctl_num = 1;
  optional uint32 intf_num = 2;
  optional uint32 pp_num = 3;
  optional int32 koff_cnt = 4;
}
message MdpCompareBwFtraceEvent {
  optional uint64 new_ab = 1;
  optional uint64 new_ib = 2;
  optional uint64 new_wb = 3;
  optional uint64 old_ab = 4;
  optional uint64 old_ib = 5;
  optional uint64 old_wb = 6;
  optional uint32 params_changed = 7;
  optional uint32 update_bw = 8;
}
message MdpPerfSetPanicLutsFtraceEvent {
  optional uint32 pnum = 1;
  optional uint32 fmt = 2;
  optional uint32 mode = 3;
  optional uint32 panic_lut = 4;
  optional uint32 robust_lut = 5;
}
message MdpSsppSetFtraceEvent {
  optional uint32 num = 1;
  optional uint32 play_cnt = 2;
  optional uint32 mixer = 3;
  optional uint32 stage = 4;
  optional uint32 flags = 5;
  optional uint32 format = 6;
  optional uint32 img_w = 7;
  optional uint32 img_h = 8;
  optional uint32 src_x = 9;
  optional uint32 src_y = 10;
  optional uint32 src_w = 11;
  optional uint32 src_h = 12;
  optional uint32 dst_x = 13;
  optional uint32 dst_y = 14;
  optional uint32 dst_w = 15;
  optional uint32 dst_h = 16;
}
message MdpCmdReadptrDoneFtraceEvent {
  optional uint32 ctl_num = 1;
  optional int32 koff_cnt = 2;
}
message MdpMisrCrcFtraceEvent {
  optional uint32 block_id = 1;
  optional uint32 vsync_cnt = 2;
  optional uint32 crc = 3;
}
message MdpPerfSetQosLutsFtraceEvent {
  optional uint32 pnum = 1;
  optional uint32 fmt = 2;
  optional uint32 intf = 3;
  optional uint32 rot = 4;
  optional uint32 fl = 5;
  optional uint32 lut = 6;
  optional uint32 linear = 7;
}
message MdpTraceCounterFtraceEvent {
  optional int32 pid = 1;
  optional string counter_name = 2;
  optional int32 value = 3;
}
message MdpCmdReleaseBwFtraceEvent {
  optional uint32 ctl_num = 1;
}
message MdpMixerUpdateFtraceEvent {
  optional uint32 mixer_num = 1;
}
message MdpPerfSetWmLevelsFtraceEvent {
  optional uint32 pnum = 1;
  optional uint32 use_space = 2;
  optional uint32 priority_bytes = 3;
  optional uint32 wm0 = 4;
  optional uint32 wm1 = 5;
  optional uint32 wm2 = 6;
  optional uint32 mb_cnt = 7;
  optional uint32 mb_size = 8;
}
message MdpVideoUnderrunDoneFtraceEvent {
  optional uint32 ctl_num = 1;
  optional uint32 underrun_cnt = 2;
}
message MdpCmdWaitPingpongFtraceEvent {
  optional uint32 ctl_num = 1;
  optional int32 kickoff_cnt = 2;
}
message MdpPerfPrefillCalcFtraceEvent {
  optional uint32 pnum = 1;
  optional uint32 latency_buf = 2;
  optional uint32 ot = 3;
  optional uint32 y_buf = 4;
  optional uint32 y_scaler = 5;
  optional uint32 pp_lines = 6;
  optional uint32 pp_bytes = 7;
  optional uint32 post_sc = 8;
  optional uint32 fbc_bytes = 9;
  optional uint32 prefill_bytes = 10;
}
message MdpPerfUpdateBusFtraceEvent {
  optional int32 client = 1;
  optional uint64 ab_quota = 2;
  optional uint64 ib_quota = 3;
}
message RotatorBwAoAsContextFtraceEvent {
  optional uint32 state = 1;
}

// End of protos/perfetto/trace/ftrace/mdss.proto

// Begin of protos/perfetto/trace/ftrace/mm_event.proto

message MmEventRecordFtraceEvent {
  optional uint32 avg_lat = 1;
  optional uint32 count = 2;
  optional uint32 max_lat = 3;
  optional uint32 type = 4;
}

// End of protos/perfetto/trace/ftrace/mm_event.proto

// Begin of protos/perfetto/trace/ftrace/net.proto

message NetifReceiveSkbFtraceEvent {
  optional uint32 len = 1;
  optional string name = 2;
  optional uint64 skbaddr = 3;
}
message NetDevXmitFtraceEvent {
  optional uint32 len = 1;
  optional string name = 2;
  optional int32 rc = 3;
  optional uint64 skbaddr = 4;
}
message NapiGroReceiveEntryFtraceEvent {
  optional uint32 data_len = 1;
  optional uint32 gso_size = 2;
  optional uint32 gso_type = 3;
  optional uint32 hash = 4;
  optional uint32 ip_summed = 5;
  optional uint32 l4_hash = 6;
  optional uint32 len = 7;
  optional int32 mac_header = 8;
  optional uint32 mac_header_valid = 9;
  optional string name = 10;
  optional uint32 napi_id = 11;
  optional uint32 nr_frags = 12;
  optional uint32 protocol = 13;
  optional uint32 queue_mapping = 14;
  optional uint64 skbaddr = 15;
  optional uint32 truesize = 16;
  optional uint32 vlan_proto = 17;
  optional uint32 vlan_tagged = 18;
  optional uint32 vlan_tci = 19;
}
message NapiGroReceiveExitFtraceEvent {
  optional int32 ret = 1;
}

// End of protos/perfetto/trace/ftrace/net.proto

// Begin of protos/perfetto/trace/ftrace/oom.proto

message OomScoreAdjUpdateFtraceEvent {
  optional string comm = 1;
  optional int32 oom_score_adj = 2;
  optional int32 pid = 3;
}
message MarkVictimFtraceEvent {
  optional int32 pid = 1;
}

// End of protos/perfetto/trace/ftrace/oom.proto

// Begin of protos/perfetto/trace/ftrace/panel.proto

message DsiCmdFifoStatusFtraceEvent {
  optional uint32 header = 1;
  optional uint32 payload = 2;
}
message DsiRxFtraceEvent {
  optional uint32 cmd = 1;
  optional uint32 rx_buf = 2;
}
message DsiTxFtraceEvent {
  optional uint32 last = 1;
  optional uint32 tx_buf = 2;
  optional uint32 type = 3;
}
message PanelWriteGenericFtraceEvent {
  optional int32 pid = 1;
  optional string trace_name = 2;
  optional uint32 trace_begin = 3;
  optional string name = 4;
  optional uint32 type = 5;
  optional int32 value = 6;
}

// End of protos/perfetto/trace/ftrace/panel.proto

// Begin of protos/perfetto/trace/ftrace/perf_trace_counters.proto

message SchedSwitchWithCtrsFtraceEvent {
  optional int32 old_pid = 1;
  optional int32 new_pid = 2;
  optional uint64 cctr = 3;
  optional uint64 ctr0 = 4;
  optional uint64 ctr1 = 5;
  optional uint64 ctr2 = 6;
  optional uint64 ctr3 = 7;
  optional uint32 lctr0 = 8;
  optional uint32 lctr1 = 9;
  optional uint64 ctr4 = 10;
  optional uint64 ctr5 = 11;
  optional string prev_comm = 12;
  optional int32 prev_pid = 13;
  optional uint32 cyc = 14;
  optional uint32 inst = 15;
  optional uint32 stallbm = 16;
  optional uint32 l3dm = 17;
  optional int32 next_pid = 18;
  optional string next_comm = 19;
  optional int64 prev_state = 20;
  optional uint64 amu0 = 21;
  optional uint64 amu1 = 22;
  optional uint64 amu2 = 23;
}

// End of protos/perfetto/trace/ftrace/perf_trace_counters.proto

// Begin of protos/perfetto/trace/ftrace/pixel_mm.proto

message PixelMmKswapdWakeFtraceEvent {
  optional int32 whatever = 1;
}
message PixelMmKswapdDoneFtraceEvent {
  optional uint64 delta_nr_scanned = 1;
  optional uint64 delta_nr_reclaimed = 2;
}

// End of protos/perfetto/trace/ftrace/pixel_mm.proto

// Begin of protos/perfetto/trace/ftrace/power.proto

message CpuFrequencyFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message CpuFrequencyLimitsFtraceEvent {
  optional uint32 min_freq = 1;
  optional uint32 max_freq = 2;
  optional uint32 cpu_id = 3;
}
message CpuIdleFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message ClockEnableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockDisableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message SuspendResumeFtraceEvent {
  optional string action = 1;
  optional int32 val = 2;
  optional uint32 start = 3;
}
message GpuFrequencyFtraceEvent {
  optional uint32 gpu_id = 1;
  optional uint32 state = 2;
}
message WakeupSourceActivateFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
}
message WakeupSourceDeactivateFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
}
message GpuWorkPeriodFtraceEvent {
  optional uint32 gpu_id = 1;
  optional uint32 uid = 2;
  optional uint64 start_time_ns = 3;
  optional uint64 end_time_ns = 4;
  optional uint64 total_active_duration_ns = 5;
}
message DevicePmCallbackStartFtraceEvent {
  optional string device = 1;
  optional string driver = 2;
  optional string parent = 3;
  optional string pm_ops = 4;
  optional int32 event = 5;
}
message DevicePmCallbackEndFtraceEvent {
  optional string device = 1;
  optional string driver = 2;
  optional int32 error = 3;
}

// End of protos/perfetto/trace/ftrace/power.proto

// Begin of protos/perfetto/trace/ftrace/printk.proto

message ConsoleFtraceEvent {
  optional string msg = 1;
}

// End of protos/perfetto/trace/ftrace/printk.proto

// Begin of protos/perfetto/trace/ftrace/raw_syscalls.proto

message SysEnterFtraceEvent {
  optional int64 id = 1;
  repeated uint64 args = 2;
}
message SysExitFtraceEvent {
  optional int64 id = 1;
  optional int64 ret = 2;
}

// End of protos/perfetto/trace/ftrace/raw_syscalls.proto

// Begin of protos/perfetto/trace/ftrace/regulator.proto

message RegulatorDisableFtraceEvent {
  optional string name = 1;
}
message RegulatorDisableCompleteFtraceEvent {
  optional string name = 1;
}
message RegulatorEnableFtraceEvent {
  optional string name = 1;
}
message RegulatorEnableCompleteFtraceEvent {
  optional string name = 1;
}
message RegulatorEnableDelayFtraceEvent {
  optional string name = 1;
}
message RegulatorSetVoltageFtraceEvent {
  optional string name = 1;
  optional int32 min = 2;
  optional int32 max = 3;
}
message RegulatorSetVoltageCompleteFtraceEvent {
  optional string name = 1;
  optional uint32 val = 2;
}

// End of protos/perfetto/trace/ftrace/regulator.proto

// Begin of protos/perfetto/trace/ftrace/rpm.proto

message RpmStatusFtraceEvent {
  optional string name = 1;
  optional int32 status = 2;
}

// End of protos/perfetto/trace/ftrace/rpm.proto

// Begin of protos/perfetto/trace/ftrace/samsung.proto

message SamsungTracingMarkWriteFtraceEvent {
  optional int32 pid = 1;
  optional string trace_name = 2;
  optional uint32 trace_begin = 3;
  optional uint32 trace_type = 4;
  optional int32 value = 5;
}

// End of protos/perfetto/trace/ftrace/samsung.proto

// Begin of protos/perfetto/trace/ftrace/sched.proto

message SchedSwitchFtraceEvent {
  optional string prev_comm = 1;
  optional int32 prev_pid = 2;
  optional int32 prev_prio = 3;
  optional int64 prev_state = 4;
  optional string next_comm = 5;
  optional int32 next_pid = 6;
  optional int32 next_prio = 7;
}
message SchedWakeupFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedBlockedReasonFtraceEvent {
  optional int32 pid = 1;
  optional uint64 caller = 2;
  optional uint32 io_wait = 3;
}
message SchedCpuHotplugFtraceEvent {
  optional int32 affected_cpu = 1;
  optional int32 error = 2;
  optional int32 status = 3;
}
message SchedWakingFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedWakeupNewFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedProcessExecFtraceEvent {
  optional string filename = 1;
  optional int32 pid = 2;
  optional int32 old_pid = 3;
}
message SchedProcessExitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 tgid = 3;
  optional int32 prio = 4;
}
message SchedProcessForkFtraceEvent {
  optional string parent_comm = 1;
  optional int32 parent_pid = 2;
  optional string child_comm = 3;
  optional int32 child_pid = 4;
}
message SchedProcessFreeFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}
message SchedProcessHangFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
}
message SchedProcessWaitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}
message SchedPiSetprioFtraceEvent {
  optional string comm = 1;
  optional int32 newprio = 2;
  optional int32 oldprio = 3;
  optional int32 pid = 4;
}
message SchedCpuUtilCfsFtraceEvent {
  optional int32 active = 1;
  optional uint64 capacity = 2;
  optional uint64 capacity_orig = 3;
  optional uint32 cpu = 4;
  optional uint64 cpu_importance = 5;
  optional uint64 cpu_util = 6;
  optional uint32 exit_lat = 7;
  optional uint64 group_capacity = 8;
  optional uint32 grp_overutilized = 9;
  optional uint32 idle_cpu = 10;
  optional uint32 nr_running = 11;
  optional int64 spare_cap = 12;
  optional uint32 task_fits = 13;
  optional uint64 wake_group_util = 14;
  optional uint64 wake_util = 15;
}
message SchedMigrateTaskFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 orig_cpu = 4;
  optional int32 dest_cpu = 5;
  optional int32 running = 6;
  optional uint32 load = 7;
}
message SchedWakeupTaskAttrFtraceEvent {
  optional int32 pid = 1;
  optional uint64 cpu_affinity = 2;
  optional uint64 task_util = 3;
  optional uint64 uclamp_min = 4;
  optional uint64 vruntime = 5;
}

// End of protos/perfetto/trace/ftrace/sched.proto

// Begin of protos/perfetto/trace/ftrace/scm.proto

message ScmCallStartFtraceEvent {
  optional uint32 arginfo = 1;
  optional uint64 x0 = 2;
  optional uint64 x5 = 3;
}
message ScmCallEndFtraceEvent {}

// End of protos/perfetto/trace/ftrace/scm.proto

// Begin of protos/perfetto/trace/ftrace/sde.proto

message SdeTracingMarkWriteFtraceEvent {
  optional int32 pid = 1;
  optional string trace_name = 2;
  optional uint32 trace_type = 3;
  optional int32 value = 4;
  optional uint32 trace_begin = 5;
}
message SdeSdeEvtlogFtraceEvent {
  optional string evtlog_tag = 1;
  optional int32 pid = 2;
  optional uint32 tag_id = 3;
}
message SdeSdePerfCalcCrtcFtraceEvent {
  optional uint64 bw_ctl_ebi = 1;
  optional uint64 bw_ctl_llcc = 2;
  optional uint64 bw_ctl_mnoc = 3;
  optional uint32 core_clk_rate = 4;
  optional uint32 crtc = 5;
  optional uint64 ib_ebi = 6;
  optional uint64 ib_llcc = 7;
  optional uint64 ib_mnoc = 8;
}
message SdeSdePerfCrtcUpdateFtraceEvent {
  optional uint64 bw_ctl_ebi = 1;
  optional uint64 bw_ctl_llcc = 2;
  optional uint64 bw_ctl_mnoc = 3;
  optional uint32 core_clk_rate = 4;
  optional uint32 crtc = 5;
  optional int32 params = 6;
  optional uint64 per_pipe_ib_ebi = 7;
  optional uint64 per_pipe_ib_llcc = 8;
  optional uint64 per_pipe_ib_mnoc = 9;
  optional uint32 stop_req = 10;
  optional uint32 update_bus = 11;
  optional uint32 update_clk = 12;
}
message SdeSdePerfSetQosLutsFtraceEvent {
  optional uint32 fl = 1;
  optional uint32 fmt = 2;
  optional uint64 lut = 3;
  optional uint32 lut_usage = 4;
  optional uint32 pnum = 5;
  optional uint32 rt = 6;
}
message SdeSdePerfUpdateBusFtraceEvent {
  optional uint64 ab_quota = 1;
  optional uint32 bus_id = 2;
  optional int32 client = 3;
  optional uint64 ib_quota = 4;
}

// End of protos/perfetto/trace/ftrace/sde.proto

// Begin of protos/perfetto/trace/ftrace/signal.proto

message SignalDeliverFtraceEvent {
  optional int32 code = 1;
  optional uint64 sa_flags = 2;
  optional int32 sig = 3;
}
message SignalGenerateFtraceEvent {
  optional int32 code = 1;
  optional string comm = 2;
  optional int32 group = 3;
  optional int32 pid = 4;
  optional int32 result = 5;
  optional int32 sig = 6;
}

// End of protos/perfetto/trace/ftrace/signal.proto

// Begin of protos/perfetto/trace/ftrace/skb.proto

message KfreeSkbFtraceEvent {
  optional uint64 location = 1;
  optional uint32 protocol = 2;
  optional uint64 skbaddr = 3;
}

// End of protos/perfetto/trace/ftrace/skb.proto

// Begin of protos/perfetto/trace/ftrace/sock.proto

message InetSockSetStateFtraceEvent {
  optional uint32 daddr = 1;
  optional uint32 dport = 2;
  optional uint32 family = 3;
  optional int32 newstate = 4;
  optional int32 oldstate = 5;
  optional uint32 protocol = 6;
  optional uint32 saddr = 7;
  optional uint64 skaddr = 8;
  optional uint32 sport = 9;
}

// End of protos/perfetto/trace/ftrace/sock.proto

// Begin of protos/perfetto/trace/ftrace/sync.proto

message SyncPtFtraceEvent {
  optional string timeline = 1;
  optional string value = 2;
}
message SyncTimelineFtraceEvent {
  optional string name = 1;
  optional string value = 2;
}
message SyncWaitFtraceEvent {
  optional string name = 1;
  optional int32 status = 2;
  optional uint32 begin = 3;
}

// End of protos/perfetto/trace/ftrace/sync.proto

// Begin of protos/perfetto/trace/ftrace/synthetic.proto

message RssStatThrottledFtraceEvent {
  optional uint32 curr = 1;
  optional int32 member = 2;
  optional uint32 mm_id = 3;
  optional int64 size = 4;
}
message SuspendResumeMinimalFtraceEvent {
  optional uint32 start = 1;
}

// End of protos/perfetto/trace/ftrace/synthetic.proto

// Begin of protos/perfetto/trace/ftrace/systrace.proto

message ZeroFtraceEvent {
  optional int32 flag = 1;
  optional string name = 2;
  optional int32 pid = 3;
  optional int64 value = 4;
}

// End of protos/perfetto/trace/ftrace/systrace.proto

// Begin of protos/perfetto/trace/ftrace/task.proto

message TaskNewtaskFtraceEvent {
  optional int32 pid = 1;
  optional string comm = 2;
  optional uint64 clone_flags = 3;
  optional int32 oom_score_adj = 4;
}
message TaskRenameFtraceEvent {
  optional int32 pid = 1;
  optional string oldcomm = 2;
  optional string newcomm = 3;
  optional int32 oom_score_adj = 4;
}

// End of protos/perfetto/trace/ftrace/task.proto

// Begin of protos/perfetto/trace/ftrace/tcp.proto

message TcpRetransmitSkbFtraceEvent {
  optional uint32 daddr = 1;
  optional uint32 dport = 2;
  optional uint32 saddr = 3;
  optional uint64 skaddr = 4;
  optional uint64 skbaddr = 5;
  optional uint32 sport = 6;
  optional int32 state = 7;
}

// End of protos/perfetto/trace/ftrace/tcp.proto

// Begin of protos/perfetto/trace/ftrace/thermal.proto

message ThermalTemperatureFtraceEvent {
  optional int32 id = 1;
  optional int32 temp = 2;
  optional int32 temp_prev = 3;
  optional string thermal_zone = 4;
}
message CdevUpdateFtraceEvent {
  optional uint64 target = 1;
  optional string type = 2;
}

// End of protos/perfetto/trace/ftrace/thermal.proto

// Begin of protos/perfetto/trace/ftrace/thermal_exynos.proto

message ThermalExynosAcpmBulkFtraceEvent {
  optional uint32 tz_id = 1;
  optional uint32 current_temp = 2;
  optional uint32 ctrl_temp = 3;
  optional uint32 cdev_state = 4;
  optional int32 pid_et_p = 5;
  optional int32 pid_power_range = 6;
  optional int32 pid_p = 7;
  optional int32 pid_i = 8;
  optional int32 k_p = 9;
  optional int32 k_i = 10;
  optional uint64 timestamp = 11;
}
message ThermalExynosAcpmHighOverheadFtraceEvent {
  optional int32 tz_id = 1;
  optional uint32 current_temp = 2;
  optional uint32 ctrl_temp = 3;
  optional uint32 cdev_state = 4;
  optional int32 pid_et_p = 5;
  optional int32 k_p = 6;
  optional int32 k_i = 7;
}

// End of protos/perfetto/trace/ftrace/thermal_exynos.proto

// Begin of protos/perfetto/trace/ftrace/timer.proto

message HrtimerStartFtraceEvent {
  optional uint64 hrtimer = 1;
  optional uint64 function = 2;
  optional int64 expires = 3;
  optional int64 softexpires = 4;
  optional uint32 mode = 5;
}
message HrtimerCancelFtraceEvent {
  optional uint64 hrtimer = 1;
}
message HrtimerExpireEntryFtraceEvent {
  optional uint64 hrtimer = 1;
  optional int64 now = 2;
  optional uint64 function = 3;
}
message HrtimerExpireExitFtraceEvent {
  optional uint64 hrtimer = 1;
}
message TimerStartFtraceEvent {
  optional uint64 timer = 1;
  optional uint64 function = 2;
  optional uint64 expires = 3;
  optional uint64 now = 4;
  optional uint32 deferrable = 5;
  optional uint32 flags = 6;
  optional uint64 bucket_expiry = 7;
}
message TimerCancelFtraceEvent {
  optional uint64 timer = 1;
}
message TimerExpireEntryFtraceEvent {
  optional uint64 timer = 1;
  optional uint64 now = 2;
  optional uint64 function = 3;
  optional uint64 baseclk = 4;
}
message TimerExpireExitFtraceEvent {
  optional uint64 timer = 1;
}

// End of protos/perfetto/trace/ftrace/timer.proto

// Begin of protos/perfetto/trace/ftrace/trusty.proto

message TrustySmcFtraceEvent {
  optional uint64 r0 = 1;
  optional uint64 r1 = 2;
  optional uint64 r2 = 3;
  optional uint64 r3 = 4;
}
message TrustySmcDoneFtraceEvent {
  optional uint64 ret = 1;
}
message TrustyStdCall32FtraceEvent {
  optional uint64 r0 = 1;
  optional uint64 r1 = 2;
  optional uint64 r2 = 3;
  optional uint64 r3 = 4;
}
message TrustyStdCall32DoneFtraceEvent {
  optional int64 ret = 1;
}
message TrustyShareMemoryFtraceEvent {
  optional uint64 len = 1;
  optional uint32 lend = 2;
  optional uint32 nents = 3;
}
message TrustyShareMemoryDoneFtraceEvent {
  optional uint64 handle = 1;
  optional uint64 len = 2;
  optional uint32 lend = 3;
  optional uint32 nents = 4;
  optional int32 ret = 5;
}
message TrustyReclaimMemoryFtraceEvent {
  optional uint64 id = 1;
}
message TrustyReclaimMemoryDoneFtraceEvent {
  optional uint64 id = 1;
  optional int32 ret = 2;
}
message TrustyIrqFtraceEvent {
  optional int32 irq = 1;
}
message TrustyIpcHandleEventFtraceEvent {
  optional uint32 chan = 1;
  optional uint32 event_id = 2;
  optional string srv_name = 3;
}
message TrustyIpcConnectFtraceEvent {
  optional uint32 chan = 1;
  optional string port = 2;
  optional int32 state = 3;
}
message TrustyIpcConnectEndFtraceEvent {
  optional uint32 chan = 1;
  optional int32 err = 2;
  optional int32 state = 3;
}
message TrustyIpcWriteFtraceEvent {
  optional uint64 buf_id = 1;
  optional uint32 chan = 2;
  optional int32 kind_shm = 3;
  optional int32 len_or_err = 4;
  optional uint64 shm_cnt = 5;
  optional string srv_name = 6;
}
message TrustyIpcPollFtraceEvent {
  optional uint32 chan = 1;
  optional uint32 poll_mask = 2;
  optional string srv_name = 3;
}
message TrustyIpcReadFtraceEvent {
  optional uint32 chan = 1;
  optional string srv_name = 2;
}
message TrustyIpcReadEndFtraceEvent {
  optional uint64 buf_id = 1;
  optional uint32 chan = 2;
  optional int32 len_or_err = 3;
  optional uint64 shm_cnt = 4;
  optional string srv_name = 5;
}
message TrustyIpcRxFtraceEvent {
  optional uint64 buf_id = 1;
  optional uint32 chan = 2;
  optional string srv_name = 3;
}
message TrustyEnqueueNopFtraceEvent {
  optional uint32 arg1 = 1;
  optional uint32 arg2 = 2;
  optional uint32 arg3 = 3;
}

// End of protos/perfetto/trace/ftrace/trusty.proto

// Begin of protos/perfetto/trace/ftrace/ufs.proto

message UfshcdCommandFtraceEvent {
  optional string dev_name = 1;
  optional uint32 doorbell = 2;
  optional uint32 intr = 3;
  optional uint64 lba = 4;
  optional uint32 opcode = 5;
  optional string str = 6;
  optional uint32 tag = 7;
  optional int32 transfer_len = 8;
  optional uint32 group_id = 9;
  optional uint32 str_t = 10;
}
message UfshcdClkGatingFtraceEvent {
  optional string dev_name = 1;
  optional int32 state = 2;
}

// End of protos/perfetto/trace/ftrace/ufs.proto

// Begin of protos/perfetto/trace/ftrace/v4l2.proto

message V4l2QbufFtraceEvent {
  optional uint32 bytesused = 1;
  optional uint32 field = 2;
  optional uint32 flags = 3;
  optional uint32 index = 4;
  optional int32 minor = 5;
  optional uint32 sequence = 6;
  optional uint32 timecode_flags = 7;
  optional uint32 timecode_frames = 8;
  optional uint32 timecode_hours = 9;
  optional uint32 timecode_minutes = 10;
  optional uint32 timecode_seconds = 11;
  optional uint32 timecode_type = 12;
  optional uint32 timecode_userbits0 = 13;
  optional uint32 timecode_userbits1 = 14;
  optional uint32 timecode_userbits2 = 15;
  optional uint32 timecode_userbits3 = 16;
  optional int64 timestamp = 17;
  optional uint32 type = 18;
}
message V4l2DqbufFtraceEvent {
  optional uint32 bytesused = 1;
  optional uint32 field = 2;
  optional uint32 flags = 3;
  optional uint32 index = 4;
  optional int32 minor = 5;
  optional uint32 sequence = 6;
  optional uint32 timecode_flags = 7;
  optional uint32 timecode_frames = 8;
  optional uint32 timecode_hours = 9;
  optional uint32 timecode_minutes = 10;
  optional uint32 timecode_seconds = 11;
  optional uint32 timecode_type = 12;
  optional uint32 timecode_userbits0 = 13;
  optional uint32 timecode_userbits1 = 14;
  optional uint32 timecode_userbits2 = 15;
  optional uint32 timecode_userbits3 = 16;
  optional int64 timestamp = 17;
  optional uint32 type = 18;
}
message Vb2V4l2BufQueueFtraceEvent {
  optional uint32 field = 1;
  optional uint32 flags = 2;
  optional int32 minor = 3;
  optional uint32 sequence = 4;
  optional uint32 timecode_flags = 5;
  optional uint32 timecode_frames = 6;
  optional uint32 timecode_hours = 7;
  optional uint32 timecode_minutes = 8;
  optional uint32 timecode_seconds = 9;
  optional uint32 timecode_type = 10;
  optional uint32 timecode_userbits0 = 11;
  optional uint32 timecode_userbits1 = 12;
  optional uint32 timecode_userbits2 = 13;
  optional uint32 timecode_userbits3 = 14;
  optional int64 timestamp = 15;
}
message Vb2V4l2BufDoneFtraceEvent {
  optional uint32 field = 1;
  optional uint32 flags = 2;
  optional int32 minor = 3;
  optional uint32 sequence = 4;
  optional uint32 timecode_flags = 5;
  optional uint32 timecode_frames = 6;
  optional uint32 timecode_hours = 7;
  optional uint32 timecode_minutes = 8;
  optional uint32 timecode_seconds = 9;
  optional uint32 timecode_type = 10;
  optional uint32 timecode_userbits0 = 11;
  optional uint32 timecode_userbits1 = 12;
  optional uint32 timecode_userbits2 = 13;
  optional uint32 timecode_userbits3 = 14;
  optional int64 timestamp = 15;
}
message Vb2V4l2QbufFtraceEvent {
  optional uint32 field = 1;
  optional uint32 flags = 2;
  optional int32 minor = 3;
  optional uint32 sequence = 4;
  optional uint32 timecode_flags = 5;
  optional uint32 timecode_frames = 6;
  optional uint32 timecode_hours = 7;
  optional uint32 timecode_minutes = 8;
  optional uint32 timecode_seconds = 9;
  optional uint32 timecode_type = 10;
  optional uint32 timecode_userbits0 = 11;
  optional uint32 timecode_userbits1 = 12;
  optional uint32 timecode_userbits2 = 13;
  optional uint32 timecode_userbits3 = 14;
  optional int64 timestamp = 15;
}
message Vb2V4l2DqbufFtraceEvent {
  optional uint32 field = 1;
  optional uint32 flags = 2;
  optional int32 minor = 3;
  optional uint32 sequence = 4;
  optional uint32 timecode_flags = 5;
  optional uint32 timecode_frames = 6;
  optional uint32 timecode_hours = 7;
  optional uint32 timecode_minutes = 8;
  optional uint32 timecode_seconds = 9;
  optional uint32 timecode_type = 10;
  optional uint32 timecode_userbits0 = 11;
  optional uint32 timecode_userbits1 = 12;
  optional uint32 timecode_userbits2 = 13;
  optional uint32 timecode_userbits3 = 14;
  optional int64 timestamp = 15;
}

// End of protos/perfetto/trace/ftrace/v4l2.proto

// Begin of protos/perfetto/trace/ftrace/virtio_gpu.proto

message VirtioGpuCmdQueueFtraceEvent {
  optional uint32 ctx_id = 1;
  optional int32 dev = 2;
  optional uint64 fence_id = 3;
  optional uint32 flags = 4;
  optional string name = 5;
  optional uint32 num_free = 6;
  optional uint32 seqno = 7;
  optional uint32 type = 8;
  optional uint32 vq = 9;
}
message VirtioGpuCmdResponseFtraceEvent {
  optional uint32 ctx_id = 1;
  optional int32 dev = 2;
  optional uint64 fence_id = 3;
  optional uint32 flags = 4;
  optional string name = 5;
  optional uint32 num_free = 6;
  optional uint32 seqno = 7;
  optional uint32 type = 8;
  optional uint32 vq = 9;
}

// End of protos/perfetto/trace/ftrace/virtio_gpu.proto

// Begin of protos/perfetto/trace/ftrace/virtio_video.proto

message VirtioVideoCmdFtraceEvent {
  optional uint32 stream_id = 1;
  optional uint32 type = 2;
}
message VirtioVideoCmdDoneFtraceEvent {
  optional uint32 stream_id = 1;
  optional uint32 type = 2;
}
message VirtioVideoResourceQueueFtraceEvent {
  optional uint32 data_size0 = 1;
  optional uint32 data_size1 = 2;
  optional uint32 data_size2 = 3;
  optional uint32 data_size3 = 4;
  optional uint32 queue_type = 5;
  optional int32 resource_id = 6;
  optional int32 stream_id = 7;
  optional uint64 timestamp = 8;
}
message VirtioVideoResourceQueueDoneFtraceEvent {
  optional uint32 data_size0 = 1;
  optional uint32 data_size1 = 2;
  optional uint32 data_size2 = 3;
  optional uint32 data_size3 = 4;
  optional uint32 queue_type = 5;
  optional int32 resource_id = 6;
  optional int32 stream_id = 7;
  optional uint64 timestamp = 8;
}

// End of protos/perfetto/trace/ftrace/virtio_video.proto

// Begin of protos/perfetto/trace/ftrace/vmscan.proto

message MmVmscanDirectReclaimBeginFtraceEvent {
  optional int32 order = 1;
  optional int32 may_writepage = 2;
  optional uint32 gfp_flags = 3;
}
message MmVmscanDirectReclaimEndFtraceEvent {
  optional uint64 nr_reclaimed = 1;
}
message MmVmscanKswapdWakeFtraceEvent {
  optional int32 nid = 1;
  optional int32 order = 2;
  optional int32 zid = 3;
}
message MmVmscanKswapdSleepFtraceEvent {
  optional int32 nid = 1;
}
message MmShrinkSlabStartFtraceEvent {
  optional uint64 cache_items = 1;
  optional uint64 delta = 2;
  optional uint32 gfp_flags = 3;
  optional uint64 lru_pgs = 4;
  optional int64 nr_objects_to_shrink = 5;
  optional uint64 pgs_scanned = 6;
  optional uint64 shr = 7;
  optional uint64 shrink = 8;
  optional uint64 total_scan = 9;
  optional int32 nid = 10;
  optional int32 priority = 11;
}
message MmShrinkSlabEndFtraceEvent {
  optional int64 new_scan = 1;
  optional int32 retval = 2;
  optional uint64 shr = 3;
  optional uint64 shrink = 4;
  optional int64 total_scan = 5;
  optional int64 unused_scan = 6;
  optional int32 nid = 7;
}

// End of protos/perfetto/trace/ftrace/vmscan.proto

// Begin of protos/perfetto/trace/ftrace/workqueue.proto

message WorkqueueActivateWorkFtraceEvent {
  optional uint64 work = 1;
}
message WorkqueueExecuteEndFtraceEvent {
  optional uint64 work = 1;
  optional uint64 function = 2;
}
message WorkqueueExecuteStartFtraceEvent {
  optional uint64 work = 1;
  optional uint64 function = 2;
}
message WorkqueueQueueWorkFtraceEvent {
  optional uint64 work = 1;
  optional uint64 function = 2;
  optional uint64 workqueue = 3;
  optional uint32 req_cpu = 4;
  optional uint32 cpu = 5;
}

// End of protos/perfetto/trace/ftrace/workqueue.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event.proto

message FtraceEvent {
  // Timestamp in nanoseconds using .../tracing/trace_clock.
  optional uint64 timestamp = 1;

  // Kernel pid (do not confuse with userspace pid aka tgid).
  optional uint32 pid = 2;

  // Not populated in actual traces. Wire format might change.
  // Placeholder declaration so that the ftrace parsing code accepts the
  // existence of this common field. If this becomes needed for all events:
  // consider merging with common_preempt_count to avoid extra proto tags.
  optional uint32 common_flags = 5;

  // Range reserved for self-describing messages.
  reserved 65536 to 131072;

  oneof event {
    PrintFtraceEvent print = 3;
    SchedSwitchFtraceEvent sched_switch = 4;
    // removed field with id 5;
    // removed field with id 6;
    // removed field with id 7;
    // removed field with id 8;
    // removed field with id 9;
    // removed field with id 10;
    CpuFrequencyFtraceEvent cpu_frequency = 11;
    CpuFrequencyLimitsFtraceEvent cpu_frequency_limits = 12;
    CpuIdleFtraceEvent cpu_idle = 13;
    ClockEnableFtraceEvent clock_enable = 14;
    ClockDisableFtraceEvent clock_disable = 15;
    ClockSetRateFtraceEvent clock_set_rate = 16;
    SchedWakeupFtraceEvent sched_wakeup = 17;
    SchedBlockedReasonFtraceEvent sched_blocked_reason = 18;
    SchedCpuHotplugFtraceEvent sched_cpu_hotplug = 19;
    SchedWakingFtraceEvent sched_waking = 20;
    IpiEntryFtraceEvent ipi_entry = 21;
    IpiExitFtraceEvent ipi_exit = 22;
    IpiRaiseFtraceEvent ipi_raise = 23;
    SoftirqEntryFtraceEvent softirq_entry = 24;
    SoftirqExitFtraceEvent softirq_exit = 25;
    SoftirqRaiseFtraceEvent softirq_raise = 26;
    I2cReadFtraceEvent i2c_read = 27;
    I2cWriteFtraceEvent i2c_write = 28;
    I2cResultFtraceEvent i2c_result = 29;
    I2cReplyFtraceEvent i2c_reply = 30;
    SmbusReadFtraceEvent smbus_read = 31;
    SmbusWriteFtraceEvent smbus_write = 32;
    SmbusResultFtraceEvent smbus_result = 33;
    SmbusReplyFtraceEvent smbus_reply = 34;
    LowmemoryKillFtraceEvent lowmemory_kill = 35;
    IrqHandlerEntryFtraceEvent irq_handler_entry = 36;
    IrqHandlerExitFtraceEvent irq_handler_exit = 37;
    SyncPtFtraceEvent sync_pt = 38;
    SyncTimelineFtraceEvent sync_timeline = 39;
    SyncWaitFtraceEvent sync_wait = 40;
    Ext4DaWriteBeginFtraceEvent ext4_da_write_begin = 41;
    Ext4DaWriteEndFtraceEvent ext4_da_write_end = 42;
    Ext4SyncFileEnterFtraceEvent ext4_sync_file_enter = 43;
    Ext4SyncFileExitFtraceEvent ext4_sync_file_exit = 44;
    BlockRqIssueFtraceEvent block_rq_issue = 45;
    MmVmscanDirectReclaimBeginFtraceEvent mm_vmscan_direct_reclaim_begin = 46;
    MmVmscanDirectReclaimEndFtraceEvent mm_vmscan_direct_reclaim_end = 47;
    MmVmscanKswapdWakeFtraceEvent mm_vmscan_kswapd_wake = 48;
    MmVmscanKswapdSleepFtraceEvent mm_vmscan_kswapd_sleep = 49;
    BinderTransactionFtraceEvent binder_transaction = 50;
    BinderTransactionReceivedFtraceEvent binder_transaction_received = 51;
    BinderSetPriorityFtraceEvent binder_set_priority = 52;
    BinderLockFtraceEvent binder_lock = 53;
    BinderLockedFtraceEvent binder_locked = 54;
    BinderUnlockFtraceEvent binder_unlock = 55;
    WorkqueueActivateWorkFtraceEvent workqueue_activate_work = 56;
    WorkqueueExecuteEndFtraceEvent workqueue_execute_end = 57;
    WorkqueueExecuteStartFtraceEvent workqueue_execute_start = 58;
    WorkqueueQueueWorkFtraceEvent workqueue_queue_work = 59;
    RegulatorDisableFtraceEvent regulator_disable = 60;
    RegulatorDisableCompleteFtraceEvent regulator_disable_complete = 61;
    RegulatorEnableFtraceEvent regulator_enable = 62;
    RegulatorEnableCompleteFtraceEvent regulator_enable_complete = 63;
    RegulatorEnableDelayFtraceEvent regulator_enable_delay = 64;
    RegulatorSetVoltageFtraceEvent regulator_set_voltage = 65;
    RegulatorSetVoltageCompleteFtraceEvent regulator_set_voltage_complete = 66;
    CgroupAttachTaskFtraceEvent cgroup_attach_task = 67;
    CgroupMkdirFtraceEvent cgroup_mkdir = 68;
    CgroupRemountFtraceEvent cgroup_remount = 69;
    CgroupRmdirFtraceEvent cgroup_rmdir = 70;
    CgroupTransferTasksFtraceEvent cgroup_transfer_tasks = 71;
    CgroupDestroyRootFtraceEvent cgroup_destroy_root = 72;
    CgroupReleaseFtraceEvent cgroup_release = 73;
    CgroupRenameFtraceEvent cgroup_rename = 74;
    CgroupSetupRootFtraceEvent cgroup_setup_root = 75;
    MdpCmdKickoffFtraceEvent mdp_cmd_kickoff = 76;
    MdpCommitFtraceEvent mdp_commit = 77;
    MdpPerfSetOtFtraceEvent mdp_perf_set_ot = 78;
    MdpSsppChangeFtraceEvent mdp_sspp_change = 79;
    TracingMarkWriteFtraceEvent tracing_mark_write = 80;
    MdpCmdPingpongDoneFtraceEvent mdp_cmd_pingpong_done = 81;
    MdpCompareBwFtraceEvent mdp_compare_bw = 82;
    MdpPerfSetPanicLutsFtraceEvent mdp_perf_set_panic_luts = 83;
    MdpSsppSetFtraceEvent mdp_sspp_set = 84;
    MdpCmdReadptrDoneFtraceEvent mdp_cmd_readptr_done = 85;
    MdpMisrCrcFtraceEvent mdp_misr_crc = 86;
    MdpPerfSetQosLutsFtraceEvent mdp_perf_set_qos_luts = 87;
    MdpTraceCounterFtraceEvent mdp_trace_counter = 88;
    MdpCmdReleaseBwFtraceEvent mdp_cmd_release_bw = 89;
    MdpMixerUpdateFtraceEvent mdp_mixer_update = 90;
    MdpPerfSetWmLevelsFtraceEvent mdp_perf_set_wm_levels = 91;
    MdpVideoUnderrunDoneFtraceEvent mdp_video_underrun_done = 92;
    MdpCmdWaitPingpongFtraceEvent mdp_cmd_wait_pingpong = 93;
    MdpPerfPrefillCalcFtraceEvent mdp_perf_prefill_calc = 94;
    MdpPerfUpdateBusFtraceEvent mdp_perf_update_bus = 95;
    RotatorBwAoAsContextFtraceEvent rotator_bw_ao_as_context = 96;
    MmFilemapAddToPageCacheFtraceEvent mm_filemap_add_to_page_cache = 97;
    MmFilemapDeleteFromPageCacheFtraceEvent mm_filemap_delete_from_page_cache =
        98;
    MmCompactionBeginFtraceEvent mm_compaction_begin = 99;
    MmCompactionDeferCompactionFtraceEvent mm_compaction_defer_compaction = 100;
    MmCompactionDeferredFtraceEvent mm_compaction_deferred = 101;
    MmCompactionDeferResetFtraceEvent mm_compaction_defer_reset = 102;
    MmCompactionEndFtraceEvent mm_compaction_end = 103;
    MmCompactionFinishedFtraceEvent mm_compaction_finished = 104;
    MmCompactionIsolateFreepagesFtraceEvent mm_compaction_isolate_freepages =
        105;
    MmCompactionIsolateMigratepagesFtraceEvent
        mm_compaction_isolate_migratepages = 106;
    MmCompactionKcompactdSleepFtraceEvent mm_compaction_kcompactd_sleep = 107;
    MmCompactionKcompactdWakeFtraceEvent mm_compaction_kcompactd_wake = 108;
    MmCompactionMigratepagesFtraceEvent mm_compaction_migratepages = 109;
    MmCompactionSuitableFtraceEvent mm_compaction_suitable = 110;
    MmCompactionTryToCompactPagesFtraceEvent
        mm_compaction_try_to_compact_pages = 111;
    MmCompactionWakeupKcompactdFtraceEvent mm_compaction_wakeup_kcompactd = 112;
    SuspendResumeFtraceEvent suspend_resume = 113;
    SchedWakeupNewFtraceEvent sched_wakeup_new = 114;
    BlockBioBackmergeFtraceEvent block_bio_backmerge = 115;
    BlockBioBounceFtraceEvent block_bio_bounce = 116;
    BlockBioCompleteFtraceEvent block_bio_complete = 117;
    BlockBioFrontmergeFtraceEvent block_bio_frontmerge = 118;
    BlockBioQueueFtraceEvent block_bio_queue = 119;
    BlockBioRemapFtraceEvent block_bio_remap = 120;
    BlockDirtyBufferFtraceEvent block_dirty_buffer = 121;
    BlockGetrqFtraceEvent block_getrq = 122;
    BlockPlugFtraceEvent block_plug = 123;
    BlockRqAbortFtraceEvent block_rq_abort = 124;
    BlockRqCompleteFtraceEvent block_rq_complete = 125;
    BlockRqInsertFtraceEvent block_rq_insert = 126;
    // removed field with id 127;
    BlockRqRemapFtraceEvent block_rq_remap = 128;
    BlockRqRequeueFtraceEvent block_rq_requeue = 129;
    BlockSleeprqFtraceEvent block_sleeprq = 130;
    BlockSplitFtraceEvent block_split = 131;
    BlockTouchBufferFtraceEvent block_touch_buffer = 132;
    BlockUnplugFtraceEvent block_unplug = 133;
    Ext4AllocDaBlocksFtraceEvent ext4_alloc_da_blocks = 134;
    Ext4AllocateBlocksFtraceEvent ext4_allocate_blocks = 135;
    Ext4AllocateInodeFtraceEvent ext4_allocate_inode = 136;
    Ext4BeginOrderedTruncateFtraceEvent ext4_begin_ordered_truncate = 137;
    Ext4CollapseRangeFtraceEvent ext4_collapse_range = 138;
    Ext4DaReleaseSpaceFtraceEvent ext4_da_release_space = 139;
    Ext4DaReserveSpaceFtraceEvent ext4_da_reserve_space = 140;
    Ext4DaUpdateReserveSpaceFtraceEvent ext4_da_update_reserve_space = 141;
    Ext4DaWritePagesFtraceEvent ext4_da_write_pages = 142;
    Ext4DaWritePagesExtentFtraceEvent ext4_da_write_pages_extent = 143;
    Ext4DirectIOEnterFtraceEvent ext4_direct_IO_enter = 144;
    Ext4DirectIOExitFtraceEvent ext4_direct_IO_exit = 145;
    Ext4DiscardBlocksFtraceEvent ext4_discard_blocks = 146;
    Ext4DiscardPreallocationsFtraceEvent ext4_discard_preallocations = 147;
    Ext4DropInodeFtraceEvent ext4_drop_inode = 148;
    Ext4EsCacheExtentFtraceEvent ext4_es_cache_extent = 149;
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent
        ext4_es_find_delayed_extent_range_enter = 150;
    Ext4EsFindDelayedExtentRangeExitFtraceEvent
        ext4_es_find_delayed_extent_range_exit = 151;
    Ext4EsInsertExtentFtraceEvent ext4_es_insert_extent = 152;
    Ext4EsLookupExtentEnterFtraceEvent ext4_es_lookup_extent_enter = 153;
    Ext4EsLookupExtentExitFtraceEvent ext4_es_lookup_extent_exit = 154;
    Ext4EsRemoveExtentFtraceEvent ext4_es_remove_extent = 155;
    Ext4EsShrinkFtraceEvent ext4_es_shrink = 156;
    Ext4EsShrinkCountFtraceEvent ext4_es_shrink_count = 157;
    Ext4EsShrinkScanEnterFtraceEvent ext4_es_shrink_scan_enter = 158;
    Ext4EsShrinkScanExitFtraceEvent ext4_es_shrink_scan_exit = 159;
    Ext4EvictInodeFtraceEvent ext4_evict_inode = 160;
    Ext4ExtConvertToInitializedEnterFtraceEvent
        ext4_ext_convert_to_initialized_enter = 161;
    Ext4ExtConvertToInitializedFastpathFtraceEvent
        ext4_ext_convert_to_initialized_fastpath = 162;
    Ext4ExtHandleUnwrittenExtentsFtraceEvent ext4_ext_handle_unwritten_extents =
        163;
    Ext4ExtInCacheFtraceEvent ext4_ext_in_cache = 164;
    Ext4ExtLoadExtentFtraceEvent ext4_ext_load_extent = 165;
    Ext4ExtMapBlocksEnterFtraceEvent ext4_ext_map_blocks_enter = 166;
    Ext4ExtMapBlocksExitFtraceEvent ext4_ext_map_blocks_exit = 167;
    Ext4ExtPutInCacheFtraceEvent ext4_ext_put_in_cache = 168;
    Ext4ExtRemoveSpaceFtraceEvent ext4_ext_remove_space = 169;
    Ext4ExtRemoveSpaceDoneFtraceEvent ext4_ext_remove_space_done = 170;
    Ext4ExtRmIdxFtraceEvent ext4_ext_rm_idx = 171;
    Ext4ExtRmLeafFtraceEvent ext4_ext_rm_leaf = 172;
    Ext4ExtShowExtentFtraceEvent ext4_ext_show_extent = 173;
    Ext4FallocateEnterFtraceEvent ext4_fallocate_enter = 174;
    Ext4FallocateExitFtraceEvent ext4_fallocate_exit = 175;
    Ext4FindDelallocRangeFtraceEvent ext4_find_delalloc_range = 176;
    Ext4ForgetFtraceEvent ext4_forget = 177;
    Ext4FreeBlocksFtraceEvent ext4_free_blocks = 178;
    Ext4FreeInodeFtraceEvent ext4_free_inode = 179;
    Ext4GetImpliedClusterAllocExitFtraceEvent
        ext4_get_implied_cluster_alloc_exit = 180;
    Ext4GetReservedClusterAllocFtraceEvent ext4_get_reserved_cluster_alloc =
        181;
    Ext4IndMapBlocksEnterFtraceEvent ext4_ind_map_blocks_enter = 182;
    Ext4IndMapBlocksExitFtraceEvent ext4_ind_map_blocks_exit = 183;
    Ext4InsertRangeFtraceEvent ext4_insert_range = 184;
    Ext4InvalidatepageFtraceEvent ext4_invalidatepage = 185;
    Ext4JournalStartFtraceEvent ext4_journal_start = 186;
    Ext4JournalStartReservedFtraceEvent ext4_journal_start_reserved = 187;
    Ext4JournalledInvalidatepageFtraceEvent ext4_journalled_invalidatepage =
        188;
    Ext4JournalledWriteEndFtraceEvent ext4_journalled_write_end = 189;
    Ext4LoadInodeFtraceEvent ext4_load_inode = 190;
    Ext4LoadInodeBitmapFtraceEvent ext4_load_inode_bitmap = 191;
    Ext4MarkInodeDirtyFtraceEvent ext4_mark_inode_dirty = 192;
    Ext4MbBitmapLoadFtraceEvent ext4_mb_bitmap_load = 193;
    Ext4MbBuddyBitmapLoadFtraceEvent ext4_mb_buddy_bitmap_load = 194;
    Ext4MbDiscardPreallocationsFtraceEvent ext4_mb_discard_preallocations = 195;
    Ext4MbNewGroupPaFtraceEvent ext4_mb_new_group_pa = 196;
    Ext4MbNewInodePaFtraceEvent ext4_mb_new_inode_pa = 197;
    Ext4MbReleaseGroupPaFtraceEvent ext4_mb_release_group_pa = 198;
    Ext4MbReleaseInodePaFtraceEvent ext4_mb_release_inode_pa = 199;
    Ext4MballocAllocFtraceEvent ext4_mballoc_alloc = 200;
    Ext4MballocDiscardFtraceEvent ext4_mballoc_discard = 201;
    Ext4MballocFreeFtraceEvent ext4_mballoc_free = 202;
    Ext4MballocPreallocFtraceEvent ext4_mballoc_prealloc = 203;
    Ext4OtherInodeUpdateTimeFtraceEvent ext4_other_inode_update_time = 204;
    Ext4PunchHoleFtraceEvent ext4_punch_hole = 205;
    Ext4ReadBlockBitmapLoadFtraceEvent ext4_read_block_bitmap_load = 206;
    Ext4ReadpageFtraceEvent ext4_readpage = 207;
    Ext4ReleasepageFtraceEvent ext4_releasepage = 208;
    Ext4RemoveBlocksFtraceEvent ext4_remove_blocks = 209;
    Ext4RequestBlocksFtraceEvent ext4_request_blocks = 210;
    Ext4RequestInodeFtraceEvent ext4_request_inode = 211;
    Ext4SyncFsFtraceEvent ext4_sync_fs = 212;
    Ext4TrimAllFreeFtraceEvent ext4_trim_all_free = 213;
    Ext4TrimExtentFtraceEvent ext4_trim_extent = 214;
    Ext4TruncateEnterFtraceEvent ext4_truncate_enter = 215;
    Ext4TruncateExitFtraceEvent ext4_truncate_exit = 216;
    Ext4UnlinkEnterFtraceEvent ext4_unlink_enter = 217;
    Ext4UnlinkExitFtraceEvent ext4_unlink_exit = 218;
    Ext4WriteBeginFtraceEvent ext4_write_begin = 219;
    // removed field with id 220;
    // removed field with id 221;
    // removed field with id 222;
    // removed field with id 223;
    // removed field with id 224;
    // removed field with id 225;
    // removed field with id 226;
    // removed field with id 227;
    // removed field with id 228;
    // removed field with id 229;
    Ext4WriteEndFtraceEvent ext4_write_end = 230;
    Ext4WritepageFtraceEvent ext4_writepage = 231;
    Ext4WritepagesFtraceEvent ext4_writepages = 232;
    Ext4WritepagesResultFtraceEvent ext4_writepages_result = 233;
    Ext4ZeroRangeFtraceEvent ext4_zero_range = 234;
    TaskNewtaskFtraceEvent task_newtask = 235;
    TaskRenameFtraceEvent task_rename = 236;
    SchedProcessExecFtraceEvent sched_process_exec = 237;
    SchedProcessExitFtraceEvent sched_process_exit = 238;
    SchedProcessForkFtraceEvent sched_process_fork = 239;
    SchedProcessFreeFtraceEvent sched_process_free = 240;
    SchedProcessHangFtraceEvent sched_process_hang = 241;
    SchedProcessWaitFtraceEvent sched_process_wait = 242;
    F2fsDoSubmitBioFtraceEvent f2fs_do_submit_bio = 243;
    F2fsEvictInodeFtraceEvent f2fs_evict_inode = 244;
    F2fsFallocateFtraceEvent f2fs_fallocate = 245;
    F2fsGetDataBlockFtraceEvent f2fs_get_data_block = 246;
    F2fsGetVictimFtraceEvent f2fs_get_victim = 247;
    F2fsIgetFtraceEvent f2fs_iget = 248;
    F2fsIgetExitFtraceEvent f2fs_iget_exit = 249;
    F2fsNewInodeFtraceEvent f2fs_new_inode = 250;
    F2fsReadpageFtraceEvent f2fs_readpage = 251;
    F2fsReserveNewBlockFtraceEvent f2fs_reserve_new_block = 252;
    F2fsSetPageDirtyFtraceEvent f2fs_set_page_dirty = 253;
    F2fsSubmitWritePageFtraceEvent f2fs_submit_write_page = 254;
    F2fsSyncFileEnterFtraceEvent f2fs_sync_file_enter = 255;
    F2fsSyncFileExitFtraceEvent f2fs_sync_file_exit = 256;
    F2fsSyncFsFtraceEvent f2fs_sync_fs = 257;
    F2fsTruncateFtraceEvent f2fs_truncate = 258;
    F2fsTruncateBlocksEnterFtraceEvent f2fs_truncate_blocks_enter = 259;
    F2fsTruncateBlocksExitFtraceEvent f2fs_truncate_blocks_exit = 260;
    F2fsTruncateDataBlocksRangeFtraceEvent f2fs_truncate_data_blocks_range =
        261;
    F2fsTruncateInodeBlocksEnterFtraceEvent f2fs_truncate_inode_blocks_enter =
        262;
    F2fsTruncateInodeBlocksExitFtraceEvent f2fs_truncate_inode_blocks_exit =
        263;
    F2fsTruncateNodeFtraceEvent f2fs_truncate_node = 264;
    F2fsTruncateNodesEnterFtraceEvent f2fs_truncate_nodes_enter = 265;
    F2fsTruncateNodesExitFtraceEvent f2fs_truncate_nodes_exit = 266;
    F2fsTruncatePartialNodesFtraceEvent f2fs_truncate_partial_nodes = 267;
    F2fsUnlinkEnterFtraceEvent f2fs_unlink_enter = 268;
    F2fsUnlinkExitFtraceEvent f2fs_unlink_exit = 269;
    F2fsVmPageMkwriteFtraceEvent f2fs_vm_page_mkwrite = 270;
    F2fsWriteBeginFtraceEvent f2fs_write_begin = 271;
    F2fsWriteCheckpointFtraceEvent f2fs_write_checkpoint = 272;
    F2fsWriteEndFtraceEvent f2fs_write_end = 273;
    AllocPagesIommuEndFtraceEvent alloc_pages_iommu_end = 274;
    AllocPagesIommuFailFtraceEvent alloc_pages_iommu_fail = 275;
    AllocPagesIommuStartFtraceEvent alloc_pages_iommu_start = 276;
    AllocPagesSysEndFtraceEvent alloc_pages_sys_end = 277;
    AllocPagesSysFailFtraceEvent alloc_pages_sys_fail = 278;
    AllocPagesSysStartFtraceEvent alloc_pages_sys_start = 279;
    DmaAllocContiguousRetryFtraceEvent dma_alloc_contiguous_retry = 280;
    IommuMapRangeFtraceEvent iommu_map_range = 281;
    IommuSecPtblMapRangeEndFtraceEvent iommu_sec_ptbl_map_range_end = 282;
    IommuSecPtblMapRangeStartFtraceEvent iommu_sec_ptbl_map_range_start = 283;
    IonAllocBufferEndFtraceEvent ion_alloc_buffer_end = 284;
    IonAllocBufferFailFtraceEvent ion_alloc_buffer_fail = 285;
    IonAllocBufferFallbackFtraceEvent ion_alloc_buffer_fallback = 286;
    IonAllocBufferStartFtraceEvent ion_alloc_buffer_start = 287;
    IonCpAllocRetryFtraceEvent ion_cp_alloc_retry = 288;
    IonCpSecureBufferEndFtraceEvent ion_cp_secure_buffer_end = 289;
    IonCpSecureBufferStartFtraceEvent ion_cp_secure_buffer_start = 290;
    IonPrefetchingFtraceEvent ion_prefetching = 291;
    IonSecureCmaAddToPoolEndFtraceEvent ion_secure_cma_add_to_pool_end = 292;
    IonSecureCmaAddToPoolStartFtraceEvent ion_secure_cma_add_to_pool_start =
        293;
    IonSecureCmaAllocateEndFtraceEvent ion_secure_cma_allocate_end = 294;
    IonSecureCmaAllocateStartFtraceEvent ion_secure_cma_allocate_start = 295;
    IonSecureCmaShrinkPoolEndFtraceEvent ion_secure_cma_shrink_pool_end = 296;
    IonSecureCmaShrinkPoolStartFtraceEvent ion_secure_cma_shrink_pool_start =
        297;
    KfreeFtraceEvent kfree = 298;
    KmallocFtraceEvent kmalloc = 299;
    KmallocNodeFtraceEvent kmalloc_node = 300;
    KmemCacheAllocFtraceEvent kmem_cache_alloc = 301;
    KmemCacheAllocNodeFtraceEvent kmem_cache_alloc_node = 302;
    KmemCacheFreeFtraceEvent kmem_cache_free = 303;
    MigratePagesEndFtraceEvent migrate_pages_end = 304;
    MigratePagesStartFtraceEvent migrate_pages_start = 305;
    MigrateRetryFtraceEvent migrate_retry = 306;
    MmPageAllocFtraceEvent mm_page_alloc = 307;
    MmPageAllocExtfragFtraceEvent mm_page_alloc_extfrag = 308;
    MmPageAllocZoneLockedFtraceEvent mm_page_alloc_zone_locked = 309;
    MmPageFreeFtraceEvent mm_page_free = 310;
    MmPageFreeBatchedFtraceEvent mm_page_free_batched = 311;
    MmPagePcpuDrainFtraceEvent mm_page_pcpu_drain = 312;
    RssStatFtraceEvent rss_stat = 313;
    IonHeapShrinkFtraceEvent ion_heap_shrink = 314;
    IonHeapGrowFtraceEvent ion_heap_grow = 315;
    FenceInitFtraceEvent fence_init = 316;
    FenceDestroyFtraceEvent fence_destroy = 317;
    FenceEnableSignalFtraceEvent fence_enable_signal = 318;
    FenceSignaledFtraceEvent fence_signaled = 319;
    ClkEnableFtraceEvent clk_enable = 320;
    ClkDisableFtraceEvent clk_disable = 321;
    ClkSetRateFtraceEvent clk_set_rate = 322;
    BinderTransactionAllocBufFtraceEvent binder_transaction_alloc_buf = 323;
    SignalDeliverFtraceEvent signal_deliver = 324;
    SignalGenerateFtraceEvent signal_generate = 325;
    OomScoreAdjUpdateFtraceEvent oom_score_adj_update = 326;
    GenericFtraceEvent generic = 327;
    MmEventRecordFtraceEvent mm_event_record = 328;
    SysEnterFtraceEvent sys_enter = 329;
    SysExitFtraceEvent sys_exit = 330;
    ZeroFtraceEvent zero = 331;
    GpuFrequencyFtraceEvent gpu_frequency = 332;
    SdeTracingMarkWriteFtraceEvent sde_tracing_mark_write = 333;
    MarkVictimFtraceEvent mark_victim = 334;
    IonStatFtraceEvent ion_stat = 335;
    IonBufferCreateFtraceEvent ion_buffer_create = 336;
    IonBufferDestroyFtraceEvent ion_buffer_destroy = 337;
    ScmCallStartFtraceEvent scm_call_start = 338;
    ScmCallEndFtraceEvent scm_call_end = 339;
    GpuMemTotalFtraceEvent gpu_mem_total = 340;
    ThermalTemperatureFtraceEvent thermal_temperature = 341;
    CdevUpdateFtraceEvent cdev_update = 342;
    CpuhpExitFtraceEvent cpuhp_exit = 343;
    CpuhpMultiEnterFtraceEvent cpuhp_multi_enter = 344;
    CpuhpEnterFtraceEvent cpuhp_enter = 345;
    CpuhpLatencyFtraceEvent cpuhp_latency = 346;
    FastrpcDmaStatFtraceEvent fastrpc_dma_stat = 347;
    DpuTracingMarkWriteFtraceEvent dpu_tracing_mark_write = 348;
    G2dTracingMarkWriteFtraceEvent g2d_tracing_mark_write = 349;
    MaliTracingMarkWriteFtraceEvent mali_tracing_mark_write = 350;
    DmaHeapStatFtraceEvent dma_heap_stat = 351;
    CpuhpPauseFtraceEvent cpuhp_pause = 352;
    SchedPiSetprioFtraceEvent sched_pi_setprio = 353;
    SdeSdeEvtlogFtraceEvent sde_sde_evtlog = 354;
    SdeSdePerfCalcCrtcFtraceEvent sde_sde_perf_calc_crtc = 355;
    SdeSdePerfCrtcUpdateFtraceEvent sde_sde_perf_crtc_update = 356;
    SdeSdePerfSetQosLutsFtraceEvent sde_sde_perf_set_qos_luts = 357;
    SdeSdePerfUpdateBusFtraceEvent sde_sde_perf_update_bus = 358;
    RssStatThrottledFtraceEvent rss_stat_throttled = 359;
    NetifReceiveSkbFtraceEvent netif_receive_skb = 360;
    NetDevXmitFtraceEvent net_dev_xmit = 361;
    InetSockSetStateFtraceEvent inet_sock_set_state = 362;
    TcpRetransmitSkbFtraceEvent tcp_retransmit_skb = 363;
    CrosEcSensorhubDataFtraceEvent cros_ec_sensorhub_data = 364;
    NapiGroReceiveEntryFtraceEvent napi_gro_receive_entry = 365;
    NapiGroReceiveExitFtraceEvent napi_gro_receive_exit = 366;
    KfreeSkbFtraceEvent kfree_skb = 367;
    KvmAccessFaultFtraceEvent kvm_access_fault = 368;
    KvmAckIrqFtraceEvent kvm_ack_irq = 369;
    KvmAgeHvaFtraceEvent kvm_age_hva = 370;
    KvmAgePageFtraceEvent kvm_age_page = 371;
    KvmArmClearDebugFtraceEvent kvm_arm_clear_debug = 372;
    KvmArmSetDreg32FtraceEvent kvm_arm_set_dreg32 = 373;
    KvmArmSetRegsetFtraceEvent kvm_arm_set_regset = 374;
    KvmArmSetupDebugFtraceEvent kvm_arm_setup_debug = 375;
    KvmEntryFtraceEvent kvm_entry = 376;
    KvmExitFtraceEvent kvm_exit = 377;
    KvmFpuFtraceEvent kvm_fpu = 378;
    KvmGetTimerMapFtraceEvent kvm_get_timer_map = 379;
    KvmGuestFaultFtraceEvent kvm_guest_fault = 380;
    KvmHandleSysRegFtraceEvent kvm_handle_sys_reg = 381;
    KvmHvcArm64FtraceEvent kvm_hvc_arm64 = 382;
    KvmIrqLineFtraceEvent kvm_irq_line = 383;
    KvmMmioFtraceEvent kvm_mmio = 384;
    KvmMmioEmulateFtraceEvent kvm_mmio_emulate = 385;
    KvmSetGuestDebugFtraceEvent kvm_set_guest_debug = 386;
    KvmSetIrqFtraceEvent kvm_set_irq = 387;
    KvmSetSpteHvaFtraceEvent kvm_set_spte_hva = 388;
    KvmSetWayFlushFtraceEvent kvm_set_way_flush = 389;
    KvmSysAccessFtraceEvent kvm_sys_access = 390;
    KvmTestAgeHvaFtraceEvent kvm_test_age_hva = 391;
    KvmTimerEmulateFtraceEvent kvm_timer_emulate = 392;
    KvmTimerHrtimerExpireFtraceEvent kvm_timer_hrtimer_expire = 393;
    KvmTimerRestoreStateFtraceEvent kvm_timer_restore_state = 394;
    KvmTimerSaveStateFtraceEvent kvm_timer_save_state = 395;
    KvmTimerUpdateIrqFtraceEvent kvm_timer_update_irq = 396;
    KvmToggleCacheFtraceEvent kvm_toggle_cache = 397;
    KvmUnmapHvaRangeFtraceEvent kvm_unmap_hva_range = 398;
    KvmUserspaceExitFtraceEvent kvm_userspace_exit = 399;
    KvmVcpuWakeupFtraceEvent kvm_vcpu_wakeup = 400;
    KvmWfxArm64FtraceEvent kvm_wfx_arm64 = 401;
    TrapRegFtraceEvent trap_reg = 402;
    VgicUpdateIrqPendingFtraceEvent vgic_update_irq_pending = 403;
    WakeupSourceActivateFtraceEvent wakeup_source_activate = 404;
    WakeupSourceDeactivateFtraceEvent wakeup_source_deactivate = 405;
    UfshcdCommandFtraceEvent ufshcd_command = 406;
    UfshcdClkGatingFtraceEvent ufshcd_clk_gating = 407;
    ConsoleFtraceEvent console = 408;
    DrmVblankEventFtraceEvent drm_vblank_event = 409;
    DrmVblankEventDeliveredFtraceEvent drm_vblank_event_delivered = 410;
    DrmSchedJobFtraceEvent drm_sched_job = 411;
    DrmRunJobFtraceEvent drm_run_job = 412;
    DrmSchedProcessJobFtraceEvent drm_sched_process_job = 413;
    DmaFenceInitFtraceEvent dma_fence_init = 414;
    DmaFenceEmitFtraceEvent dma_fence_emit = 415;
    DmaFenceSignaledFtraceEvent dma_fence_signaled = 416;
    DmaFenceWaitStartFtraceEvent dma_fence_wait_start = 417;
    DmaFenceWaitEndFtraceEvent dma_fence_wait_end = 418;
    F2fsIostatFtraceEvent f2fs_iostat = 419;
    F2fsIostatLatencyFtraceEvent f2fs_iostat_latency = 420;
    SchedCpuUtilCfsFtraceEvent sched_cpu_util_cfs = 421;
    V4l2QbufFtraceEvent v4l2_qbuf = 422;
    V4l2DqbufFtraceEvent v4l2_dqbuf = 423;
    Vb2V4l2BufQueueFtraceEvent vb2_v4l2_buf_queue = 424;
    Vb2V4l2BufDoneFtraceEvent vb2_v4l2_buf_done = 425;
    Vb2V4l2QbufFtraceEvent vb2_v4l2_qbuf = 426;
    Vb2V4l2DqbufFtraceEvent vb2_v4l2_dqbuf = 427;
    DsiCmdFifoStatusFtraceEvent dsi_cmd_fifo_status = 428;
    DsiRxFtraceEvent dsi_rx = 429;
    DsiTxFtraceEvent dsi_tx = 430;
    AndroidFsDatareadEndFtraceEvent android_fs_dataread_end = 431;
    AndroidFsDatareadStartFtraceEvent android_fs_dataread_start = 432;
    AndroidFsDatawriteEndFtraceEvent android_fs_datawrite_end = 433;
    AndroidFsDatawriteStartFtraceEvent android_fs_datawrite_start = 434;
    AndroidFsFsyncEndFtraceEvent android_fs_fsync_end = 435;
    AndroidFsFsyncStartFtraceEvent android_fs_fsync_start = 436;
    FuncgraphEntryFtraceEvent funcgraph_entry = 437;
    FuncgraphExitFtraceEvent funcgraph_exit = 438;
    VirtioVideoCmdFtraceEvent virtio_video_cmd = 439;
    VirtioVideoCmdDoneFtraceEvent virtio_video_cmd_done = 440;
    VirtioVideoResourceQueueFtraceEvent virtio_video_resource_queue = 441;
    VirtioVideoResourceQueueDoneFtraceEvent virtio_video_resource_queue_done =
        442;
    MmShrinkSlabStartFtraceEvent mm_shrink_slab_start = 443;
    MmShrinkSlabEndFtraceEvent mm_shrink_slab_end = 444;
    TrustySmcFtraceEvent trusty_smc = 445;
    TrustySmcDoneFtraceEvent trusty_smc_done = 446;
    TrustyStdCall32FtraceEvent trusty_std_call32 = 447;
    TrustyStdCall32DoneFtraceEvent trusty_std_call32_done = 448;
    TrustyShareMemoryFtraceEvent trusty_share_memory = 449;
    TrustyShareMemoryDoneFtraceEvent trusty_share_memory_done = 450;
    TrustyReclaimMemoryFtraceEvent trusty_reclaim_memory = 451;
    TrustyReclaimMemoryDoneFtraceEvent trusty_reclaim_memory_done = 452;
    TrustyIrqFtraceEvent trusty_irq = 453;
    TrustyIpcHandleEventFtraceEvent trusty_ipc_handle_event = 454;
    TrustyIpcConnectFtraceEvent trusty_ipc_connect = 455;
    TrustyIpcConnectEndFtraceEvent trusty_ipc_connect_end = 456;
    TrustyIpcWriteFtraceEvent trusty_ipc_write = 457;
    TrustyIpcPollFtraceEvent trusty_ipc_poll = 458;
    // removed field with id 459;
    TrustyIpcReadFtraceEvent trusty_ipc_read = 460;
    TrustyIpcReadEndFtraceEvent trusty_ipc_read_end = 461;
    TrustyIpcRxFtraceEvent trusty_ipc_rx = 462;
    // removed field with id 463;
    TrustyEnqueueNopFtraceEvent trusty_enqueue_nop = 464;
    CmaAllocStartFtraceEvent cma_alloc_start = 465;
    CmaAllocInfoFtraceEvent cma_alloc_info = 466;
    LwisTracingMarkWriteFtraceEvent lwis_tracing_mark_write = 467;
    VirtioGpuCmdQueueFtraceEvent virtio_gpu_cmd_queue = 468;
    VirtioGpuCmdResponseFtraceEvent virtio_gpu_cmd_response = 469;
    MaliMaliKCPUCQSSETFtraceEvent mali_mali_KCPU_CQS_SET = 470;
    MaliMaliKCPUCQSWAITSTARTFtraceEvent mali_mali_KCPU_CQS_WAIT_START = 471;
    MaliMaliKCPUCQSWAITENDFtraceEvent mali_mali_KCPU_CQS_WAIT_END = 472;
    MaliMaliKCPUFENCESIGNALFtraceEvent mali_mali_KCPU_FENCE_SIGNAL = 473;
    MaliMaliKCPUFENCEWAITSTARTFtraceEvent mali_mali_KCPU_FENCE_WAIT_START = 474;
    MaliMaliKCPUFENCEWAITENDFtraceEvent mali_mali_KCPU_FENCE_WAIT_END = 475;
    HypEnterFtraceEvent hyp_enter = 476;
    HypExitFtraceEvent hyp_exit = 477;
    HostHcallFtraceEvent host_hcall = 478;
    HostSmcFtraceEvent host_smc = 479;
    HostMemAbortFtraceEvent host_mem_abort = 480;
    SuspendResumeMinimalFtraceEvent suspend_resume_minimal = 481;
    MaliMaliCSFINTERRUPTSTARTFtraceEvent mali_mali_CSF_INTERRUPT_START = 482;
    MaliMaliCSFINTERRUPTENDFtraceEvent mali_mali_CSF_INTERRUPT_END = 483;
    SamsungTracingMarkWriteFtraceEvent samsung_tracing_mark_write = 484;
    BinderCommandFtraceEvent binder_command = 485;
    BinderReturnFtraceEvent binder_return = 486;
    SchedSwitchWithCtrsFtraceEvent sched_switch_with_ctrs = 487;
    GpuWorkPeriodFtraceEvent gpu_work_period = 488;
    RpmStatusFtraceEvent rpm_status = 489;
    PanelWriteGenericFtraceEvent panel_write_generic = 490;
    SchedMigrateTaskFtraceEvent sched_migrate_task = 491;
    DpuDsiCmdFifoStatusFtraceEvent dpu_dsi_cmd_fifo_status = 492;
    DpuDsiRxFtraceEvent dpu_dsi_rx = 493;
    DpuDsiTxFtraceEvent dpu_dsi_tx = 494;
    F2fsBackgroundGcFtraceEvent f2fs_background_gc = 495;
    F2fsGcBeginFtraceEvent f2fs_gc_begin = 496;
    F2fsGcEndFtraceEvent f2fs_gc_end = 497;
    FastrpcDmaFreeFtraceEvent fastrpc_dma_free = 498;
    FastrpcDmaAllocFtraceEvent fastrpc_dma_alloc = 499;
    FastrpcDmaUnmapFtraceEvent fastrpc_dma_unmap = 500;
    FastrpcDmaMapFtraceEvent fastrpc_dma_map = 501;
    GoogleIccEventFtraceEvent google_icc_event = 502;
    GoogleIrmEventFtraceEvent google_irm_event = 503;
    DevicePmCallbackStartFtraceEvent device_pm_callback_start = 504;
    DevicePmCallbackEndFtraceEvent device_pm_callback_end = 505;
    ThermalExynosAcpmBulkFtraceEvent thermal_exynos_acpm_bulk = 506;
    ThermalExynosAcpmHighOverheadFtraceEvent thermal_exynos_acpm_high_overhead =
        507;
    DcvshFreqFtraceEvent dcvsh_freq = 508;
    KgslGpuFrequencyFtraceEvent kgsl_gpu_frequency = 509;
    MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEvent
        mali_mali_PM_MCU_HCTL_CORES_DOWN_SCALE_NOTIFY_PEND = 510;
    MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEvent
        mali_mali_PM_MCU_HCTL_CORES_NOTIFY_PEND = 511;
    MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEvent
        mali_mali_PM_MCU_HCTL_CORE_INACTIVE_PEND = 512;
    MaliMaliPMMCUHCTLMCUONRECHECKFtraceEvent
        mali_mali_PM_MCU_HCTL_MCU_ON_RECHECK = 513;
    MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEvent
        mali_mali_PM_MCU_HCTL_SHADERS_CORE_OFF_PEND = 514;
    MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEvent
        mali_mali_PM_MCU_HCTL_SHADERS_PEND_OFF = 515;
    MaliMaliPMMCUHCTLSHADERSPENDONFtraceEvent
        mali_mali_PM_MCU_HCTL_SHADERS_PEND_ON = 516;
    MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEvent
        mali_mali_PM_MCU_HCTL_SHADERS_READY_OFF = 517;
    MaliMaliPMMCUINSLEEPFtraceEvent mali_mali_PM_MCU_IN_SLEEP = 518;
    MaliMaliPMMCUOFFFtraceEvent mali_mali_PM_MCU_OFF = 519;
    MaliMaliPMMCUONFtraceEvent mali_mali_PM_MCU_ON = 520;
    MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEvent
        mali_mali_PM_MCU_ON_CORE_ATTR_UPDATE_PEND = 521;
    MaliMaliPMMCUONGLBREINITPENDFtraceEvent
        mali_mali_PM_MCU_ON_GLB_REINIT_PEND = 522;
    MaliMaliPMMCUONHALTFtraceEvent mali_mali_PM_MCU_ON_HALT = 523;
    MaliMaliPMMCUONHWCNTDISABLEFtraceEvent mali_mali_PM_MCU_ON_HWCNT_DISABLE =
        524;
    MaliMaliPMMCUONHWCNTENABLEFtraceEvent mali_mali_PM_MCU_ON_HWCNT_ENABLE =
        525;
    MaliMaliPMMCUONPENDHALTFtraceEvent mali_mali_PM_MCU_ON_PEND_HALT = 526;
    MaliMaliPMMCUONPENDSLEEPFtraceEvent mali_mali_PM_MCU_ON_PEND_SLEEP = 527;
    MaliMaliPMMCUONSLEEPINITIATEFtraceEvent mali_mali_PM_MCU_ON_SLEEP_INITIATE =
        528;
    MaliMaliPMMCUPENDOFFFtraceEvent mali_mali_PM_MCU_PEND_OFF = 529;
    MaliMaliPMMCUPENDONRELOADFtraceEvent mali_mali_PM_MCU_PEND_ON_RELOAD = 530;
    MaliMaliPMMCUPOWERDOWNFtraceEvent mali_mali_PM_MCU_POWER_DOWN = 531;
    MaliMaliPMMCURESETWAITFtraceEvent mali_mali_PM_MCU_RESET_WAIT = 532;
    BclIrqTriggerFtraceEvent bcl_irq_trigger = 533;
    KgslAdrenoCmdbatchQueuedFtraceEvent kgsl_adreno_cmdbatch_queued = 534;
    KgslAdrenoCmdbatchSubmittedFtraceEvent kgsl_adreno_cmdbatch_submitted = 535;
    KgslAdrenoCmdbatchSyncFtraceEvent kgsl_adreno_cmdbatch_sync = 536;
    KgslAdrenoCmdbatchRetiredFtraceEvent kgsl_adreno_cmdbatch_retired = 537;
    PixelMmKswapdWakeFtraceEvent pixel_mm_kswapd_wake = 538;
    PixelMmKswapdDoneFtraceEvent pixel_mm_kswapd_done = 539;
    SchedWakeupTaskAttrFtraceEvent sched_wakeup_task_attr = 540;
    DevfreqFrequencyFtraceEvent devfreq_frequency = 541;
    KprobeEvent kprobe_event = 542;
    ParamSetValueCpmFtraceEvent param_set_value_cpm = 543;
    DoSysOpenFtraceEvent do_sys_open = 544;
    OpenExecFtraceEvent open_exec = 545;
    BlockIoStartFtraceEvent block_io_start = 546;
    BlockIoDoneFtraceEvent block_io_done = 547;
    MaliGpuPowerStateFtraceEvent mali_gpu_power_state = 548;
    DpuDispDpuUnderrunFtraceEvent dpu_disp_dpu_underrun = 549;
    DpuDispVblankIrqEnableFtraceEvent dpu_disp_vblank_irq_enable = 550;
    HrtimerStartFtraceEvent hrtimer_start = 551;
    HrtimerCancelFtraceEvent hrtimer_cancel = 552;
    HrtimerExpireEntryFtraceEvent hrtimer_expire_entry = 553;
    HrtimerExpireExitFtraceEvent hrtimer_expire_exit = 554;
    TimerStartFtraceEvent timer_start = 555;
    TimerCancelFtraceEvent timer_cancel = 556;
    TimerExpireEntryFtraceEvent timer_expire_entry = 557;
    TimerExpireExitFtraceEvent timer_expire_exit = 558;
    LocalTimerEntryFtraceEvent local_timer_entry = 559;
    LocalTimerExitFtraceEvent local_timer_exit = 560;
    Dwc3AllocRequestFtraceEvent dwc3_alloc_request = 561;
    Dwc3CompleteTrbFtraceEvent dwc3_complete_trb = 562;
    Dwc3CtrlReqFtraceEvent dwc3_ctrl_req = 563;
    Dwc3EpDequeueFtraceEvent dwc3_ep_dequeue = 564;
    Dwc3EpQueueFtraceEvent dwc3_ep_queue = 565;
    Dwc3EventFtraceEvent dwc3_event = 566;
    Dwc3FreeRequestFtraceEvent dwc3_free_request = 567;
    Dwc3GadgetEpCmdFtraceEvent dwc3_gadget_ep_cmd = 568;
    Dwc3GadgetEpDisableFtraceEvent dwc3_gadget_ep_disable = 569;
    Dwc3GadgetEpEnableFtraceEvent dwc3_gadget_ep_enable = 570;
    Dwc3GadgetGenericCmdFtraceEvent dwc3_gadget_generic_cmd = 571;
    Dwc3GadgetGivebackFtraceEvent dwc3_gadget_giveback = 572;
    Dwc3PrepareTrbFtraceEvent dwc3_prepare_trb = 573;
    Dwc3ReadlFtraceEvent dwc3_readl = 574;
    Dwc3WritelFtraceEvent dwc3_writel = 575;
    CmaAllocFinishFtraceEvent cma_alloc_finish = 576;
    MmAllocContigMigrateRangeInfoFtraceEvent
        mm_alloc_contig_migrate_range_info = 577;
    HostFfaCallFtraceEvent host_ffa_call = 578;
    DmabufRssStatFtraceEvent dmabuf_rss_stat = 579;
    IommuIdmapFtraceEvent iommu_idmap = 580;
    PsciMemProtectFtraceEvent psci_mem_protect = 581;
    HypervisorHostHcallFtraceEvent hypervisor_host_hcall = 582;
    HypervisorHostSmcFtraceEvent hypervisor_host_smc = 583;
    HypervisorHypExitFtraceEvent hypervisor_hyp_exit = 584;
    HypervisorIommuIdmapFtraceEvent hypervisor_iommu_idmap = 585;
    HypervisorPsciMemProtectFtraceEvent hypervisor_psci_mem_protect = 586;
    HypervisorHostMemAbortFtraceEvent hypervisor_host_mem_abort = 587;
    HypervisorHypEnterFtraceEvent hypervisor_hyp_enter = 588;
    HypervisorIommuIdmapCompleteFtraceEvent hypervisor_iommu_idmap_complete =
        589;
    HypervisorVcpuIllegalTrapFtraceEvent hypervisor_vcpu_illegal_trap = 590;
    DrmSchedJobAddDepFtraceEvent drm_sched_job_add_dep = 591;
    DrmSchedJobDoneFtraceEvent drm_sched_job_done = 592;
    DrmSchedJobQueueFtraceEvent drm_sched_job_queue = 593;
    DrmSchedJobRunFtraceEvent drm_sched_job_run = 594;
    DrmSchedJobUnschedulableFtraceEvent drm_sched_job_unschedulable = 595;
  }
}

// End of protos/perfetto/trace/ftrace/ftrace_event.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Per-CPU kernel buffer stats for the ftrace data source gathered from
// /sys/kernel/tracing/per_cpu/cpuX/stats.
message FtraceCpuStats {
  // CPU index.
  optional uint64 cpu = 1;

  // Number of entries currently in the kernel buffer.
  optional uint64 entries = 2;

  // Number of events lost in kernel buffers due to overwriting of old events
  // before userspace had a chance to drain them. Valid if the buffer is in
  // "overwrite" mode, otherwise see |dropped_events|.
  optional uint64 overrun = 3;

  // This should always be zero. If not the buffer size is way too small or
  // something went wrong with the tracer. Quoting the kernel: "number of
  // commits failing due to the buffer wrapping around while there are
  // uncommitted events, such as during an interrupt storm".
  optional uint64 commit_overrun = 4;

  // Size of entries currently in the kernel buffer (see |entries|) in bytes.
  // The field should be named "bytes", but is misnamed for historical reasons.
  // This value has known inaccuracies before Linux v6.6:
  // https://github.com/torvalds/linux/commit/45d99ea
  optional uint64 bytes_read = 5;

  // The timestamp for the oldest event still in the ring buffer.
  // Unit: seconds for typical trace clocks (i.e. not tsc/counter).
  optional double oldest_event_ts = 6;

  // The current timestamp.
  // Unit: seconds for typical trace clocks (i.e. not tsc/counter).
  optional double now_ts = 7;

  // If the kernel buffer has overwrite mode disabled, this will show the number
  // of new events that were lost because the buffer was full. This is similar
  // to |overrun| but only for the overwrite=false case.
  optional uint64 dropped_events = 8;

  // The number of events read (consumed) from the buffer by userspace.
  optional uint64 read_events = 9;
}

// Kprobe statistical data, gathered from /sys/kernel/tracing/kprobe_profile.
message FtraceKprobeStats {
  // Cumulative number of kprobe events generated for this function
  optional int64 hits = 1;
  // Cumulative number of kprobe events that could not be generated for this
  // function and were missed.  This happens when too much nesting
  // happens between a kprobe and its kretprobe, overflowing the
  // maxactives buffer.
  optional int64 misses = 2;
}

// Errors and kernel buffer stats for the ftrace data source.
message FtraceStats {
  enum Phase {
    UNSPECIFIED = 0;
    START_OF_TRACE = 1;
    END_OF_TRACE = 2;
  }

  // A pair of FtraceStats is written on every trace flush:
  // * START_OF_TRACE - stats recorded at the beginning of the trace.
  // * END_OF_TRACE - stats recorded during the flush. In other words shortly
  //                  before this packet was written. For simple traces this
  //                  will be once at the end of the trace.
  optional Phase phase = 1;

  // Per-CPU stats (one entry for each CPU).
  repeated FtraceCpuStats cpu_stats = 2;

  // When FtraceConfig.symbolize_ksyms = true, this records the number of
  // symbols parsed from /proc/kallsyms, whether they have been seen in the
  // trace or not. It can be used to debug kptr_restrict or security-related
  // errors.
  // Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
  // initialized. When START_OF_TRACE is emitted it is not ready yet.
  optional uint32 kernel_symbols_parsed = 3;

  // The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
  optional uint32 kernel_symbols_mem_kb = 4;

  // Atrace errors (even non-fatal ones) are reported here. A typical example is
  // one or more atrace categories not available on the device.
  optional string atrace_errors = 5;

  // Error message due to exclusivity violation of a single-tenant feature.
  optional string exclusive_feature_error = 13;

  // Ftrace events requested by the config but not present on device.
  repeated string unknown_ftrace_events = 6;

  // Ftrace events requested by the config and present on device, but which we
  // failed to enable due to permissions, or due to a conflicting option
  // (currently FtraceConfig.disable_generic_events).
  repeated string failed_ftrace_events = 7;

  // The data source was configured to preserve existing events in the ftrace
  // buffer before the start of the trace.
  optional bool preserve_ftrace_buffer = 8;

  // Unique errors encountered during reading and parsing of the raw ftrace
  // data. Ring buffer ABI related errors will also be recorded in the
  // affected FtraceEventBundles with a timestamp.
  // Any traces with entries in this field should be investigated, as they
  // indicate a bug in perfetto or the kernel.
  repeated FtraceParseStatus ftrace_parse_errors = 9;

  // Kprobe profile stats for functions hits and misses
  optional FtraceKprobeStats kprobe_stats = 10;

  // Per-cpu buffer size as returned by buffer_size_kb in pages (rounded up).
  // Added in: perfetto v52.
  optional uint32 cpu_buffer_size_pages = 11;

  // Per-cpu buffer size as cached by our implementation (ftrace muxer), based
  // on the value we're writing into the tracefs control file. Might not be
  // exactly equal to |cpu_buffer_size_pages| due to the kernel allocating extra
  // scratch pages (and/or other factors). Added in: perfetto v52.
  optional uint32 cached_cpu_buffer_size_pages = 12;
}

enum FtraceParseStatus {
  FTRACE_STATUS_UNSPECIFIED = 0;
  // Not written, used for convenience of implementation:
  FTRACE_STATUS_OK = 1;
  // Issues with reading data out of the ftrace ring buffer:
  FTRACE_STATUS_UNEXPECTED_READ_ERROR = 2;
  FTRACE_STATUS_PARTIAL_PAGE_READ = 3;
  // Ring buffer binary data not matching our understanding of the layout:
  FTRACE_STATUS_ABI_INVALID_PAGE_HEADER = 4;
  FTRACE_STATUS_ABI_SHORT_EVENT_HEADER = 5;
  FTRACE_STATUS_ABI_NULL_PADDING = 6;
  FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH = 7;
  FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH = 8;
  FTRACE_STATUS_ABI_SHORT_TIME_EXTEND = 9;
  FTRACE_STATUS_ABI_SHORT_TIME_STAMP = 10;
  FTRACE_STATUS_ABI_SHORT_DATA_LENGTH = 11;
  FTRACE_STATUS_ABI_ZERO_DATA_LENGTH = 12;
  FTRACE_STATUS_ABI_INVALID_DATA_LENGTH = 13;
  FTRACE_STATUS_ABI_SHORT_EVENT_ID = 14;
  FTRACE_STATUS_ABI_END_OVERFLOW = 15;
  // Issues with parsing the event payload:
  FTRACE_STATUS_SHORT_COMPACT_EVENT = 16;
  FTRACE_STATUS_INVALID_EVENT = 17;
}

// End of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

// The result of tracing one or more ftrace data pages from a single per-cpu
// kernel ring buffer. If collating multiple pages' worth of events, all of
// them come from contiguous pages, with no kernel data loss in between.
message FtraceEventBundle {
  optional uint32 cpu = 1;
  repeated FtraceEvent event = 2;

  // Set to true if there was data loss between the last time we've read from
  // the corresponding per-cpu kernel buffer, and the earliest event recorded
  // in this bundle.
  optional bool lost_events = 3;

  // Optionally-enabled compact encoding of a batch of scheduling events. Only
  // a subset of events & their fields is recorded.
  // All fields (except comms) are stored in a structure-of-arrays form, one
  // entry in each repeated field per event.
  message CompactSched {
    // Interned table of unique strings for this bundle.
    repeated string intern_table = 5;

    // Delta-encoded timestamps across all sched_switch events within this
    // bundle. The first is absolute, each next one is relative to its
    // predecessor.
    repeated uint64 switch_timestamp = 1 [packed = true];
    repeated int64 switch_prev_state = 2 [packed = true];
    repeated int32 switch_next_pid = 3 [packed = true];
    repeated int32 switch_next_prio = 4 [packed = true];
    // One per event, index into |intern_table| corresponding to the
    // next_comm field of the event.
    repeated uint32 switch_next_comm_index = 6 [packed = true];

    // Delta-encoded timestamps across all sched_waking events within this
    // bundle. The first is absolute, each next one is relative to its
    // predecessor.
    repeated uint64 waking_timestamp = 7 [packed = true];
    repeated int32 waking_pid = 8 [packed = true];
    repeated int32 waking_target_cpu = 9 [packed = true];
    repeated int32 waking_prio = 10 [packed = true];
    // One per event, index into |intern_table| corresponding to the
    // comm field of the event.
    repeated uint32 waking_comm_index = 11 [packed = true];
    repeated uint32 waking_common_flags = 12 [packed = true];
  }
  optional CompactSched compact_sched = 4;

  // Perfetto will by default try to use the boottime ("boot") clock for ftrace
  // timestamps as that counts during suspend, is available to userspace, and
  // is coherent across cpus.
  //
  // If this field is set, it means that a different clock was used during
  // recording. Either because the boot clock is unavailable (e.g. old kernels
  // before 3.x), or the trace config has set an incompatible option
  // (use_monotonic_raw_clock / preserve_ftrace_buffer). In that case,
  // trace_processor will do best-effort clock alignment using timestamp pairs
  // from |ftrace_timestamp| and |boot_timestamp| fields. This field is omitted
  // when the ftrace clock is "boot", as that is the default assumption.
  //
  // Some clocks (local/global) are technically per-cpu, but we make a
  // simplifying assumption that they are global, as their inter-cpu skew
  // should be reasonably bounded on modern systems.
  //
  // Added in: perfetto v19. Android T (13).
  optional FtraceClock ftrace_clock = 5;

  // The timestamp according to the ftrace clock, taken at the same instant as
  // |boot_timestamp|. Note: timestamping is done at buffer read time, so it
  // will be in the future relative to the data covered by this bundle.
  // Implementation note: Populated by reading the 'now ts:' field in
  // tracefs/per_cpu/cpu0/stat.
  //
  // Set only if |ftrace_clock| != FTRACE_CLOCK_UNSPECIFIED.
  optional int64 ftrace_timestamp = 6;

  // The timestamp according to CLOCK_BOOTTIME, taken at the same instant as
  // |ftrace_timestamp|.
  //
  // Set only if |ftrace_clock| != FTRACE_CLOCK_UNSPECIFIED.
  optional int64 boot_timestamp = 7;

  // Errors encountered during parsing of the raw ftrace data. In case of ring
  // buffer layout errors, the parser skips the rest of the offending kernel
  // buffer page and continues from the next page.
  // See also FtraceStats.ftrace_parse_errors, which collates all unique errors
  // seen within the duration of the trace (even if the affected bundles get
  // overwritten in ring buffer mode).
  message FtraceError {
    // Timestamp of the data that we're unable to parse, in the ftrace clock
    // domain. Currently, we use the base timestamp of the tracing page
    // containing the bad record rather than the time of the record itself.
    optional uint64 timestamp = 1;
    optional FtraceParseStatus status = 2;
  }
  repeated FtraceError error = 8;

  // Superseded by |previous_bundle_end_timestamp| in perfetto v47+. The
  // primary difference is that this field tracked the last timestamp read from
  // the per-cpu buffer, while the newer field tracks events that get
  // serialised into the trace.
  // Added in: perfetto v44.
  optional uint64 last_read_event_timestamp = 9;

  // The timestamp (using ftrace clock) of the last event written into this
  // data source on this cpu. In other words: the last event in the previous
  // bundle.
  // Lets the trace processing find an initial timestamp after which ftrace
  // data is known to be valid across all cpus. Of particular importance when
  // the perfetto trace buffer is a ring buffer as well, as the overwriting of
  // oldest bundles can skew the first valid timestamp per cpu significantly.
  // Added in: perfetto v47.
  optional uint64 previous_bundle_end_timestamp = 10;

  // Describes the serialised |FtraceEvent| protos for events not known at
  // compile time, when using the |denser_generic_event_encoding| option.
  // Addded in: perfetto v50.
  message GenericEventDescriptor {
    // submessage id within FtraceEvent described by |event_descriptor|.
    optional int32 field_id = 1;
    // optional: the event's group, e.g. "sched" for "sched/sched_switch".
    // The event name itself is in |event_descriptor.name|.
    optional string group_name = 3;
    // serialised DescriptorProto.
    optional bytes event_descriptor = 2;
  }
  repeated GenericEventDescriptor generic_event_descriptors = 11;

  // Written only on android builds if the config sets |debug_ftrace_abi|.
  // Contains the raw ring buffer tracing page that the implementation could
  // not parse.
  // Addded in: perfetto v50.
  optional bytes broken_abi_trace_page = 512;
}

enum FtraceClock {
  // There is no FTRACE_CLOCK_BOOT entry as that's the default assumption. When
  // the ftrace clock is "boot", it's just omitted (so UNSPECIFIED == BOOT).
  FTRACE_CLOCK_UNSPECIFIED = 0;
  FTRACE_CLOCK_UNKNOWN = 1;
  FTRACE_CLOCK_GLOBAL = 2;
  FTRACE_CLOCK_LOCAL = 3;
  FTRACE_CLOCK_MONO_RAW = 4;
}

// End of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

// Begin of protos/perfetto/trace/generic_kernel/generic_power.proto

// GenericKernelCpuFrequencyEvent is the standard proto to capture CPU
// frequency change events in a generic kernel implementation.
message GenericKernelCpuFrequencyEvent {
  // CPU in which the event occurred.
  optional int32 cpu = 1;
  // Frequency (Hz) of the CPU.
  optional int64 freq_hz = 2;
}

// End of protos/perfetto/trace/generic_kernel/generic_power.proto

// Begin of protos/perfetto/trace/generic_kernel/generic_task.proto

// GenericKernelTaskStateEvent is the standard proto to capture thread state
// change events in a generic kernel implementation. This is mainly for the
// case where scheduler events are not directly supported in the kernel's
// tracing mechanism.
//
// By capturing these task state events Perfetto is able to infer higher-level
// events such as context switches and task waking events, providing as much
// parity as possible with established tracing frameworks such as
// Linux's ftrace.
message GenericKernelTaskStateEvent {
  // CPU in which the event occurred.
  // This field is only relevant with the TASK_STATE_RUNNING state. There is
  // no specific meaning to the cpu field in a non-running state event.
  optional int32 cpu = 1;
  // Command name for the thread.
  optional string comm = 2;
  // Thread id.
  optional int64 tid = 3;

  // TaskStateEnum represents the valid states of a thread.
  // These states are a generic representation of the actual thread state and
  // don't necessarily map one-to-one to the states the actual OS kernel
  // tracks internally.
  //
  // Note: Consecutive TASK_STATE_RUNNING states for the same TID is considered
  // an error resulting in potential data loss.
  enum TaskStateEnum {
    TASK_STATE_UNKNOWN = 0;
    TASK_STATE_CREATED = 1;
    TASK_STATE_RUNNABLE = 2;
    TASK_STATE_RUNNING = 3;
    TASK_STATE_INTERRUPTIBLE_SLEEP = 4;
    TASK_STATE_UNINTERRUPTIBLE_SLEEP = 5;
    TASK_STATE_STOPPED = 6;
    TASK_STATE_DEAD = 7;
    TASK_STATE_DESTROYED = 8;
  }
  // New state of the thread.
  optional TaskStateEnum state = 4;

  // Priority of the thread.
  // This value is OS agnostic and should only be interpreted based on the
  // kernel who emitted the message.
  optional int32 prio = 5;
}

// GenericKernelTaskRenameEvent is the standard proto to capture the renaming
// of a thread.
message GenericKernelTaskRenameEvent {
  // Thread id.
  optional int64 tid = 1;
  // New command name for the thread.
  optional string comm = 2;
}

// Metadata about the processes and threads in the trace.
// The main goal of this proto is to provide a generic kernel
// implementation a mechanism to outline its process structure.
message GenericKernelProcessTree {
  // Representation of a thread.
  message Thread {
    // Thread id.
    optional int64 tid = 1;

    // Id of the parent process.
    optional int64 pid = 2;

    // The command name of the thread.
    optional string comm = 3;

    // True if thread is the main thread.
    optional bool is_main_thread = 4;
  }

  // Representation of a process.
  message Process {
    // Process id.
    optional int64 pid = 1;

    // Parent process id.
    optional int64 ppid = 2;

    // The command line of the process.
    // If the cmdline has spaces in it, then we use the characters from
    // position 0 to the first instance of the space char (' ') as the name
    // of the process. If no spaces are present, then the entire cmdline is
    // used as the name.
    optional string cmdline = 3;
  }

  // List of processes and threads in the kernel. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might not show up at all, if
  // no sched switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{tid: 11, pid: 10}] }
  // #1 { threads: [{tid: 12, pid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{tid: 13, pid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;
}

// End of protos/perfetto/trace/generic_kernel/generic_task.proto

// Begin of protos/perfetto/trace/gpu/gpu_counter_event.proto

message GpuCounterEvent {
  // The first trace packet of each session should include counter_spec.
  optional GpuCounterDescriptor counter_descriptor = 1;

  message GpuCounter {
    // required. Identifier for counter.
    optional uint32 counter_id = 1;
    // required. Value of the counter.
    oneof value {
      int64 int_value = 2;
      double double_value = 3;
    }
  }
  repeated GpuCounter counters = 2;

  // optional. Identifier for GPU in a multi-gpu device.
  optional int32 gpu_id = 3;
}

// End of protos/perfetto/trace/gpu/gpu_counter_event.proto

// Begin of protos/perfetto/trace/gpu/gpu_log.proto

// Message for logging events GPU data producer.
message GpuLog {
  enum Severity {
    LOG_SEVERITY_UNSPECIFIED = 0;
    LOG_SEVERITY_VERBOSE = 1;
    LOG_SEVERITY_DEBUG = 2;
    LOG_SEVERITY_INFO = 3;
    LOG_SEVERITY_WARNING = 4;
    LOG_SEVERITY_ERROR = 5;
  };
  optional Severity severity = 1;

  optional string tag = 2;

  optional string log_message = 3;
}

// End of protos/perfetto/trace/gpu/gpu_log.proto

// Begin of protos/perfetto/trace/gpu/gpu_render_stage_event.proto

// next id: 15
message GpuRenderStageEvent {
  // required. Unique ID for the event.
  optional uint64 event_id = 1;

  // optional. Duration of the event in nanoseconds. If unset, this is a
  // single time point event.
  optional uint64 duration = 2;

  // required. ID to a hardware queue description in the specifications.
  // InternedGpuRenderStageSpecification
  optional uint64 hw_queue_iid = 13;

  // required. ID to a render stage description in the specifications.
  // InternedGpuRenderStageSpecification
  optional uint64 stage_iid = 14;

  // optional. Identifier for GPU in a multi-gpu device.
  optional int32 gpu_id = 11;

  // required. Graphics context for the event.
  // For OpenGL, this is the GL context.
  // For Vulkan, this is the VkDevice.
  optional uint64 context = 5;

  // optional. The render target for this event.
  // For OpenGL, this is the GL frame buffer handle.
  // For Vulkan, this is the VkFrameBuffer handle.
  optional uint64 render_target_handle = 8;

  // optional. Submission ID generated by the UMD.
  // For OpenGL, the ID should map to an API submission (e.g., glFlush,
  // glFinish, eglSwapBufffers) event.  The set of submissions to the HW due
  // to a single API submission should share the same ID.
  // For Vulkan, it should map 1:1 with a vkQueueSubmit.
  optional uint32 submission_id = 10;

  // optional. Additional data for the user. This may include attributes for
  // the event like resource ids, shaders, etc.
  message ExtraData {
    optional string name = 1;
    optional string value = 2;
  }
  repeated ExtraData extra_data = 6;

  // VULKAN SPECIFICS

  // optional. The Vulkan render pass handle.
  optional uint64 render_pass_handle = 9;

  // optional. An ID for the render pass instance. This is used to correlate
  // different events on different queues produced by the same Vulkan render
  // pass instance.
  optional uint64 render_pass_instance_id = 16;

  // optional. A bit mask representing which render subpasses contributed to
  // this render stage event.  Subpass index 0 is represented by setting the
  // LSB of the mask.  Additional mask can be added for subpass index greater
  // than 63.
  repeated uint64 render_subpass_index_mask = 15;

  // optional. The Vulkan command buffer handle.
  optional uint64 command_buffer_handle = 12;

  // DEPRECATED

  // Deprecated.  Use InternedGpuRenderStageSpecification instead.
  // The first trace packet of each session should include a Specifications
  // to enumerate *all* IDs that will be used. The timestamp of this packet
  // must be earlier than all other packets. Only one packet with Specifications
  // is expected.
  message Specifications {
    message ContextSpec {
      optional uint64 context = 1;
      optional int32 pid = 2;
    }
    optional ContextSpec context_spec = 1;

    message Description {
      optional string name = 1;
      optional string description = 2;
    }

    // Labels to categorize the hw Queue this event goes on.
    repeated Description hw_queue = 2;

    // Labels to categorize render stage(binning, render, compute etc).
    repeated Description stage = 3;
  }
  // Deprecated.  Use hw_queue_iid and stage_iid to refer to
  // InternedGpuRenderStageSpecification instead.
  optional Specifications specifications = 7 [deprecated = true];

  // Deprecated. Use hw_queue_iid instead;
  optional int32 hw_queue_id = 3 [deprecated = true];

  // Deprecated. Use stage_iid instead;
  optional int32 stage_id = 4 [deprecated = true];

  // Extension for vendor's custom proto.
  extensions 100;
}

// Interned data.

// The iid is the numeric value of either the GL Context or the VkDevice
// handle.
message InternedGraphicsContext {
  optional uint64 iid = 1;
  optional int32 pid = 2;
  enum Api {
    UNDEFINED = 0;
    OPEN_GL = 1;
    VULKAN = 2;
    OPEN_CL = 3;
  }
  optional Api api = 3;
}

message InternedGpuRenderStageSpecification {
  optional uint64 iid = 1;
  optional string name = 2;
  optional string description = 3;

  enum RenderStageCategory {
    OTHER = 0;
    GRAPHICS = 1;
    COMPUTE = 2;
  }
  optional RenderStageCategory category = 4;
}

// End of protos/perfetto/trace/gpu/gpu_render_stage_event.proto

// Begin of protos/perfetto/trace/gpu/vulkan_api_event.proto

// Message for recording the Vulkan call.
message VulkanApiEvent {
  oneof event {
    VkDebugUtilsObjectName vk_debug_utils_object_name = 1;
    VkQueueSubmit vk_queue_submit = 2;
  }

  // For recording vkSetDebugUtilsObjectNameEXT and
  // vkDebugMarkerSetObjectNameEXT
  message VkDebugUtilsObjectName {
    optional uint32 pid = 1;
    optional uint64 vk_device = 2;
    // VkObjectType.  Value must match
    // https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkObjectType.html.
    optional int32 object_type = 3;
    optional uint64 object = 4;
    optional string object_name = 5;
  }

  // For recording vkQueueSubmit call.
  message VkQueueSubmit {
    optional uint64 duration_ns = 1;
    optional uint32 pid = 2;
    optional uint32 tid = 3;
    optional uint64 vk_queue = 4;
    repeated uint64 vk_command_buffers = 5;
    // Submission ID.  An identifier unique to each vkQueueSubmit call.  This
    // submission_id must match GpuRenderStageEvent.submission_id if the
    // GpuRenderStageEvent is created due to this vkQueueSubmit.
    optional uint32 submission_id = 6;
  }
}

// End of protos/perfetto/trace/gpu/vulkan_api_event.proto

// Begin of protos/perfetto/trace/gpu/vulkan_memory_event.proto

// All the information that cannot be sent within a VulkanMemoryEvent message,
// are sent as annotations to the main memory event. One example is the
// properties of the object that consumes the allocated memory, for example, a
// buffer or an image.
// key_iid and string_iid are both interned strings. Original string value is
// stored in vulkan_memory_keys from
// protos/perfetto/trace/interned_data/interned_data.proto.
message VulkanMemoryEventAnnotation {
  optional uint64 key_iid = 1;
  oneof value {
    int64 int_value = 2;
    double double_value = 3;
    uint64 string_iid = 4;
  }
}

// Each VulkanMemoryEvent encompasses information regarding one single function
// call that results in reserving, binding or freeing host or GPU memory. There
// is a special message type, ANNOTATIONS, which is used to communicate
// information that are not directly related to a memory event, nonetheless are
// essential to understand the memory usage. An example is the size and memory
// types of the memory heaps.
//
// Next reserved id: 10 (up to 15).
// Next id: 21.
message VulkanMemoryEvent {
  enum Source {
    SOURCE_UNSPECIFIED = 0;
    SOURCE_DRIVER = 1;
    SOURCE_DEVICE = 2;
    SOURCE_DEVICE_MEMORY = 3;
    SOURCE_BUFFER = 4;
    SOURCE_IMAGE = 5;
  }

  enum Operation {
    OP_UNSPECIFIED = 0;

    // alloc, create
    OP_CREATE = 1;

    // free, destroy(non-bound)
    OP_DESTROY = 2;

    // bind buffer and image
    OP_BIND = 3;

    // destroy (bound)
    OP_DESTROY_BOUND = 4;

    // only annotations
    OP_ANNOTATIONS = 5;
  }

  enum AllocationScope {
    SCOPE_UNSPECIFIED = 0;
    SCOPE_COMMAND = 1;
    SCOPE_OBJECT = 2;
    SCOPE_CACHE = 3;
    SCOPE_DEVICE = 4;
    SCOPE_INSTANCE = 5;
  }

  optional Source source = 1;
  optional Operation operation = 2;
  optional int64 timestamp = 3;
  optional uint32 pid = 4;
  optional fixed64 memory_address = 5;
  optional uint64 memory_size = 6;
  // Interned string. Original string value is stored in function_names from
  // protos/perfetto/trace/interned_data/interned_data.proto.
  optional uint64 caller_iid = 7;
  optional AllocationScope allocation_scope = 8;
  // Extra related information, e.g., create configs, etc.
  repeated VulkanMemoryEventAnnotation annotations = 9;

  // Field IDs used for device memory (low sampling rate)
  optional fixed64 device = 16;
  optional fixed64 device_memory = 17;
  optional uint32 memory_type = 18;
  optional uint32 heap = 19;
  optional fixed64 object_handle = 20;
}

// End of protos/perfetto/trace/gpu/vulkan_memory_event.proto

// Begin of protos/perfetto/trace/profiling/profile_common.proto

// The interning fields in this file can refer to 2 different intern tables,
// depending on the message they are used in. If the interned fields are present
// in ProfilePacket proto, then the intern tables included in the ProfilePacket
// should be used. If the intered fields are present in the
// StreamingProfilePacket proto, then the intern tables included in all of the
// previous InternedData message with same sequence ID should be used.
// TODO(fmayer): Move to the intern tables to a common location.
message InternedString {
  // Interning key. Starts from 1, 0 is the same as "not set".
  optional uint64 iid = 1;

  // The actual string.
  optional bytes str = 2;
}

// Source line info.
message Line {
  optional string function_name = 1;
  optional string source_file_name = 2;
  optional uint32 line_number = 3;
}

// Symbols for a given address in a module.
message AddressSymbols {
  optional uint64 address = 1;

  // Source lines that correspond to this address.
  //
  // These are repeated because when inlining happens, multiple functions'
  // frames can be at a single address. Imagine function Foo calling the
  // std::vector<int> constructor, which gets inlined at 0xf00. We then get
  // both Foo and the std::vector<int> constructor when we symbolize the
  // address.
  repeated Line lines = 2;
}

// Symbols for addresses seen in a module.
// Used in re-symbolisation of complete traces.
message ModuleSymbols {
  // Fully qualified path to the mapping.
  // E.g. /system/lib64/libc.so.
  optional string path = 1;

  // .note.gnu.build-id on Linux (not hex encoded).
  // uuid on MacOS.
  // Module GUID on Windows.
  optional string build_id = 2;
  repeated AddressSymbols address_symbols = 3;
}

message Mapping {
  // Interning key.
  // Starts from 1, 0 is the same as "not set".
  optional uint64 iid = 1;

  // Interning key.
  // Starts from 1, 0 is the same as "not set".
  optional uint64 build_id = 2;

  // The linker may create multiple memory mappings for the same shared
  // library.
  // This is so that the ELF header is mapped as read only, while the
  // executable memory is mapped as executable only.
  // The details of this depend on the linker, a possible mapping of an ELF
  // file is this:
  //         +----------------------+
  // ELF     |xxxxxxxxxyyyyyyyyyyyyy|
  //         +---------+------------+
  //         |         |
  //         | read    | executable
  //         v mapping v mapping
  //         +----------------------+
  // Memory  |xxxxxxxxx|yyyyyyyyyyyy|
  //         +------------------+---+
  //         ^         ^        ^
  //         +         +        +
  //       start     exact    relpc
  //       offset   offset    0x1800
  //       0x0000   0x1000
  //
  // exact_offset is the offset into the library file of this mapping.
  // start_offset is the offset into the library file of the first mapping
  // for that library. For native libraries (.so files) this should be 0.

  // This is not set on Android 10.
  optional uint64 exact_offset = 8;

  optional uint64 start_offset = 3;
  optional uint64 start = 4;
  optional uint64 end = 5;

  // Libunwindstack-specific concept, not to be confused with bionic linker's
  // notion of load_bias. Needed to correct relative pc addresses (as produced
  // by libunwindstack) when doing offline resymbolisation.
  //
  // For an executable ELF PT_LOAD segment, this is:
  //   p_vaddr - p_offset
  //
  // Where p_offset means that the code is at that offset into the ELF file on
  // disk. While p_vaddr is the offset at which the code gets *mapped*, relative
  // to where the linker loads the ELF into the address space. For most ELFs,
  // the two values are identical and therefore load_bias is zero.
  optional uint64 load_bias = 6;

  // E.g. ["system", "lib64", "libc.so"]
  // id of string.
  repeated uint64 path_string_ids = 7;
}

message Frame {
  // Interning key. Starts from 1, 0 is the same as "not set".
  optional uint64 iid = 1;

  // E.g. "fopen"
  // id of string.
  optional uint64 function_name_id = 2;

  // The mapping in which this frame's instruction pointer resides.
  // iid of Mapping.iid.
  //
  // If set (non-zero), rel_pc MUST also be set. If mapping_id is 0 (not set),
  // this frame has no associated memory mapping (e.g., symbolized frames
  // without address information).
  //
  // Starts from 1, 0 is the same as "not set".
  optional uint64 mapping_id = 3;

  // Instruction pointer relative to the start of the mapping.
  // MUST be set if mapping_id is set (non-zero). Ignored if mapping_id is 0.
  optional uint64 rel_pc = 4;

  // Source file path for this frame.
  // This is typically set during online symbolization when symbol information
  // is available at trace collection time. If not set, source file paths may be
  // added later via offline symbolization (see ModuleSymbols).
  //
  // Starts from 1, 0 is the same as "not set".
  //
  // iid of InternedData.source_paths.
  optional uint64 source_path_iid = 5;

  // Line number in the source file for this frame.
  // This is typically set during online symbolization when symbol information
  // is available at trace collection time. If not set, line numbers may be
  // added later via offline symbolization (see ModuleSymbols).
  optional uint32 line_number = 6;
}

message Callstack {
  // Interning key. Starts from 1, 0 is the same as "not set".
  optional uint64 iid = 1;
  // Frames of this callstack. Bottom frame first.
  repeated uint64 frame_ids = 2;
}

// End of protos/perfetto/trace/profiling/profile_common.proto

// Begin of protos/perfetto/trace/track_event/chrome_histogram_sample.proto

message HistogramName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// An individual histogram sample logged via Chrome's UMA metrics system.
message ChromeHistogramSample {
  // MD5 hash of the metric name. Either |name_hash| or |name|/|name_iid| or
  // both must be present.
  optional uint64 name_hash = 1;
  optional string name = 2;
  optional int64 sample = 3;
  // Interned HistogramName. Only one of |name|, |name_iid| can be set.
  optional uint64 name_iid = 4;
}

// End of protos/perfetto/trace/track_event/chrome_histogram_sample.proto

// Begin of protos/perfetto/trace/track_event/debug_annotation.proto

// Proto representation of untyped key/value annotations provided in TRACE_EVENT
// macros. Users of the Perfetto SDK should prefer to use the
// perfetto::TracedValue API to fill these protos, rather than filling them
// manually.
//
// Debug annotations are intended for debug use and are not considered a stable
// API of the trace contents. Trace-based metrics that use debug annotation
// values are prone to breakage, so please rely on typed TrackEvent fields for
// these instead.
//
// DebugAnnotations support nested arrays and dictionaries. Each entry is
// encoded as a single DebugAnnotation message. Only dictionary entries
// set the "name" field. The TrackEvent message forms an implicit root
// dictionary.
//
// Example TrackEvent with nested annotations:
//   track_event {
//     debug_annotations {
//       name: "foo"
//       dict_entries {
//         name: "a"
//         bool_value: true
//       }
//       dict_entries {
//         name: "b"
//         int_value: 123
//       }
//     }
//     debug_annotations {
//       name: "bar"
//       array_values {
//         string_value: "hello"
//       }
//       array_values {
//         string_value: "world"
//       }
//     }
//   }
//
// Next ID: 18.
// Reserved ID: 15
message DebugAnnotation {
  // Name fields are set only for dictionary entries.
  oneof name_field {
    // interned DebugAnnotationName.
    uint64 name_iid = 1;
    // non-interned variant.
    string name = 10;
  }

  oneof value {
    bool bool_value = 2;
    uint64 uint_value = 3;
    int64 int_value = 4;
    double double_value = 5;
    // Pointers are stored in a separate type as the JSON output treats them
    // differently from other uint64 values.
    uint64 pointer_value = 7;

    // Deprecated. Use dict_entries / array_values instead.
    NestedValue nested_value = 8;

    // Legacy instrumentation may not support conversion of nested data to
    // NestedValue yet.
    string legacy_json_value = 9;

    // interned and non-interned variants of strings.
    string string_value = 6;
    // Corresponds to |debug_annotation_string_values| field in InternedData.
    uint64 string_value_iid = 17;
  }

  // Used to embed arbitrary proto messages (which are also typically used to
  // represent typed TrackEvent arguments). |proto_type_name| or
  // |proto_type_name_iid| are storing the full name of the proto messages (e.g.
  // .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
  // proto messages. See |TracedValue::WriteProto| for more details.
  oneof proto_type_descriptor {
    string proto_type_name = 16;
    // interned DebugAnnotationValueTypeName.
    uint64 proto_type_name_iid = 13;
  }
  optional bytes proto_value = 14;

  repeated DebugAnnotation dict_entries = 11;
  repeated DebugAnnotation array_values = 12;

  // Deprecated legacy way to use nested values. Only kept for
  // backwards-compatibility in TraceProcessor. May be removed in the future -
  // code filling protos should use |dict_entries| and |array_values| instead.
  message NestedValue {
    enum NestedType {
      // leaf value.
      UNSPECIFIED = 0;
      DICT = 1;
      ARRAY = 2;
    }
    optional NestedType nested_type = 1;

    repeated string dict_keys = 2;
    repeated NestedValue dict_values = 3;
    repeated NestedValue array_values = 4;
    optional int64 int_value = 5;
    optional double double_value = 6;
    optional bool bool_value = 7;
    optional string string_value = 8;
  }
}

// --------------------
// Interned data types:
// --------------------

message DebugAnnotationName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// See the |proto_type_descriptor| comment.
message DebugAnnotationValueTypeName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/debug_annotation.proto

// Begin of protos/perfetto/trace/track_event/log_message.proto

message LogMessage {
  // interned SourceLocation.
  optional uint64 source_location_iid = 1;
  // interned LogMessageBody.
  optional uint64 body_iid = 2;
  enum Priority {
    PRIO_UNSPECIFIED = 0;
    PRIO_UNUSED = 1;
    PRIO_VERBOSE = 2;
    PRIO_DEBUG = 3;
    PRIO_INFO = 4;
    PRIO_WARN = 5;
    PRIO_ERROR = 6;
    PRIO_FATAL = 7;
  }
  optional Priority prio = 3;
}

// --------------------
// Interned data types:
// --------------------

message LogMessageBody {
  optional uint64 iid = 1;
  optional string body = 2;
}

// End of protos/perfetto/trace/track_event/log_message.proto

// Begin of protos/perfetto/trace/track_event/source_location.proto

// --------------------
// Interned data types:
// --------------------

// A source location, represented as a native symbol.
// This is similar to `message Frame` from
// protos/perfetto/trace/profiling/profile_common.proto, but for abitrary
// source code locations (for example in track event args), not stack frames.
message UnsymbolizedSourceLocation {
  optional uint64 iid = 1;
  optional uint64 mapping_id = 2;
  optional uint64 rel_pc = 3;
}

message SourceLocation {
  optional uint64 iid = 1;
  optional string file_name = 2;
  optional string function_name = 3;
  optional uint32 line_number = 4;
}

// End of protos/perfetto/trace/track_event/source_location.proto

// Begin of protos/perfetto/trace/track_event/chrome_active_processes.proto

// A list of processes connected to the tracing service.
message ChromeActiveProcesses {
  repeated int32 pid = 1;
}
// End of protos/perfetto/trace/track_event/chrome_active_processes.proto

// Begin of protos/perfetto/trace/track_event/chrome_application_state_info.proto

// Trace event arguments for application state changes.
message ChromeApplicationStateInfo {
  // Enum definition taken from:
  // https://source.chromium.org/chromium/chromium/src/+/master:base/android/application_status_listener.h
  enum ChromeApplicationState {
    APPLICATION_STATE_UNKNOWN = 0;
    APPLICATION_STATE_HAS_RUNNING_ACTIVITIES = 1;
    APPLICATION_STATE_HAS_PAUSED_ACTIVITIES = 2;
    APPLICATION_STATE_HAS_STOPPED_ACTIVITIES = 3;
    APPLICATION_STATE_HAS_DESTROYED_ACTIVITIES = 4;
  };
  optional ChromeApplicationState application_state = 1;
}

// End of protos/perfetto/trace/track_event/chrome_application_state_info.proto

// Begin of protos/perfetto/trace/track_event/chrome_compositor_scheduler_state.proto

// Describes Chrome's Compositor scheduler's current state and associated
// variables.
//
// These protos and enums were adapted from the corresponding original JSON
// trace event for the scheduler state. In contrast to the JSON, we use strongly
// typed enum values instead of strings for many fields, and
// microsecond-granularity timestamps.
//
// The original format was generated in JSON by the code at
// https://cs.chromium.org/chromium/src/cc/scheduler/scheduler.cc?l=870&rcl=5e15eabc9c0eec8daf94fdf78e93f13b6e3b63dd
//
// And is now generated as protozero:
// https://cs.chromium.org/chromium/src/cc/scheduler/scheduler.cc?q=Scheduler::AsPro
//
// All non-delta-timestamps are absolute CLOCK_MONOTONIC timestamps.

enum ChromeCompositorSchedulerAction {
  CC_SCHEDULER_ACTION_UNSPECIFIED = 0;
  CC_SCHEDULER_ACTION_NONE = 1;
  CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME = 2;
  CC_SCHEDULER_ACTION_COMMIT = 3;
  CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE = 4;
  CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE = 5;
  CC_SCHEDULER_ACTION_DRAW_FORCED = 6;
  CC_SCHEDULER_ACTION_DRAW_ABORT = 7;
  CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION = 8;
  CC_SCHEDULER_ACTION_PREPARE_TILES = 9;
  CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK = 10;
  CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION = 11;
  CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL = 12;
  CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON = 13;
}

// Next id: 18
message ChromeCompositorSchedulerState {
  enum BeginImplFrameDeadlineMode {
    DEADLINE_MODE_UNSPECIFIED = 0;
    DEADLINE_MODE_NONE = 1;
    DEADLINE_MODE_IMMEDIATE = 2;
    DEADLINE_MODE_REGULAR = 3;
    DEADLINE_MODE_LATE = 4;
    DEADLINE_MODE_BLOCKED = 5;
  }
  optional ChromeCompositorStateMachine state_machine = 1;
  optional bool observing_begin_frame_source = 2;
  optional bool begin_impl_frame_deadline_task = 3;
  optional bool pending_begin_frame_task = 4;
  optional bool skipped_last_frame_missed_exceeded_deadline = 5;
  optional ChromeCompositorSchedulerAction inside_action = 7;
  optional BeginImplFrameDeadlineMode deadline_mode = 8;
  optional int64 deadline_us = 9;
  optional int64 deadline_scheduled_at_us = 10;
  optional int64 now_us = 11;
  optional int64 now_to_deadline_delta_us = 12;
  optional int64 now_to_deadline_scheduled_at_delta_us = 13;
  optional BeginImplFrameArgs begin_impl_frame_args = 14;
  optional BeginFrameObserverState begin_frame_observer_state = 15;
  optional BeginFrameSourceState begin_frame_source_state = 16;
  optional CompositorTimingHistory compositor_timing_history = 17;

  reserved 6;
}

// Describes the current values stored in the Chrome Compositor state machine.
// Next id: 3
message ChromeCompositorStateMachine {
  // Next id: 6
  message MajorState {
    enum BeginImplFrameState {
      BEGIN_IMPL_FRAME_UNSPECIFIED = 0;
      BEGIN_IMPL_FRAME_IDLE = 1;
      BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME = 2;
      BEGIN_IMPL_FRAME_INSIDE_DEADLINE = 3;
    }
    enum BeginMainFrameState {
      BEGIN_MAIN_FRAME_UNSPECIFIED = 0;
      BEGIN_MAIN_FRAME_IDLE = 1;
      BEGIN_MAIN_FRAME_SENT = 2;
      BEGIN_MAIN_FRAME_READY_TO_COMMIT = 3;
    }
    enum LayerTreeFrameSinkState {
      LAYER_TREE_FRAME_UNSPECIFIED = 0;
      LAYER_TREE_FRAME_NONE = 1;
      LAYER_TREE_FRAME_ACTIVE = 2;
      LAYER_TREE_FRAME_CREATING = 3;
      LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT = 4;
      LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION = 5;
    }
    enum ForcedRedrawOnTimeoutState {
      FORCED_REDRAW_UNSPECIFIED = 0;
      FORCED_REDRAW_IDLE = 1;
      FORCED_REDRAW_WAITING_FOR_COMMIT = 2;
      FORCED_REDRAW_WAITING_FOR_ACTIVATION = 3;
      FORCED_REDRAW_WAITING_FOR_DRAW = 4;
    }
    optional ChromeCompositorSchedulerAction next_action = 1;
    optional BeginImplFrameState begin_impl_frame_state = 2;
    optional BeginMainFrameState begin_main_frame_state = 3;
    optional LayerTreeFrameSinkState layer_tree_frame_sink_state = 4;
    optional ForcedRedrawOnTimeoutState forced_redraw_state = 5;
  }
  optional MajorState major_state = 1;

  // Next id: 47
  message MinorState {
    enum TreePriority {
      TREE_PRIORITY_UNSPECIFIED = 0;
      TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES = 1;
      TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY = 2;
      TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY = 3;
    }
    enum ScrollHandlerState {
      SCROLL_HANDLER_UNSPECIFIED = 0;
      SCROLL_AFFECTS_SCROLL_HANDLER = 1;
      SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER = 2;
    }
    optional int32 commit_count = 1;
    optional int32 current_frame_number = 2;
    optional int32 last_frame_number_submit_performed = 3;
    optional int32 last_frame_number_draw_performed = 4;
    optional int32 last_frame_number_begin_main_frame_sent = 5;
    optional bool did_draw = 6;
    optional bool did_send_begin_main_frame_for_current_frame = 7;
    optional bool did_notify_begin_main_frame_not_expected_until = 8;
    optional bool did_notify_begin_main_frame_not_expected_soon = 9;
    optional bool wants_begin_main_frame_not_expected = 10;
    optional bool did_commit_during_frame = 11;
    optional bool did_invalidate_layer_tree_frame_sink = 12;
    optional bool did_perform_impl_side_invalidaion = 13;
    optional bool did_prepare_tiles = 14;
    optional int32 consecutive_checkerboard_animations = 15;
    optional int32 pending_submit_frames = 16;
    optional int32 submit_frames_with_current_layer_tree_frame_sink = 17;
    optional bool needs_redraw = 18;
    optional bool needs_prepare_tiles = 19;
    optional bool needs_begin_main_frame = 20;
    optional bool needs_one_begin_impl_frame = 21;
    optional bool visible = 22;
    optional bool begin_frame_source_paused = 23;
    optional bool can_draw = 24;
    optional bool resourceless_draw = 25;
    optional bool has_pending_tree = 26;
    optional bool pending_tree_is_ready_for_activation = 27;
    optional bool active_tree_needs_first_draw = 28;
    optional bool active_tree_is_ready_to_draw = 29;
    optional bool did_create_and_initialize_first_layer_tree_frame_sink = 30;
    optional TreePriority tree_priority = 31;
    optional ScrollHandlerState scroll_handler_state = 32;
    optional bool critical_begin_main_frame_to_activate_is_fast = 33;
    optional bool main_thread_missed_last_deadline = 34;
    optional bool video_needs_begin_frames = 36;
    optional bool defer_begin_main_frame = 37;
    optional bool last_commit_had_no_updates = 38;
    optional bool did_draw_in_last_frame = 39;
    optional bool did_submit_in_last_frame = 40;
    optional bool needs_impl_side_invalidation = 41;
    optional bool current_pending_tree_is_impl_side = 42;
    optional bool previous_pending_tree_was_impl_side = 43;
    optional bool processing_animation_worklets_for_active_tree = 44;
    optional bool processing_animation_worklets_for_pending_tree = 45;
    optional bool processing_paint_worklets_for_pending_tree = 46;

    reserved 35;
  }
  optional MinorState minor_state = 2;
}

// Next id: 13
message BeginFrameArgs {
  // JSON format has a "type" field that was always just "BeginFrameArgs" we
  // drop this in the proto representation, and instead make the JSON format
  // "subtype" field become the type field.
  enum BeginFrameArgsType {
    BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED = 0;
    BEGIN_FRAME_ARGS_TYPE_INVALID = 1;
    BEGIN_FRAME_ARGS_TYPE_NORMAL = 2;
    BEGIN_FRAME_ARGS_TYPE_MISSED = 3;
  }
  optional BeginFrameArgsType type = 1;
  optional uint64 source_id = 2;
  optional uint64 sequence_number = 3;
  optional int64 frame_time_us = 4;
  optional int64 deadline_us = 5;
  optional int64 interval_delta_us = 6;
  optional bool on_critical_path = 7;
  optional bool animate_only = 8;
  oneof created_from {
    // The interned SourceLocation.
    uint64 source_location_iid = 9;
    // The SourceLocation that this args was created from.
    // TODO(nuskos): Eventually we will support interning inside of
    // TypedArgument TraceEvents and then we shouldn't need this SourceLocation
    // since we can emit it as part of the InternedData message. When we can
    // remove this |source_location|.
    SourceLocation source_location = 10;
  }
  optional int64 frames_throttled_since_last = 12;
}

// Next id: 7
message BeginImplFrameArgs {
  optional int64 updated_at_us = 1;
  optional int64 finished_at_us = 2;
  enum State {
    BEGIN_FRAME_FINISHED = 0;
    BEGIN_FRAME_USING = 1;
  }
  optional State state = 3;
  oneof args {
    // Only set if |state| is BEGIN_FRAME_FINISHED.
    BeginFrameArgs current_args = 4;
    // Only set if |state| is BEGIN_FRAME_USING.
    BeginFrameArgs last_args = 5;
  }
  message TimestampsInUs {
    optional int64 interval_delta = 1;
    optional int64 now_to_deadline_delta = 2;
    optional int64 frame_time_to_now_delta = 3;
    optional int64 frame_time_to_deadline_delta = 4;
    optional int64 now = 5;
    optional int64 frame_time = 6;
    optional int64 deadline = 7;
  }
  optional TimestampsInUs timestamps_in_us = 6;
}

message BeginFrameObserverState {
  optional int64 dropped_begin_frame_args = 1;
  optional BeginFrameArgs last_begin_frame_args = 2;
}

message BeginFrameSourceState {
  optional uint32 source_id = 1;
  optional bool paused = 2;
  optional uint32 num_observers = 3;
  optional BeginFrameArgs last_begin_frame_args = 4;
}

message CompositorTimingHistory {
  optional int64 begin_main_frame_queue_critical_estimate_delta_us = 1;
  optional int64 begin_main_frame_queue_not_critical_estimate_delta_us = 2;
  optional int64 begin_main_frame_start_to_ready_to_commit_estimate_delta_us =
      3;
  optional int64 commit_to_ready_to_activate_estimate_delta_us = 4;
  optional int64 prepare_tiles_estimate_delta_us = 5;
  optional int64 activate_estimate_delta_us = 6;
  optional int64 draw_estimate_delta_us = 7;
}

// End of protos/perfetto/trace/track_event/chrome_compositor_scheduler_state.proto

// Begin of protos/perfetto/trace/track_event/chrome_content_settings_event_info.proto

// Details about ContentSettings trace events.
message ChromeContentSettingsEventInfo {
  // The number of user defined hostname patterns for content settings at
  // browser start. Similar to UMA histogram
  // 'ContentSettings.NumberOfExceptions'.
  optional uint32 number_of_exceptions = 1;
}
// End of protos/perfetto/trace/track_event/chrome_content_settings_event_info.proto

// Begin of protos/perfetto/trace/track_event/chrome_frame_reporter.proto

// DEPRECATED. Only kept for backwards compatibility. Use |ChromeFrameReporter2|
// in
// https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
// instead.
message ChromeFrameReporter {
  option deprecated = true;

  enum State {
    // The frame did not have any updates to present.
    STATE_NO_UPDATE_DESIRED = 0;

    // The frame presented all the desired updates (i.e. any updates requested
    // from both the compositor thread and main-threads were handled).
    STATE_PRESENTED_ALL = 1;

    // The frame was presented with some updates, but also missed some updates
    // (e.g. missed updates from the main-thread, but included updates from the
    // compositor thread).
    STATE_PRESENTED_PARTIAL = 2;

    // The frame was dropped, i.e. some updates were desired for the frame, but
    // was not presented.
    STATE_DROPPED = 3;
  };

  optional State state = 1;

  enum FrameDropReason {
    REASON_UNSPECIFIED = 0;

    // Frame was dropped by the display-compositor.
    // The display-compositor may drop a frame some times (e.g. the frame missed
    // the deadline, or was blocked on surface-sync, etc.)
    REASON_DISPLAY_COMPOSITOR = 1;

    // Frame was dropped because of the main-thread.
    // The main-thread may cause a frame to be dropped, e.g. if the main-thread
    // is running expensive javascript, or doing a lot of layout updates, etc.
    REASON_MAIN_THREAD = 2;

    // Frame was dropped by the client compositor.
    // The client compositor can drop some frames too (e.g. attempting to
    // recover latency, missing the deadline, etc.).
    REASON_CLIENT_COMPOSITOR = 3;
  };

  // The reason is set only if |state| is not |STATE_UPDATED_ALL|.
  optional FrameDropReason reason = 2;

  optional uint64 frame_source = 3;
  optional uint64 frame_sequence = 4;

  // If this is a droped frame (i.e. if |state| is set to |STATE_DROPPED| or
  // |STATE_PRESENTED_PARTIAL|), then indicates whether this frame impacts
  // smoothness.
  optional bool affects_smoothness = 5;

  enum ScrollState {
    SCROLL_NONE = 0;
    SCROLL_MAIN_THREAD = 1;
    SCROLL_COMPOSITOR_THREAD = 2;
    SCROLL_RASTER = 3;

    // Used when it can't be determined whether a scroll is in progress or not.
    SCROLL_UNKNOWN = 4;
  }

  // The type of active scroll.
  optional ScrollState scroll_state = 6;

  // If any main thread animation is active during this frame.
  optional bool has_main_animation = 7;
  // If any compositor thread animation is active during this frame.
  optional bool has_compositor_animation = 8;
  // If any touch-driven UX (not scroll) is active during this frame.
  optional bool has_smooth_input_main = 9;

  // Whether the frame contained any missing content (i.e. whether there was
  // checkerboarding in the frame).  If has_missing_content,
  // checkerboarded_needs_raster and checkerboarded_needs_record all have
  // values, has_missing_content should equal checkerboarded_needs_raster ||
  // checkerboarded_needs_record.
  optional bool has_missing_content = 10;

  // The id of layer_tree_host that the frame has been produced for.
  optional uint64 layer_tree_host_id = 11;

  // If total latency of PipelineReporter exceeds a certain limit.
  optional bool has_high_latency = 12;

  enum FrameType {
    FORKED = 0;
    BACKFILL = 1;
  }

  // Indicate if the frame is "FORKED" (i.e. a PipelineReporter event starts at
  // the same frame sequence as another PipelineReporter) or "BACKFILL"
  // (i.e. dropped frames when there are no partial compositor updates).
  optional FrameType frame_type = 13;

  // The breakdown stage of PipelineReporter that is most likely accountable for
  // high latency.
  repeated string high_latency_contribution_stage = 14;

  // Whether the frame contained any content that is not fully rastered.
  optional bool checkerboarded_needs_raster = 15;

  // Whether the frame contained any content that is not fully recorded.
  optional bool checkerboarded_needs_record = 16;

  // viz::BeginFrameArgs.trace_id of the frame (before surface aggregation). See
  // also ChromeTrackEvent.EventLatency.surface_frame_trace_id.
  optional int64 surface_frame_trace_id = 17;

  // gfx::PresentationFeedback.display_trace_id of the frame (after surface
  // aggregation). See also ChromeTrackEvent.EventLatency.display_trace_id.
  optional int64 display_trace_id = 18;
}

// End of protos/perfetto/trace/track_event/chrome_frame_reporter.proto

// Begin of protos/perfetto/trace/track_event/chrome_keyed_service.proto

// Details about one of Chrome's keyed services associated with the event.
message ChromeKeyedService {
  // Name of the service, e.g. "MediaRouter", "PreviewsService", etc. (in
  // Chrome, these are static strings known at compile time).
  optional string name = 1;
}

// End of protos/perfetto/trace/track_event/chrome_keyed_service.proto

// Begin of protos/perfetto/trace/track_event/chrome_latency_info.proto

message ChromeLatencyInfo {
  optional int64 trace_id = 1;

  // NEXT ID: 12
  // All step are optional but the enum is ordered (not by number) below in the
  // order we expect them to appear if they are emitted in trace in a blocking
  // fashion.
  enum Step {
    STEP_UNSPECIFIED = 0;
    // Emitted on the browser main thread.
    STEP_SEND_INPUT_EVENT_UI = 3;
    // Happens on the renderer's compositor.
    STEP_HANDLE_INPUT_EVENT_IMPL = 5;
    STEP_DID_HANDLE_INPUT_AND_OVERSCROLL = 8;
    // Occurs on the Renderer's main thread.
    STEP_HANDLE_INPUT_EVENT_MAIN = 4;
    STEP_MAIN_THREAD_SCROLL_UPDATE = 2;
    STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT = 1;
    // Could be emitted on both the renderer's main OR compositor.
    STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL = 9;
    // Optionally sometimes HANDLED_INPUT_EVENT_MAIN_OR_IMPL will proxy to the
    // renderer's compositor and this will be emitted.
    STEP_HANDLED_INPUT_EVENT_IMPL = 10;
    // Renderer's compositor.
    STEP_SWAP_BUFFERS = 6;
    // Happens on the VizCompositor in the GPU process.
    STEP_DRAW_AND_SWAP = 7;
    // Happens on the GPU main thread after the swap has completed.
    STEP_FINISHED_SWAP_BUFFERS = 11;
    // See above for NEXT ID, enum steps are not ordered by tag number.
  };

  optional Step step = 2;
  optional int32 frame_tree_node_id = 3;

  // This enum is a copy of LatencyComponentType enum in Chrome, located in
  // ui/latency/latency_info.h, modulo added UNKNOWN value per protobuf
  // practices.
  enum LatencyComponentType {
    COMPONENT_UNSPECIFIED = 0;
    COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH = 1;
    COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL = 2;
    COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL = 3;
    COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL = 4;
    COMPONENT_INPUT_EVENT_LATENCY_UI = 5;
    COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN = 6;
    COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN = 7;
    COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL = 8;
    COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT = 9;
    COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH = 10;
    COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP = 11;
    COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME = 12;
    COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER = 13;
    COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP = 14;
  }

  message ComponentInfo {
    optional LatencyComponentType component_type = 1;

    // Microsecond timestamp in CLOCK_MONOTONIC domain
    optional uint64 time_us = 2;
  };

  repeated ComponentInfo component_info = 4;
  optional bool is_coalesced = 5;
  optional int64 gesture_scroll_id = 6;
  optional int64 touch_id = 7;

  enum InputType {
    UNSPECIFIED_OR_OTHER = 0;
    TOUCH_MOVED = 1;
    GESTURE_SCROLL_BEGIN = 2;
    GESTURE_SCROLL_UPDATE = 3;
    GESTURE_SCROLL_END = 4;
    GESTURE_TAP = 5;
    GESTURE_TAP_CANCEL = 6;
  }

  // The type of input corresponding to this `ChromeLatencyInfo`.
  optional InputType input_type = 8;
}

// End of protos/perfetto/trace/track_event/chrome_latency_info.proto

// Begin of protos/perfetto/trace/track_event/chrome_legacy_ipc.proto

// Details about a legacy Chrome IPC message that is either sent by the event.
// TODO(eseckler): Also use this message on the receiving side?
message ChromeLegacyIpc {
  enum MessageClass {
    CLASS_UNSPECIFIED = 0;
    CLASS_AUTOMATION = 1;
    CLASS_FRAME = 2;
    CLASS_PAGE = 3;
    CLASS_VIEW = 4;
    CLASS_WIDGET = 5;
    CLASS_INPUT = 6;
    CLASS_TEST = 7;
    CLASS_WORKER = 8;
    CLASS_NACL = 9;
    CLASS_GPU_CHANNEL = 10;
    CLASS_MEDIA = 11;
    CLASS_PPAPI = 12;
    CLASS_CHROME = 13;
    CLASS_DRAG = 14;
    CLASS_PRINT = 15;
    CLASS_EXTENSION = 16;
    CLASS_TEXT_INPUT_CLIENT = 17;
    CLASS_BLINK_TEST = 18;
    CLASS_ACCESSIBILITY = 19;
    CLASS_PRERENDER = 20;
    CLASS_CHROMOTING = 21;
    CLASS_BROWSER_PLUGIN = 22;
    CLASS_ANDROID_WEB_VIEW = 23;
    CLASS_NACL_HOST = 24;
    CLASS_ENCRYPTED_MEDIA = 25;
    CLASS_CAST = 26;
    CLASS_GIN_JAVA_BRIDGE = 27;
    CLASS_CHROME_UTILITY_PRINTING = 28;
    CLASS_OZONE_GPU = 29;
    CLASS_WEB_TEST = 30;
    CLASS_NETWORK_HINTS = 31;
    CLASS_EXTENSIONS_GUEST_VIEW = 32;
    CLASS_GUEST_VIEW = 33;
    CLASS_MEDIA_PLAYER_DELEGATE = 34;
    CLASS_EXTENSION_WORKER = 35;
    CLASS_SUBRESOURCE_FILTER = 36;
    CLASS_UNFREEZABLE_FRAME = 37;
  }

  // Corresponds to the message class type defined in Chrome's IPCMessageStart
  // enum, e.g. FrameMsgStart,
  optional MessageClass message_class = 1;

  // Line number of the message definition. See Chrome's IPC_MESSAGE_ID and
  // IPC_MESSAGE_START macros.
  optional uint32 message_line = 2;
}

// End of protos/perfetto/trace/track_event/chrome_legacy_ipc.proto

// Begin of protos/perfetto/trace/track_event/chrome_message_pump.proto

// Details about Chrome message pump events
message ChromeMessagePump {
  // True if there are sent messages in the queue.
  optional bool sent_messages_in_queue = 1;
  // Interned SourceLocation of IO handler that MessagePumpForIO is about to
  // invoke.
  optional uint64 io_handler_location_iid = 2;
}

// End of protos/perfetto/trace/track_event/chrome_message_pump.proto

// Begin of protos/perfetto/trace/track_event/chrome_mojo_event_info.proto

// Contains information to identify mojo handling events. The trace events in
// mojo are common for all mojo interfaces and this information is used to
// identify who is the caller or callee.
message ChromeMojoEventInfo {
  // Contains the interface name or the file name of the creator of a mojo
  // handle watcher, recorded when an event if notified to the watcher. The code
  // that runs within the track event belongs to the interface.
  optional string watcher_notify_interface_tag = 1;

  // The hash of the IPC message that is being handled.
  optional uint32 ipc_hash = 2;

  // A static string representing the mojo interface name of the message that is
  // being handled.
  optional string mojo_interface_tag = 3;

  // Refers to an interned UnsymbolizedSourceLocation.
  // The UnsymbolizedSourceLocation contains the interface method that's being
  // handled, represented as a native symbol.
  // The native symbol can be symbolized after the trace is recorded.
  // Not using a symbolized source location for official Chromium builds to
  // reduce binary size - emitting file/function names as strings into the
  // trace requires storing them in the binary, which causes a significant
  // binary size bloat for Chromium.
  optional uint64 mojo_interface_method_iid = 4;

  // Indicate whether this is a message or reply.
  optional bool is_reply = 5;

  // The payload size of the message being sent through mojo messages.
  optional uint64 payload_size = 6;

  // Represents the size of the message. Includes all headers and user payload.
  optional uint64 data_num_bytes = 7;
}

// End of protos/perfetto/trace/track_event/chrome_mojo_event_info.proto

// Begin of protos/perfetto/trace/track_event/chrome_renderer_scheduler_state.proto

// Describes the state of the RendererScheduler for a given Renderer Process.

// RAIL Mode is an indication of the kind of work that a Renderer is currently
// performing which is in turn used to prioritise work accordingly.
// A fuller description of these modes can be found https://web.dev/rail/
enum ChromeRAILMode {
  RAIL_MODE_NONE = 0;
  RAIL_MODE_RESPONSE = 1;
  RAIL_MODE_ANIMATION = 2;
  RAIL_MODE_IDLE = 3;
  RAIL_MODE_LOAD = 4;
}

message ChromeRendererSchedulerState {
  optional ChromeRAILMode rail_mode = 1;

  optional bool is_backgrounded = 2;
  optional bool is_hidden = 3;
}

// End of protos/perfetto/trace/track_event/chrome_renderer_scheduler_state.proto

// Begin of protos/perfetto/trace/track_event/chrome_user_event.proto

// Details about a UI interaction initiated by the user, such as opening or
// closing a tab or a context menu.
message ChromeUserEvent {
  // Name of the action, e.g. "NewTab", "ShowBookmarkManager", etc. (in
  // Chrome, these are usually static strings known at compile time, or
  // concatenations of multiple such static strings).
  optional string action = 1;

  // MD5 hash of the action string.
  optional uint64 action_hash = 2;
}

// End of protos/perfetto/trace/track_event/chrome_user_event.proto

// Begin of protos/perfetto/trace/track_event/chrome_window_handle_event_info.proto

// Details about HWNDMessageHandler trace events.
message ChromeWindowHandleEventInfo {
  optional uint32 dpi = 1;
  optional uint32 message_id = 2;
  optional fixed64 hwnd_ptr = 3;
}

// End of protos/perfetto/trace/track_event/chrome_window_handle_event_info.proto

// Begin of protos/perfetto/trace/track_event/screenshot.proto

message Screenshot {
  optional bytes jpg_image = 1;
}

// End of protos/perfetto/trace/track_event/screenshot.proto

// Begin of protos/perfetto/trace/track_event/task_execution.proto

// TrackEvent arguments describing the execution of a task.
message TaskExecution {
  // Source location that the task was posted from.
  // interned SourceLocation.
  optional uint64 posted_from_iid = 1;
}
// End of protos/perfetto/trace/track_event/task_execution.proto

// Begin of protos/perfetto/trace/track_event/track_event.proto

// NOTE: Full TrackEvent support in the client lib and chrome is WIP, thus these
// protos are still subject to change. Don't depend on them staying as they are.

// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
// which describe activity on a track, such as a thread or asynchronous event
// track. The track is specified using separate TrackDescriptor messages and
// referred to via the track's UUID.
//
// A simple TrackEvent packet specifies a timestamp, category, name and type:
// ```protobuf
//   trace_packet {
//     timestamp: 1000
//     track_event {
//       categories: ["my_cat"]
//       name: "my_event"
//       type: TYPE_INSTANT
//      }
//    }
// ```
//
// To associate an event with a custom track (e.g. a thread), the track is
// defined in a separate packet and referred to from the TrackEvent by its UUID:
// ```protobuf
//   trace_packet {
//     track_descriptor {
//       track_uuid: 1234
//       name: "my_track"
//
//       // Optionally, associate the track with a thread.
//       thread_descriptor {
//         pid: 10
//         tid: 10
//         ..
//       }
//     }
//   }
// ```
//
// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
//
// ```protobuf
//   trace_packet {
//     timestamp: 1200
//     track_event {
//       track_uuid: 1234
//       categories: ["my_cat"]
//       name: "my_slice"
//       type: TYPE_SLICE_BEGIN
//     }
//   }
//   trace_packet {
//     timestamp: 1400
//     track_event {
//       track_uuid: 1234
//       type: TYPE_SLICE_END
//     }
//   }
// ```
// TrackEvents also support optimizations to reduce data repetition and encoded
// data size, e.g. through data interning (names, categories, ...) and delta
// encoding of timestamps/counters. For details, see the InternedData message.
// Further, default values for attributes of events on the same sequence (e.g.
// their default track association) can be emitted as part of a
// TrackEventDefaults message.
//
// Next reserved id: 13 (up to 15). Next id: 57.
message TrackEvent {
  // Names of categories of the event. In the client library, categories are a
  // way to turn groups of individual events on or off.
  // interned EventCategoryName.
  repeated uint64 category_iids = 3;
  // non-interned variant.
  repeated string categories = 22;

  // Optional name of the event for its display in trace viewer. May be left
  // unspecified for events with typed arguments.
  //
  // Note that metrics should not rely on event names, as they are prone to
  // changing. Instead, they should use typed arguments to identify the events
  // they are interested in.
  oneof name_field {
    // interned EventName.
    uint64 name_iid = 10;
    // non-interned variant.
    string name = 23;
  }

  // TODO(eseckler): Support using binary symbols for category/event names.

  // Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
  enum Type {
    TYPE_UNSPECIFIED = 0;

    // Slice events are events that have a begin and end timestamp, i.e. a
    // duration. They can be nested similar to a callstack: If, on the same
    // track, event B begins after event A, but before A ends, B is a child
    // event of A and will be drawn as a nested event underneath A in the UI.
    // Note that child events should always end before their parents (e.g. B
    // before A).
    //
    // Each slice event is formed by a pair of BEGIN + END events. The END event
    // does not need to repeat any TrackEvent fields it has in common with its
    // corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
    // END pair will be merged during trace import.
    //
    // Note that we deliberately chose not to support COMPLETE events (which
    // would specify a duration directly) since clients would need to delay
    // writing them until the slice is completed, which can result in reordered
    // events in the trace and loss of unfinished events at the end of a trace.
    TYPE_SLICE_BEGIN = 1;
    TYPE_SLICE_END = 2;

    // Instant events are nestable events without duration. They can be children
    // of slice events on the same track.
    TYPE_INSTANT = 3;

    // Event that provides a value for a counter track. |track_uuid| should
    // refer to a counter track and |counter_value| set to the new value. Note
    // that most other TrackEvent fields (e.g. categories, name, ..) are not
    // supported for TYPE_COUNTER events. See also CounterDescriptor.
    TYPE_COUNTER = 4;
  }
  optional Type type = 9;

  // Identifies the track of the event. The default value may be overridden
  // using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
  // sequence (in most cases sequence = one thread). If no value is specified
  // here or in TrackEventDefaults, the TrackEvent will be associated with an
  // implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
  optional uint64 track_uuid = 11;

  // A new value for a counter track. |track_uuid| should refer to a track with
  // a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
  // efficient encoding of counter values that are sampled at the beginning/end
  // of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
  // Counter values can optionally be encoded in as delta values (positive or
  // negative) on each packet sequence (see CounterIncrementalBase).
  oneof counter_value_field {
    int64 counter_value = 30;
    double double_counter_value = 44;
  }

  // To encode counter values more efficiently, we support attaching additional
  // counter values to a TrackEvent of any type. All values will share the same
  // timestamp specified in the TracePacket. The value at
  // extra_counter_values[N] is for the counter track referenced by
  // extra_counter_track_uuids[N].
  //
  // |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
  // should always be equal or more uuids than values. It is valid to set more
  // uuids (e.g. via defaults) than values. If uuids are specified in
  // TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
  // default uuid list.
  //
  // For example, this allows snapshotting the thread time clock at each
  // thread-track BEGIN and END event to capture the cpu time delta of a slice.
  repeated uint64 extra_counter_track_uuids = 31;
  repeated int64 extra_counter_values = 12;

  // Counter snapshots using floating point instead of integer values.
  repeated uint64 extra_double_counter_track_uuids = 45;
  repeated double extra_double_counter_values = 46;

  // IDs of flows originating, passing through, or ending at this event.
  // Flow IDs are global within a trace.
  //
  // A flow connects a sequence of TrackEvents within or across tracks, e.g.
  // an input event may be handled on one thread but cause another event on
  // a different thread - a flow between the two events can associate them.
  //
  // The direction of the flows between events is inferred from the events'
  // timestamps. The earliest event with the same flow ID becomes the source
  // of the flow. Any events thereafter are intermediate steps of the flow,
  // until the flow terminates at the last event with the flow ID.
  //
  // Flows can also be explicitly terminated (see |terminating_flow_ids|), so
  // that the same ID can later be reused for another flow.
  // DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
  repeated uint64 flow_ids_old = 36 [deprecated = true];
  // TODO(b/204341740): replace "flow_ids_old" with "flow_ids" to reduce memory
  // consumption.
  repeated fixed64 flow_ids = 47;

  // List of flow ids which should terminate on this event, otherwise same as
  // |flow_ids|.
  // Any one flow ID should be either listed as part of |flow_ids| OR
  // |terminating_flow_ids|, not both.
  // DEPRECATED. Only kept for backwards compatibility.  Use
  // |terminating_flow_ids|.
  repeated uint64 terminating_flow_ids_old = 42 [deprecated = true];
  // TODO(b/204341740): replace "terminating_flow_ids_old" with
  // "terminating_flow_ids" to reduce memory consumption.
  repeated fixed64 terminating_flow_ids = 48;

  // An opaque identifier to correlate this slice with other slices that are
  // considered part of the same logical operation, even if they are not
  // causally connected. Examples uses of a correlation id might be the number
  // of frame going through various stages of rendering in a GPU, the id for an
  // RPC request going through a distributed system, or the id of a network
  // request going through various stages of processing by the kernel.
  //
  // NOTE: if the events *are* causually connected, you probably want to use
  // flows instead of OR in addition to correlation ids.
  //
  // UIs can use this identifier to visually link these slices, for instance,
  // by assigning them a consistent color or highlighting the entire correlated
  // set when one slice is hovered.
  //
  // Only one field within this 'oneof' should be set to define the correlation.
  oneof correlation_id_field {
    // A 64-bit unsigned integer used as the correlation ID.
    //
    // Best for performance and compact traces if the identifier is naturally
    // numerical or can be easily mapped to one by the trace producer.
    uint64 correlation_id = 52;

    // A string value used as the correlation ID.
    //
    // Offers maximum flexibility for human-readable or complex identifiers
    // (e.g., GUIDs). Note: Using many unique, long strings may increase trace
    // size. For frequently repeated string identifiers, consider
    // 'correlation_id_string_iid'.
    string correlation_id_str = 53;

    // An interned string identifier (an IID) for correlation.
    //
    // This 64-bit ID refers to a string defined in the 'correlation_id_str'
    // field within the packet sequence's InternedData. This approach combines
    // the descriptiveness and uniqueness of strings with the efficiency of
    // integer IDs for storage and comparison, especially for identifiers that
    // repeat across many events.
    uint64 correlation_id_str_iid = 54;
  }

  // Callstack associated with this event. This captures the program stack at
  // the time the event occurred, useful for understanding what code path led
  // to the event.
  //
  // Two variants are supported:
  // - callstack: Inline callstack data (simpler when trace size is not a
  //   concern or callstacks are unique)
  // - callstack_iid: Reference to an interned Callstack in InternedData
  //   (efficient for repeated callstacks)
  //
  // Only one of these fields should be set.
  oneof callstack_field {
    // Inline callstack data. Use this for simplicity when interning is not
    // needed (e.g., for unique callstacks or when trace size is not critical).
    Callstack callstack = 55;

    // Reference to interned Callstack (see InternedData.callstacks).
    // This is the efficient option when callstacks are repeated.
    //
    // Note: iids *always* start from 1. A value of 0 is considered "not set".
    uint64 callstack_iid = 56;
  }

  // Inline callstack for TrackEvents when interning is not needed.
  // This is a simplified version of the profiling Callstack/Frame messages,
  // designed for cases where trace size is not critical or callstacks are
  // unique.
  //
  // Use this for simple callstacks with function names and source locations.
  // For binary/library information (mappings, build IDs, relative PCs), use
  // interned callstacks via callstack_iid instead.
  message Callstack {
    // Frame within an inline callstack.
    message Frame {
      // Function name, e.g., "malloc" or "std::vector<int>::push_back"
      optional string function_name = 1;

      // Optional: Source file path, e.g., "/src/foo.cc"
      optional string source_file = 2;

      // Optional: Line number in the source file
      optional uint32 line_number = 3;
    }

    // Frames of this callstack, ordered from bottom (outermost) to top
    // (innermost). For example, if main() calls foo() which calls bar(), the
    // frames would be: [main, foo, bar]
    repeated Frame frames = 1;
  }

  // Debug annotations associated with this event. These are arbitrary key-value
  // pairs that can be used to attach additional information to the event.
  // See DebugAnnotation message for details on supported value types.
  //
  // For example, debug annotations can be used to attach a URL or resource
  // identifier to a network request event. Arrays, dictionaries and full
  // nested structures (e.g. arrays of dictionaries of dictionaries)
  // are supported.
  repeated DebugAnnotation debug_annotations = 4;

  // ---------------------------------------------------------------------------
  // TrackEvent arguments:
  // ---------------------------------------------------------------------------
  //
  // NOTE: The fields below this point are NOT part of the stable public API.
  // They are primarily intended for internal use by Chrome and Android. These
  // fields may change or be removed without notice. For custom/synthetic
  // traces, prefer using the fields above (name, categories, type, flows,
  // correlation_id, callstack, etc.) along with custom debug_annotations.

  // Typed event arguments:
  optional TaskExecution task_execution = 5;
  optional LogMessage log_message = 21;
  optional ChromeCompositorSchedulerState cc_scheduler_state = 24;
  optional ChromeUserEvent chrome_user_event = 25;
  optional ChromeKeyedService chrome_keyed_service = 26;
  optional ChromeLegacyIpc chrome_legacy_ipc = 27;
  optional ChromeHistogramSample chrome_histogram_sample = 28;
  optional ChromeLatencyInfo chrome_latency_info = 29;
  // DEPRECATED. Only kept for backwards compatibility. Use the
  // |ChromeTrackEvent.frame_reporter| extension in
  // https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
  // instead.
  optional ChromeFrameReporter chrome_frame_reporter = 32 [deprecated = true];
  optional ChromeApplicationStateInfo chrome_application_state_info = 39;
  optional ChromeRendererSchedulerState chrome_renderer_scheduler_state = 40;
  optional ChromeWindowHandleEventInfo chrome_window_handle_event_info = 41;
  optional ChromeContentSettingsEventInfo chrome_content_settings_event_info =
      43;
  optional ChromeActiveProcesses chrome_active_processes = 49;
  optional Screenshot screenshot = 50;

  // This field is used only if the source location represents the function that
  // executes during this event.
  oneof source_location_field {
    // Non-interned field.
    SourceLocation source_location = 33;
    // Interned field.
    uint64 source_location_iid = 34;
  }

  optional ChromeMessagePump chrome_message_pump = 35;
  optional ChromeMojoEventInfo chrome_mojo_event_info = 38;

  // New argument types go here :)

  // Extension range for typed events defined externally.
  // See docs/design-docs/extensions.md for more details.
  //
  // Extension support is work-in-progress, in the future the way to reserve a
  // subrange for a particular project will be described here and in the design
  // document linked above.
  //
  // Contact perfetto-dev@googlegroups.com if you are interested in a subrange
  // for your project.

  // Extension range reserved for chromium:
  // https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
  extensions 1000 to 1999;
  // Extension range reserved for https://b.corp.google.com/issues/301227627.
  extensions 2000 to 2000;
  // Extension range reserved for android:
  // protos/perfetto/trace/android/android_track_event.proto
  extensions 2001 to 2999;
  // Extension range for future use.
  extensions 3000 to 9899;
  // Reserved for Perfetto unit and integration tests.
  extensions 9900 to 10000;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy event fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
  // TracePacket instead.
  //
  // Timestamp in microseconds (usually CLOCK_MONOTONIC).
  oneof timestamp {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 timestamp_delta_us = 1;
    // Absolute value (e.g. a manually specified timestamp in the macro).
    // This is a one-off value that does not affect delta timestamp computation
    // in subsequent TrackEvents.
    int64 timestamp_absolute_us = 16;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread time instead.
  //
  // CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
  // microseconds.
  oneof thread_time {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 thread_time_delta_us = 2;
    // This is a one-off absolute value that does not affect delta timestamp
    // computation in subsequent TrackEvents.
    int64 thread_time_absolute_us = 17;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread instruction count instead.
  //
  // Value of the instruction counter for the current thread.
  oneof thread_instruction_count {
    // Same encoding as |thread_time| field above.
    int64 thread_instruction_count_delta = 8;
    int64 thread_instruction_count_absolute = 20;
  }

  // Apart from {category, time, thread time, tid, pid}, other legacy trace
  // event attributes are initially simply proxied for conversion to a JSON
  // trace. We intend to gradually transition these attributes to similar native
  // features in TrackEvent (e.g. async + flow events), or deprecate them
  // without replacement where transition is unsuitable.
  //
  // Next reserved id: 16 (up to 16).
  // Next id: 20.
  message LegacyEvent {
    // Deprecated, use TrackEvent::name(_iid) instead.
    // interned EventName.
    optional uint64 name_iid = 1;
    optional int32 phase = 2;
    optional int64 duration_us = 3;
    optional int64 thread_duration_us = 4;

    // Elapsed retired instruction count during the event.
    optional int64 thread_instruction_delta = 15;

    // used to be |flags|.
    reserved 5;

    oneof id {
      uint64 unscoped_id = 6;
      uint64 local_id = 10;
      uint64 global_id = 11;
    }
    // Additional optional scope for |id|.
    optional string id_scope = 7;

    // Consider the thread timestamps for async BEGIN/END event pairs as valid.
    optional bool use_async_tts = 9;

    // Idenfifies a flow. Flow events with the same bind_id are connected.
    optional uint64 bind_id = 8;
    // Use the enclosing slice as binding point for a flow end event instead of
    // the next slice. Flow start/step events always bind to the enclosing
    // slice.
    optional bool bind_to_enclosing = 12;

    enum FlowDirection {
      FLOW_UNSPECIFIED = 0;
      FLOW_IN = 1;
      FLOW_OUT = 2;
      FLOW_INOUT = 3;
    }
    optional FlowDirection flow_direction = 13;

    enum InstantEventScope {
      SCOPE_UNSPECIFIED = 0;
      SCOPE_GLOBAL = 1;
      SCOPE_PROCESS = 2;
      SCOPE_THREAD = 3;
    }
    optional InstantEventScope instant_event_scope = 14;

    // Override the pid/tid if the writer needs to emit events on behalf of
    // another process/thread. This should be the exception. Normally, the
    // pid+tid from ThreadDescriptor is used.
    optional int32 pid_override = 18;
    optional int32 tid_override = 19;
  }

  optional LegacyEvent legacy_event = 6;

  reserved 51;
}

// Default values for fields of all TrackEvents on the same packet sequence.
// Should be emitted as part of TracePacketDefaults whenever incremental state
// is cleared. It's defined here because field IDs should match those of the
// corresponding fields in TrackEvent.
message TrackEventDefaults {
  optional uint64 track_uuid = 11;
  repeated uint64 extra_counter_track_uuids = 31;
  repeated uint64 extra_double_counter_track_uuids = 45;

  // TODO(eseckler): Support default values for more TrackEvent fields.
}

// --------------------
// Interned data types:
// --------------------

message EventCategory {
  optional uint64 iid = 1;
  optional string name = 2;
}

message EventName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/track_event.proto

// Begin of protos/perfetto/trace/interned_data/interned_data.proto

// ------------------------------ DATA INTERNING: ------------------------------
// Interning indexes are built up gradually by adding the entries contained in
// each TracePacket of the same packet sequence (packets emitted by the same
// producer and TraceWriter, see |trusted_packet_sequence_id|). Thus, packets
// can only refer to interned data from other packets in the same sequence.
//
// The writer will emit new entries when it encounters new internable values
// that aren't yet in the index. Data in current and subsequent TracePackets can
// then refer to the entry by its position (interning ID, abbreviated "iid") in
// its index. An interning ID with value 0 is considered invalid (not set).
//
// Because of the incremental build-up, the interning index will miss data when
// TracePackets are lost, e.g. because a chunk was overridden in the central
// ring buffer. To avoid invalidation of the whole trace in such a case, the
// index is periodically reset (see SEQ_INCREMENTAL_STATE_CLEARED).
// When packet loss occurs, the reader will only lose interning data up to the
// next reset.
// -----------------------------------------------------------------------------

// Message that contains new entries for the interning indices of a packet
// sequence.
//
// The writer will usually emit new entries in the same TracePacket that first
// refers to them (since the last reset of interning state). They may also be
// emitted proactively in advance of referring to them in later packets.
//
// Next reserved id: 8 (up to 15).
// Next id: 44.
message InternedData {
  // TODO(eseckler): Replace iid fields inside interned messages with
  // map<iid, message> type fields in InternedData.

  // Each field's message type needs to specify an |iid| field, which is the ID
  // of the entry in the field's interning index. Each field constructs its own
  // index, thus interning IDs are scoped to the tracing session and field
  // (usually as a counter for efficient var-int encoding), and optionally to
  // the incremental state generation of the packet sequence.
  repeated EventCategory event_categories = 1;
  repeated EventName event_names = 2;
  repeated DebugAnnotationName debug_annotation_names = 3;
  repeated DebugAnnotationValueTypeName debug_annotation_value_type_names = 27;
  repeated SourceLocation source_locations = 4;
  repeated UnsymbolizedSourceLocation unsymbolized_source_locations = 28;
  repeated LogMessageBody log_message_body = 20;
  repeated HistogramName histogram_names = 25;

  // Note: field IDs up to 15 should be used for frequent data only.

  // Build IDs of exectuable files.
  repeated InternedString build_ids = 16;
  // Paths to executable files.
  repeated InternedString mapping_paths = 17;
  // Paths to source files.
  repeated InternedString source_paths = 18;
  // Names of functions used in frames below.
  repeated InternedString function_names = 5;
  // Executable files mapped into processes.
  repeated Mapping mappings = 19;
  // Frames of callstacks of a program.
  repeated Frame frames = 6;
  // A callstack of a program.
  repeated Callstack callstacks = 7;

  // Additional Vulkan information sent in a VulkanMemoryEvent message
  repeated InternedString vulkan_memory_keys = 22;

  // Graphics context of a render stage event.  This represent the GL
  // context for an OpenGl app or the VkDevice for a Vulkan app.
  repeated InternedGraphicsContext graphics_contexts = 23;

  // Description of a GPU hardware queue or render stage.
  repeated InternedGpuRenderStageSpecification gpu_specifications = 24;

  // This is set when FtraceConfig.symbolize_ksyms = true.
  // The id of each symbol the number that will be reported in ftrace events
  // like sched_block_reason.caller and is obtained from a monotonic counter.
  // The same symbol can have different indexes in different bundles.
  // This is is NOT the real address. This is to avoid disclosing KASLR through
  // traces.
  repeated InternedString kernel_symbols = 26;

  // Interned string values in the DebugAnnotation proto.
  repeated InternedString debug_annotation_string_values = 29;

  // Interned packet context for android.network_packets.
  repeated NetworkPacketContext packet_context = 30;

  // Interned name of a js function. We only intern js functions as there is a
  // lot of duplication for them, but less so for other strings in the V8 data
  // source.
  repeated InternedV8String v8_js_function_name = 31;
  // Js functions can be emitted multiple times for various compilation tiers,
  // so it makes sense to deduplicate all this.
  repeated InternedV8JsFunction v8_js_function = 32;
  // Interned JS script (there is one associated with each JS function)
  repeated InternedV8JsScript v8_js_script = 33;
  // Interned Wasm script (there is one associated with each Wasm function)
  repeated InternedV8WasmScript v8_wasm_script = 34;
  // Every V8 event is associated with an isolate, intern the isolate to remove
  // duplication.
  repeated InternedV8Isolate v8_isolate = 35;

  // Interned protolog strings args.
  repeated InternedString protolog_string_args = 36;
  // Interned protolog stacktraces.
  repeated InternedString protolog_stacktrace = 37;

  // viewcapture
  repeated InternedString viewcapture_package_name = 38;
  repeated InternedString viewcapture_window_name = 39;
  repeated InternedString viewcapture_view_id = 40;
  repeated InternedString viewcapture_class_name = 41;

  // Interned context for android.app_wakelocks.
  repeated AppWakelockInfo app_wakelock_info = 42;

  // Interned correlation ids in track_event.
  repeated InternedString correlation_id_str = 43;

  // removed ProfiledFrameSymbols profiled_frame_symbols
  reserved 21;
}

// End of protos/perfetto/trace/interned_data/interned_data.proto

// Begin of protos/perfetto/trace/memory_graph.proto

// Message definitions for app-reported memory breakdowns. At the moment, this
// is a Chrome-only tracing feature, historically known as 'memory-infra'. See
// https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/ .
// This is unrelated to the native or java heap profilers (those protos live
// in //protos/perfetto/trace/profiling/).

message MemoryTrackerSnapshot {
  // Memory snapshot of a process. The snapshot contains memory data that is
  // from 2 different sources, namely system stats and instrumentation stats.
  // The system memory usage stats come from the OS based on standard API
  // available in the platform to query memory usage. The instrumentation stats
  // are added by instrumenting specific piece of code which tracks memory
  // allocations and deallocations made by a small sub-system within the
  // application.
  // The system stats of the global memory snapshot are recorded as part of
  // ProcessStats and SmapsPacket fields in trace packet with the same
  // timestamp.
  message ProcessSnapshot {
    // Process ID of the process
    optional int32 pid = 1;

    // Memory dumps are represented as a graph of memory nodes which contain
    // statistics. To avoid double counting the same memory across different
    // nodes, edges are used to mark nodes that account for the same memory. See
    // this doc for examples of the usage:
    // https://docs.google.com/document/d/1WGQRJ1sjJrfVkNcgPVY6frm64UqPc94tsxUOXImZUZI

    // A single node in the memory graph.
    message MemoryNode {
      // Unique ID of the node across all processes involved in the global
      // memory dump. The ID is only unique within this particular global dump
      // identified by GlobalMemoryDumpPacket.global_dump_id.
      optional uint64 id = 1;

      // Absolute name is a unique name for the memory node within the process
      // with ProcessMemoryDump.pid. The name can contain multiple parts
      // separated by '/', which traces the edges of the node from the root
      // node.
      // Eg: "partition_allocator/array_buffers/buffer1" refers to the child
      // node "buffer1" in a graph structure of:
      //   root -> partition_allocator -> array_buffers -> buffer1.
      optional string absolute_name = 2;

      // A weak node means that the instrumentation that added the current node
      // is unsure about the existence of the actual memory. Unless a "strong"
      // (non-weak is default) node that has an edge to the current node exists
      // in the current global dump, the current node will be discarded.
      optional bool weak = 3;

      // Size of the node in bytes, used to compute the effective size of the
      // nodes without double counting.
      optional uint64 size_bytes = 4;

      // Entries in the memory node that contain statistics and additional
      // debuggable information about the memory. The size of the node is
      // tracked separately in the |size_bytes| field.
      message MemoryNodeEntry {
        optional string name = 1;

        enum Units {
          UNSPECIFIED = 0;
          BYTES = 1;
          COUNT = 2;
        }
        optional Units units = 2;

        // Contains either one of uint64 or string value.
        optional uint64 value_uint64 = 3;
        optional string value_string = 4;
      }
      repeated MemoryNodeEntry entries = 5;
    }
    repeated MemoryNode allocator_dumps = 2;

    // A directed edge that connects any 2 nodes in the graph above. These are
    // in addition to the inherent edges added due to the tree structure of the
    // node's absolute names.
    // Node with id |source_id| owns the node with id |target_id|, and has the
    // effect of attributing the memory usage of target to source. |importance|
    // is optional and relevant only for the cases of co-ownership, where it
    // acts as a z-index: the owner with the highest importance will be
    // attributed target's memory.
    message MemoryEdge {
      optional uint64 source_id = 1;
      optional uint64 target_id = 2;
      optional uint32 importance = 3;
      optional bool overridable = 4;
    }
    repeated MemoryEdge memory_edges = 3;
  }

  // Unique ID that represents the global memory dump.
  optional uint64 global_dump_id = 1;

  enum LevelOfDetail {
    DETAIL_FULL = 0;
    DETAIL_LIGHT = 1;
    DETAIL_BACKGROUND = 2;
  }
  optional LevelOfDetail level_of_detail = 2;

  repeated ProcessSnapshot process_memory_dumps = 3;
}

// End of protos/perfetto/trace/memory_graph.proto

// Begin of protos/perfetto/trace/perfetto/perfetto_metatrace.proto

// Used to trace the execution of perfetto itself.
message PerfettoMetatrace {
  // See base/metatrace_events.h for definitions.
  oneof record_type {
    uint32 event_id = 1;
    uint32 counter_id = 2;

    // For trace processor metatracing.
    string event_name = 8;
    uint64 event_name_iid = 11;

    string counter_name = 9;
  }
  message Arg {
    oneof key_or_interned_key {
      string key = 1;
      uint64 key_iid = 3;
    }
    oneof value_or_interned_value {
      string value = 2;
      uint64 value_iid = 4;
    }
  }

  // Only when using |event_id|.
  optional uint64 event_duration_ns = 3;

  // Only when using |counter_id|.
  optional int32 counter_value = 4;

  // ID of the thread that emitted the event.
  optional uint32 thread_id = 5;

  // If true the meta-tracing ring buffer had overruns and hence some data is
  // missing from this point.
  optional bool has_overruns = 6;

  // Args for the event.
  repeated Arg args = 7;

  // Interned strings corresponding to the |event_name_iid|, |key_iid| and
  // |value_iid| above.
  message InternedString {
    optional uint64 iid = 1;
    optional string value = 2;
  };
  repeated InternedString interned_strings = 10;
}

// End of protos/perfetto/trace/perfetto/perfetto_metatrace.proto

// Begin of protos/perfetto/trace/perfetto/tracing_service_event.proto

// Events emitted by the tracing service.
// Next id: 12.
message TracingServiceEvent {
  message DataSources {
    message DataSource {
      optional string producer_name = 1;
      optional string data_source_name = 2;
    }
    repeated DataSource data_source = 1;
  }
  oneof event_type {
    // When each of the following booleans are set to true, they report the
    // point in time (through TracePacket's timestamp) where the condition
    // they describe happened.
    // The order of the booleans below matches the timestamp ordering
    // they would generally be expected to have.

    // Emitted when we start tracing and specifically, this will be before any
    // producer is notified about the existence of this trace. This is always
    // emitted before the all_data_sources_started event. This event is also
    // guaranteed to be seen (byte-offset wise) before any data packets from
    // producers.
    bool tracing_started = 2;

    // Emitted after all data sources saw the start event and ACKed it.
    // This identifies the point in time when it's safe to assume that all data
    // sources have been recording events.
    bool all_data_sources_started = 1;

    // Emitted when a flush is started.
    bool flush_started = 9;

    // Emitted when all data sources have been flushed successfully or with an
    // error (including timeouts). This can generally happen many times over the
    // course of the trace.
    bool all_data_sources_flushed = 3;

    // Emitted when reading back the central tracing buffers has been completed.
    // If |write_into_file| is specified, this can happen many times over the
    // course of the trace.
    bool read_tracing_buffers_completed = 4;

    // Emitted after tracing has been disabled and specifically, this will be
    // after all packets from producers have been included in the central
    // tracing buffer.
    bool tracing_disabled = 5;

    // Emitted if perfetto --save-for-bugreport was invoked while the current
    // tracing session was running and it had the highest bugreport_score. In
    // this case the original consumer will see a nearly empty trace, because
    // the contents are routed onto the bugreport file. This event flags the
    // situation explicitly. Traces that contain this marker should be discarded
    // by test infrastructures / pipelines.
    // Deprecated since Android U, where --save-for-bugreport uses
    // non-destructive cloning.
    bool seized_for_bugreport = 6;

    // Emitted when not all data sources in all producers reply to a start
    // request after some time.
    DataSources slow_starting_data_sources = 7;

    // Emitted when the last flush request has failed. Lists data sources that
    // did not reply on time.
    DataSources last_flush_slow_data_sources = 8;

    // If this was a cloned tracing session, emitted when the tracing serice
    // started the clone operation.
    bool clone_started = 10;

    // If this was a cloned tracing session, emitted when the tracing service
    // finished the clone operation (for a specific buffer).
    uint32 buffer_cloned = 11;
  }
}

// End of protos/perfetto/trace/perfetto/tracing_service_event.proto

// Begin of protos/perfetto/common/android_energy_consumer_descriptor.proto

// Energy consumer based on aidl class:
// android.hardware.power.stats.EnergyConsumer.
message AndroidEnergyConsumer {
  // Unique ID of this energy consumer.  Matches the ID in a
  // AndroidEnergyEstimationBreakdown.
  optional int32 energy_consumer_id = 1;

  // For a group of energy consumers of the same logical type, sorting by
  // ordinal gives their physical order. Ordinals must be consecutive integers
  // starting from 0.
  optional int32 ordinal = 2;

  // Type of this energy consumer.
  optional string type = 3;

  // Unique name of this energy consumer. Vendor/device specific. Opaque to
  // framework.
  optional string name = 4;
}

message AndroidEnergyConsumerDescriptor {
  repeated AndroidEnergyConsumer energy_consumers = 1;
}

// End of protos/perfetto/common/android_energy_consumer_descriptor.proto

// Begin of protos/perfetto/trace/power/android_energy_estimation_breakdown.proto

// Energy data retrieve using the ODPM(On Device Power Monitor) API.
// This proto represents the aidl class:
// android.hardware.power.stats.EnergyConsumerResult.
message AndroidEnergyEstimationBreakdown {
  // The first trace packet of each session should include a energy consumer
  // descriptor.
  optional AndroidEnergyConsumerDescriptor energy_consumer_descriptor = 1;

  // ID of the AndroidEnergyConsumer associated with this result.  Matches
  // the energy_consumer_id in the AndroidEnergyConsumerDescriptor that
  // should be sent at the beginning of a trace.
  optional int32 energy_consumer_id = 2;

  // Total accumulated energy since boot in microwatt-seconds (uWs)
  optional int64 energy_uws = 3;

  message EnergyUidBreakdown {
    // Android ID/Linux UID, the accumulated energy is attributed to.
    optional int32 uid = 1;

    // Accumulated energy since boot in microwatt-seconds (uWs).
    optional int64 energy_uws = 2;
  }
  // Optional attributed energy per Android ID / Linux UID for this
  // EnergyConsumer. Sum total of attributed energy must be less than or equal
  // to total accumulated energy.
  repeated EnergyUidBreakdown per_uid_breakdown = 4;
}

// End of protos/perfetto/trace/power/android_energy_estimation_breakdown.proto

// Begin of protos/perfetto/trace/power/android_entity_state_residency.proto

message EntityStateResidency {
  message PowerEntityState {
    // Index corresponding to the entity
    optional int32 entity_index = 1;

    // Index corresponding to the state
    optional int32 state_index = 2;

    // Name of the entity. This is device-specific, determined by the PowerStats
    // HAL, and cannot be configured by the user. An example would be
    // "Bluetooth".
    optional string entity_name = 3;

    // Name of the state. This is device-specific, determined by the PowerStats
    // HAL, and cannot be configured by the user. An example would be
    // "Active".
    optional string state_name = 4;
  }

  // This is only emitted at the beginning of the trace.
  repeated PowerEntityState power_entity_state = 1;

  message StateResidency {
    // Index corresponding to PowerEntityState.entity_index
    optional int32 entity_index = 1;

    // Index corresponding to PowerEntityState.state_index
    optional int32 state_index = 2;

    // Time since boot that this entity has been in this state
    optional uint64 total_time_in_state_ms = 3;

    // Total number of times since boot that the entity has entered this state
    optional uint64 total_state_entry_count = 4;

    // Timestamp of the last time the entity entered this state
    optional uint64 last_entry_timestamp_ms = 5;
  }

  repeated StateResidency residency = 2;
}

// End of protos/perfetto/trace/power/android_entity_state_residency.proto

// Begin of protos/perfetto/trace/power/battery_counters.proto

message BatteryCounters {
  // Battery capacity in microampere-hours(Ah). Also known as Coulomb counter.
  optional int64 charge_counter_uah = 1;

  // Remaining battery capacity percentage of total capacity
  optional float capacity_percent = 2;

  // Instantaneous battery current in microamperes(A).
  // Negative values indicate current being drained from the battery and
  // positive values indicate current feeding the battery from a charge source
  // (USB).
  //
  // See https://perfetto.dev/docs/data-sources/battery-counters for more info.
  optional int64 current_ua = 3;

  // Instantaneous battery current in microamperes(A).
  optional int64 current_avg_ua = 4;

  // Battery name, emitted only on multiple batteries.
  optional string name = 5;

  // Battery capacity in microwatt-hours(Wh).
  optional int64 energy_counter_uwh = 6;

  // Battery voltage in microvolts(V).
  optional int64 voltage_uv = 7;
}

// End of protos/perfetto/trace/power/battery_counters.proto

// Begin of protos/perfetto/trace/power/power_rails.proto

message PowerRails {
  message RailDescriptor {
    // Index corresponding to the rail
    optional uint32 index = 1;

    // Name of the rail
    optional string rail_name = 2;

    // Name of the subsystem to which this rail belongs
    optional string subsys_name = 3;

    // Hardware sampling rate (Hz).
    optional uint32 sampling_rate = 4;
  }

  // This is only emitted at the beginning of the trace.
  repeated RailDescriptor rail_descriptor = 1;

  message EnergyData {
    // Index corresponding to RailDescriptor.index
    optional uint32 index = 1;

    // Time since device boot(CLOCK_BOOTTIME) in milli-seconds.
    optional uint64 timestamp_ms = 2;

    // Accumulated energy since device boot in microwatt-seconds (uWs).
    optional uint64 energy = 3;
  }

  repeated EnergyData energy_data = 2;

  // A unique session id that can be used to match energy data to sets of
  // descriptors. The indices used by rail descriptors and energy data packets
  // are meant to be unique to a given session uuid. When multiple data sources
  // are running in parallel, each data source should use a unique id.
  optional uint64 session_uuid = 3;
}

// End of protos/perfetto/trace/power/power_rails.proto

// Begin of protos/perfetto/trace/profiling/deobfuscation.proto

message ObfuscatedMember {
  // This is the obfuscated field name relative to the class containing the
  // ObfuscatedMember.
  optional string obfuscated_name = 1;
  // If this is fully qualified (i.e. contains a '.') this is the deobfuscated
  // field name including its class. Otherwise, this is this the unqualified
  // deobfuscated field name relative to the class containing this
  // ObfuscatedMember.
  optional string deobfuscated_name = 2;
}

message ObfuscatedClass {
  optional string obfuscated_name = 1;
  optional string deobfuscated_name = 2;
  // fields.
  repeated ObfuscatedMember obfuscated_members = 3;
  repeated ObfuscatedMember obfuscated_methods = 4;
}

message DeobfuscationMapping {
  optional string package_name = 1;
  optional int64 version_code = 2;
  repeated ObfuscatedClass obfuscated_classes = 3;
}
// End of protos/perfetto/trace/profiling/deobfuscation.proto

// Begin of protos/perfetto/trace/profiling/heap_graph.proto

message HeapGraphRoot {
  enum Type {
    ROOT_UNKNOWN = 0;
    ROOT_JNI_GLOBAL = 1;
    ROOT_JNI_LOCAL = 2;
    ROOT_JAVA_FRAME = 3;
    ROOT_NATIVE_STACK = 4;
    ROOT_STICKY_CLASS = 5;
    ROOT_THREAD_BLOCK = 6;
    ROOT_MONITOR_USED = 7;
    ROOT_THREAD_OBJECT = 8;
    ROOT_INTERNED_STRING = 9;
    ROOT_FINALIZING = 10;
    ROOT_DEBUGGER = 11;
    ROOT_REFERENCE_CLEANUP = 12;
    ROOT_VM_INTERNAL = 13;
    ROOT_JNI_MONITOR = 14;
  };
  // Objects retained by this root.
  repeated uint64 object_ids = 1 [packed = true];

  optional Type root_type = 2;
}

message HeapGraphType {
  enum Kind {
    KIND_UNKNOWN = 0;
    KIND_NORMAL = 1;
    KIND_NOREFERENCES = 2;
    KIND_STRING = 3;
    KIND_ARRAY = 4;
    KIND_CLASS = 5;
    KIND_CLASSLOADER = 6;
    KIND_DEXCACHE = 7;
    KIND_SOFT_REFERENCE = 8;
    KIND_WEAK_REFERENCE = 9;
    KIND_FINALIZER_REFERENCE = 10;
    KIND_PHANTOM_REFERENCE = 11;
  };
  // TODO(fmayer): Consider removing this and using the index in the repeaed
  // field to save space.
  optional uint64 id = 1;
  optional uint64 location_id = 2;
  optional string class_name = 3;
  // Size of objects of this type.
  optional uint64 object_size = 4;
  optional uint64 superclass_id = 5;
  // Indices for InternedData.field_names for the names of the fields of
  // instances of this class. This does NOT include the fields from
  // superclasses. The consumer of this data needs to walk all super
  // classes to get a full lists of fields. Objects always write the
  // fields in order of most specific class to the furthest up superclass.
  repeated uint64 reference_field_id = 6 [packed = true];
  optional Kind kind = 7;
  optional uint64 classloader_id = 8;
}

message HeapGraphObject {
  oneof identifier {
    uint64 id = 1;
    uint64 id_delta = 7;
  }

  // Index for InternedData.types for the name of the type of this object.
  optional uint64 type_id = 2;

  // Bytes occupied by this objects.
  optional uint64 self_size = 3;

  // Add this to all non-zero values in reference_object_id. This is used to
  // get more compact varint encoding.
  //
  // The name is confusing, but this has always been used as a base for
  // reference_object_id. The field should be named reference_object_id_base.
  optional uint64 reference_field_id_base = 6;

  // Indices for InternedData.field_names for the name of the field referring
  // to the object. For Android S+ and for instances of normal classes (e.g.
  // not instances of java.lang.Class or arrays), this is instead set in the
  // corresponding HeapGraphType, and this is left empty.
  repeated uint64 reference_field_id = 4 [packed = true];

  // Ids of the Object that is referred to.
  repeated uint64 reference_object_id = 5 [packed = true];

  // If this object is an instance of `libcore.util.NativeAllocationRegistry`,
  // the value of the `size` field.
  //
  // N.B. This is not the native size of this object.
  optional int64 native_allocation_registry_size_field = 8;

  enum HeapType {
    HEAP_TYPE_UNKNOWN = 0;
    HEAP_TYPE_APP = 1;
    HEAP_TYPE_ZYGOTE = 2;
    HEAP_TYPE_BOOT_IMAGE = 3;
  }
  // To reduce the space required we only emit the heap type if it has changed
  // from the previous object we recorded.
  optional HeapType heap_type_delta = 9;

  // Ids of the Objects referred by this object, not via fields, but via
  // internal runtime structures.
  repeated uint64 runtime_internal_object_id = 10 [packed = true];
}

message HeapGraph {
  optional int32 pid = 1;

  // This contains all objects at the time this dump was taken. Some of these
  // will be live, some of those unreachable (garbage). To find the live
  // objects, the client needs to build the transitive closure of objects
  // reachable from |roots|.
  // All objects not contained within that transitive closure are garbage that
  // has not yet been collected.
  repeated HeapGraphObject objects = 2;

  // Roots at the time this dump was taken.
  // All live objects are reachable from the roots. All other objects are
  // garbage.
  repeated HeapGraphRoot roots = 7;

  // Types used in HeapGraphObjects.
  repeated HeapGraphType types = 9;

  reserved 3;

  // Field names for references in managed heap graph.
  repeated InternedString field_names = 4;

  // Paths of files used in managed heap graph.
  repeated InternedString location_names = 8;

  optional bool continued = 5;
  optional uint64 index = 6;
}

// End of protos/perfetto/trace/profiling/heap_graph.proto

// Begin of protos/perfetto/trace/profiling/profile_packet.proto

// This file contains a mixture of messages emitted by various sampling
// profilers:
//
// Memory allocator profiling
// ----------------
// ProfilePacket:
//   The packet emitted by heapprofd, which started off as a native heap
//   (malloc/free) profiler, but now supports custom allocators as well. Each
//   packet contains a preaggregated state of the heap at snapshot time, which
//   report the total allocated/free bytes per callstack (plus other info such
//   as the number of samples).
// StreamingAllocation/StreamingFree:
//   Emitted by heapprofd when configured in streaming mode (i.e. when
//   stream_allocations = true). This is only for local testing, and doesn't
//   report callstacks (only address time and size of each alloc/free). It can
//   lead to enormous traces, as it contains the stream of each alloc/free call.
//
// Callstack sampling
// ------------------
// StreamingProfilePacket:
//   The packet emitted by the chromium in-process sampling profiler, which is
//   based on periodically sending a signal to itself, and unwinding the stack
//   in the signal handler. Each packet contains a series of individual stack
//   samples for a Chromium thread.
//
// Callstack and performance counter sampling
// ---------------------
// PerfSample:
//   The packet emitted by traced_perf sampling performance profiler based on
//   the perf_event_open syscall. Each packet represents an individual sample
//   of a performance counter (which might be a timer), and optionally a
//   callstack of the process that was scheduled at the time of the sample.
//

// The packet emitted by heapprofd for each heap snapshot. A snapshot can
// involve more than one ProfilePacket if the snapshot is big (when |continued|
// is true). The cardinality and grouping is as follows:
// A ProfilePacket contains:
//  - 1+ per-process heap snapshots (ProcessHeapSamples). Normally there is only
//    one heap per process (the main malloc/free heap), but there can be more if
//    the process is using the heapprofd API to profile custom allocators.
//  - Globally interned strings, mappings and frames (to allow de-duplicating
//    frames/mapping in common between different processes).
// A ProcessHeapSamples contains:
//  - The process and heap identifier.
//  - A number of HeapSample, one for each callsite that had some alloc/frees.
//  - Statistics about heapprofd internals (e.g., sampling/unwinding timings).
// A HeapSample contains statistics about callsites:
//  - Total number of bytes allocated and freed from that callsite.
//  - Total number of alloc/free calls sampled.
//  - Stats at the local maximum when dump_at_max = true.
// See https://perfetto.dev/docs/data-sources/native-heap-profiler for more.
message ProfilePacket {
  // The following interning tables are only used in Android version Q.
  // In newer versions, these tables are in InternedData
  // (see protos/perfetto/trace/interned_data) and are shared across
  // multiple ProfilePackets.
  // For backwards compatibility, consumers need to first look up interned
  // data in the tables within the ProfilePacket, and then, if they are empty,
  // look up in the InternedData instead.
  repeated InternedString strings = 1;
  repeated Mapping mappings = 4;
  repeated Frame frames = 2;
  repeated Callstack callstacks = 3;

  // Next ID: 9
  message HeapSample {
    optional uint64 callstack_id = 1;
    // bytes allocated at this callstack.
    optional uint64 self_allocated = 2;
    // bytes allocated at this callstack that have been freed.
    optional uint64 self_freed = 3;
    // deprecated self_idle.
    reserved 7;
    // Bytes allocated by this callstack but not freed at the time the malloc
    // heap usage of this process was maximal. This is only set if dump_at_max
    // is true in HeapprofdConfig. In that case, self_allocated, self_freed and
    // self_idle will not be set.
    optional uint64 self_max = 8;
    // Number of allocations that were sampled at this callstack but not freed
    // at the time the malloc heap usage of this process was maximal. This is
    // only set if dump_at_max is true in HeapprofdConfig. In that case,
    // self_allocated, self_freed and self_idle will not be set.
    optional uint64 self_max_count = 9;
    // timestamp [opt]
    optional uint64 timestamp = 4;
    // Number of allocations that were sampled at this callstack.
    optional uint64 alloc_count = 5;
    // Number of allocations that were sampled at this callstack that have been
    // freed.
    optional uint64 free_count = 6;
  }

  message Histogram {
    message Bucket {
      // This bucket counts values from the previous bucket's (or -infinity if
      // this is the first bucket) upper_limit (inclusive) to this upper_limit
      // (exclusive).
      optional uint64 upper_limit = 1;
      // This is the highest bucket. This is set instead of the upper_limit. Any
      // values larger or equal to the previous bucket's upper_limit are counted
      // in this bucket.
      optional bool max_bucket = 2;
      // Number of values that fall into this range.
      optional uint64 count = 3;
    }
    repeated Bucket buckets = 1;
  }

  message ProcessStats {
    optional uint64 unwinding_errors = 1;
    optional uint64 heap_samples = 2;
    optional uint64 map_reparses = 3;
    optional Histogram unwinding_time_us = 4;
    optional uint64 total_unwinding_time_us = 5;
    optional uint64 client_spinlock_blocked_us = 6;
  }

  repeated ProcessHeapSamples process_dumps = 5;
  message ProcessHeapSamples {
    enum ClientError {
      CLIENT_ERROR_NONE = 0;
      CLIENT_ERROR_HIT_TIMEOUT = 1;
      CLIENT_ERROR_INVALID_STACK_BOUNDS = 2;
    }
    optional uint64 pid = 1;

    // This process was profiled from startup.
    // If false, this process was already running when profiling started.
    optional bool from_startup = 3;

    // This process was not profiled because a concurrent session was active.
    // If this is true, samples will be empty.
    optional bool rejected_concurrent = 4;

    // This process disconnected while it was profiled.
    // If false, the process outlived the profiling session.
    optional bool disconnected = 6;

    // If disconnected, this disconnect was caused by the client overrunning
    // the buffer.
    // Equivalent to client_error == CLIENT_ERROR_HIT_TIMEOUT
    // on new S builds.
    optional bool buffer_overran = 7;

    optional ClientError client_error = 14;

    // If disconnected, this disconnected was caused by the shared memory
    // buffer being corrupted. THIS IS ALWAYS A BUG IN HEAPPROFD OR CLIENT
    // MEMORY CORRUPTION.
    optional bool buffer_corrupted = 8;

    // If disconnected, this disconnect was caused by heapprofd exceeding
    // guardrails during this profiling session.
    optional bool hit_guardrail = 10;

    optional string heap_name = 11;
    optional uint64 sampling_interval_bytes = 12;
    optional uint64 orig_sampling_interval_bytes = 13;

    // Timestamp of the state of the target process that this dump represents.
    // This can be different to the timestamp of the TracePackets for various
    // reasons:
    // * If disconnected is set above, this is the timestamp of last state
    //   heapprofd had of the process before it disconnected.
    // * Otherwise, if the rate of events produced by the process is high,
    //   heapprofd might be behind.
    //
    // TODO(fmayer): This is MONOTONIC_COARSE. Refactor ClockSnapshot::Clock
    //               to have a type enum that we can reuse here.
    optional uint64 timestamp = 9;

    // Metadata about heapprofd.
    optional ProcessStats stats = 5;

    repeated HeapSample samples = 2;
  }

  // If this is true, the next ProfilePacket in this package_sequence_id is a
  // continuation of this one.
  // To get all samples for a process, accummulate its
  // ProcessHeapSamples.samples until you see continued=false.
  optional bool continued = 6;

  // Index of this ProfilePacket on its package_sequence_id. Can be used
  // to detect dropped data.
  // Verify these are consecutive.
  optional uint64 index = 7;
}

// Packet emitted by heapprofd when stream_allocations = true. Only for local
// testing. Doesn't report the callsite.
message StreamingAllocation {
  // TODO(fmayer): Add callstack.
  repeated uint64 address = 1;
  repeated uint64 size = 2;
  repeated uint64 sample_size = 3;
  repeated uint64 clock_monotonic_coarse_timestamp = 4;
  repeated uint32 heap_id = 5;
  repeated uint64 sequence_number = 6;
};

// Packet emitted by heapprofd when stream_allocations = true. Only for local
// testing. Doesn't report the callsite.
message StreamingFree {
  // TODO(fmayer): Add callstack.
  repeated uint64 address = 1;
  repeated uint32 heap_id = 2;
  repeated uint64 sequence_number = 3;
};

// Packet emitted by the chromium in-process signal-based callstack sampler.
// Represents a series of individual stack samples (sampled at discrete points
// in time), rather than aggregated over an interval.
message StreamingProfilePacket {
  // Index into InternedData.callstacks
  repeated uint64 callstack_iid = 1;
  // TODO(eseckler): ThreadDescriptor-based timestamps are deprecated. Replace
  // this with ClockSnapshot-based delta encoding instead.
  repeated int64 timestamp_delta_us = 2;
  optional int32 process_priority = 3;
}

// Namespace for the contained enums.
message Profiling {
  enum CpuMode {
    MODE_UNKNOWN = 0;
    MODE_KERNEL = 1;
    MODE_USER = 2;
    // The following values aren't expected, but included for completeness:
    MODE_HYPERVISOR = 3;
    MODE_GUEST_KERNEL = 4;
    MODE_GUEST_USER = 5;
  }

  // Enumeration of libunwindstack's error codes.
  // NB: the integral representations of the two enums are different.
  enum StackUnwindError {
    UNWIND_ERROR_UNKNOWN = 0;
    UNWIND_ERROR_NONE = 1;
    UNWIND_ERROR_MEMORY_INVALID = 2;
    UNWIND_ERROR_UNWIND_INFO = 3;
    UNWIND_ERROR_UNSUPPORTED = 4;
    UNWIND_ERROR_INVALID_MAP = 5;
    UNWIND_ERROR_MAX_FRAMES_EXCEEDED = 6;
    UNWIND_ERROR_REPEATED_FRAME = 7;
    UNWIND_ERROR_INVALID_ELF = 8;
    UNWIND_ERROR_SYSTEM_CALL = 9;
    UNWIND_ERROR_THREAD_TIMEOUT = 10;
    UNWIND_ERROR_THREAD_DOES_NOT_EXIST = 11;
    UNWIND_ERROR_BAD_ARCH = 12;
    UNWIND_ERROR_MAPS_PARSE = 13;
    UNWIND_ERROR_INVALID_PARAMETER = 14;
    UNWIND_ERROR_PTRACE_CALL = 15;
  }
}

// Packet emitted by the traced_perf sampling performance profiler, which
// gathers data via the perf_event_open syscall. Each packet contains an
// individual sample with a counter value, and optionally a
// callstack.
//
// Timestamps are within the root packet. The config can specify the clock, or
// the implementation will default to CLOCK_MONOTONIC_RAW. Within the Android R
// timeframe, the default was CLOCK_BOOTTIME.
//
// There are several distinct views of this message:
// * indication of kernel buffer data loss (kernel_records_lost set)
// * indication of skipped samples (sample_skipped_reason set)
// * notable event in the sampling implementation (producer_event set)
// * normal sample (timebase_count set, typically also callstack_iid)
message PerfSample {
  optional uint32 cpu = 1;
  optional uint32 pid = 2;
  optional uint32 tid = 3;

  // Execution state that the process was sampled at.
  optional Profiling.CpuMode cpu_mode = 5;

  // Value of the timebase counter (since the event was configured, no deltas).
  optional uint64 timebase_count = 6;

  // Value of the followers counter (since the event was configured, no deltas).
  repeated uint64 follower_counts = 7;

  // Unwound callstack. Might be partial, in which case a synthetic "error"
  // frame is appended, and |unwind_error| is set accordingly.
  optional uint64 callstack_iid = 4;

  // If set, stack unwinding was incomplete due to an error.
  // Unset values should be treated as UNWIND_ERROR_NONE.
  oneof optional_unwind_error {
    Profiling.StackUnwindError unwind_error = 16;
  };

  // If set, indicates that this message is not a sample, but rather an
  // indication of data loss in the ring buffer allocated for |cpu|. Such data
  // loss occurs when the kernel has insufficient ring buffer capacity to write
  // a record (which gets discarded). A record in this context is an individual
  // ring buffer entry, and counts more than just sample records.
  //
  // The |timestamp| of the packet corresponds to the time that the producer
  // wrote the packet for trace-sorting purposes alone, and should not be
  // interpreted relative to the sample timestamps. This field is sufficient to
  // detect that *some* kernel data loss happened within the trace, but not the
  // specific time bounds of that loss (which would require tracking precedessor
  // & successor timestamps, which is not deemed necessary at the moment).
  optional uint64 kernel_records_lost = 17;

  // If set, indicates that the profiler encountered a sample that was relevant,
  // but was skipped.
  enum SampleSkipReason {
    PROFILER_SKIP_UNKNOWN = 0;
    PROFILER_SKIP_READ_STAGE = 1;
    PROFILER_SKIP_UNWIND_STAGE = 2;
    PROFILER_SKIP_UNWIND_ENQUEUE = 3;
    PROFILER_SKIP_NOT_IN_SCOPE = 4;
  }
  oneof optional_sample_skipped_reason {
    SampleSkipReason sample_skipped_reason = 18;
  };

  // A notable event within the sampling implementation.
  message ProducerEvent {
    enum DataSourceStopReason {
      PROFILER_STOP_UNKNOWN = 0;
      PROFILER_STOP_GUARDRAIL = 1;
    }
    oneof optional_source_stop_reason {
      DataSourceStopReason source_stop_reason = 1;
    }
  }
  optional ProducerEvent producer_event = 19;
}

// Submessage for TracePacketDefaults.
message PerfSampleDefaults {
  // The sampling timebase. Might not be identical to the data source config if
  // the implementation decided to default/override some parameters.
  optional PerfEvents.Timebase timebase = 1;

  // Description of followers event
  repeated FollowerEvent followers = 4;

  // If the config requested process sharding, report back the count and which
  // of those bins was selected. Never changes for the duration of a trace.
  optional uint32 process_shard_count = 2;
  optional uint32 chosen_process_shard = 3;
}

// End of protos/perfetto/trace/profiling/profile_packet.proto

// Begin of protos/perfetto/trace/profiling/smaps.proto

message SmapsEntry {
  optional string path = 1;
  optional uint64 size_kb = 2;
  optional uint64 private_dirty_kb = 3;
  optional uint64 swap_kb = 4;

  // for field upload (instead of path).
  optional string file_name = 5;

  // TODO(crbug.com/1098746): Consider encoding this as incremental values.
  optional uint64 start_address = 6;
  optional uint64 module_timestamp = 7;
  optional string module_debugid = 8;
  optional string module_debug_path = 9;
  optional uint32 protection_flags = 10;

  optional uint64 private_clean_resident_kb = 11;
  optional uint64 shared_dirty_resident_kb = 12;
  optional uint64 shared_clean_resident_kb = 13;
  optional uint64 locked_kb = 14;
  optional uint64 proportional_resident_kb = 15;
};

message SmapsPacket {
  optional uint32 pid = 1;
  repeated SmapsEntry entries = 2;
};

// End of protos/perfetto/trace/profiling/smaps.proto

// Begin of protos/perfetto/trace/ps/process_stats.proto

// Per-process periodically sampled stats. These samples are wrapped in a
// dedicated message (as opposite to be fields in process_tree.proto) because
// they are dumped at a different rate than cmdline and thread list.
// Note: not all of these stats will be present in every ProcessStats message
// and sometimes processes may be missing. This is because counters are
// cached to reduce emission of counters which do not change.
message ProcessStats {
  // Per-thread periodically sampled stats.
  // Note: not all of these stats will be present in every message. See the note
  // for ProcessStats.
  message Thread {
    optional int32 tid = 1;

    // DEPRECATED cpu_freq_indices
    reserved 2;

    // DEPRECATED cpu_freq_ticks
    reserved 3;

    // DEPRECATED cpu_freq_full
    reserved 4;
  }

  message FDInfo {
    optional uint64 fd = 1;
    optional string path = 2;
  }

  message Process {
    optional int32 pid = 1;

    repeated Thread threads = 11;

    // See /proc/[pid]/status in `man 5 proc` for a description of these fields.
    optional uint64 vm_size_kb = 2;
    optional uint64 vm_rss_kb = 3;
    optional uint64 rss_anon_kb = 4;
    optional uint64 rss_file_kb = 5;
    optional uint64 rss_shmem_kb = 6;
    optional uint64 vm_swap_kb = 7;
    optional uint64 vm_locked_kb = 8;
    optional uint64 vm_hwm_kb = 9;
    // When adding a new field remember to update kProcMemCounterSize in
    // the trace processor.

    optional int64 oom_score_adj = 10;

    // The peak resident set size is resettable in newer Posix kernels.
    // This field specifies if reset is supported and if the writer had reset
    // the peaks after each process stats recording.
    optional bool is_peak_rss_resettable = 12;

    // Private, shared and swap footprint of the process as measured by
    // Chrome. To know more about these metrics refer to:
    // https://docs.google.com/document/d/1_WmgE1F5WUrhwkPqJis3dWyOiUmQKvpXp5cd4w86TvA
    optional uint32 chrome_private_footprint_kb = 13;
    optional uint32 chrome_peak_resident_set_kb = 14;

    repeated FDInfo fds = 15;

    // These fields are set only when scan_smaps_rollup=true
    optional uint64 smr_rss_kb = 16;
    optional uint64 smr_pss_kb = 17;
    optional uint64 smr_pss_anon_kb = 18;
    optional uint64 smr_pss_file_kb = 19;
    optional uint64 smr_pss_shmem_kb = 20;
    optional uint64 smr_swap_pss_kb = 23;

    // Time spent scheduled in user mode in nanoseconds. Parsed from utime in
    // /proc/pid/stat. Recorded if record_process_runtime config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 runtime_user_mode = 21;

    // Time spent scheduled in kernel mode in nanoseconds. Parsed from stime in
    // /proc/pid/stat. Recorded if record_process_runtime config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 runtime_kernel_mode = 22;

    // The total size of all dmabufs referenced by a process via FDs or VMAs.
    optional uint64 dmabuf_rss_kb = 24;
  }
  repeated Process processes = 1;

  // The time at which we finish collecting this batch of samples;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 2;
}

// End of protos/perfetto/trace/ps/process_stats.proto

// Begin of protos/perfetto/trace/ps/process_tree.proto

// Metadata about the processes and threads in the trace.
// Note: this proto was designed to be filled in by traced_probes and should
// only be populated with accurate information coming from the system. Other
// trace writers should prefer to fill ThreadDescriptor and ProcessDescriptor
// in TrackDescriptor.
message ProcessTree {
  // Representation of a thread.
  message Thread {
    // The thread ID (as per gettid()) in the root PID namespace.
    optional int32 tid = 1;

    // Thread group id (i.e. the PID of the process, == TID of the main thread)
    optional int32 tgid = 3;

    // The name of the thread.
    optional string name = 2;

    // The non-root-level thread IDs if the thread runs in a PID namespace. Read
    // from the NSpid entry of /proc/<tid>/status, with the first element (root-
    // level thread ID) omitted.
    repeated int32 nstid = 4;
  }

  // Representation of a process.
  message Process {
    // The UNIX process ID, aka thread group ID (as per getpid()) in the root
    // PID namespace.
    optional int32 pid = 1;

    // The parent process ID, as per getppid().
    optional int32 ppid = 2;

    // The command line for the process, as per /proc/pid/cmdline, broken up on
    // NUL bytes.
    // If it is a kernel thread or a zombie, there will only be one cmdline
    // field and it will contain /proc/pid/comm.
    repeated string cmdline = 3;

    // If true, the |cmdline| field was filled with the main thread's "comm"
    // field instead.
    // Introduced in: perfetto v50.
    optional bool cmdline_is_comm = 9;

    // The uid for the process, as per /proc/pid/status.
    optional int32 uid = 5;

    // The non-root-level process IDs if the process runs in a PID namespace.
    // Read from the NSpid entry of /proc/<pid>/status, with the first element
    // (root-level process ID) omitted.
    repeated int32 nspid = 6;

    // Timestamp of when the process was created, in nanoseconds
    // from boot. Parsed from starttime in /proc/pid/stat.
    // Recorded if record_process_age config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 process_start_from_boot = 7;

    // If true, the process is a kernel thread.
    // Set only on linux v6.4+. For traces from older devices, it is possible to
    // infer most kthreads by checking that they're a descendant of kthreadd
    // (pid=2), or are the idle process (pid=0).
    // Introduced in: perfetto v50.
    optional bool is_kthread = 8;

    // threads_deprecated
    reserved 4;
  }

  // List of processes and threads in the client. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might event not show up at all, if
  // no sched_switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{pid: 11, tgid: 10}] }
  // #1 { threads: [{pid: 12, tgid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{pid: 13, tgid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;

  // The time at which we finish collecting this process tree;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 3;
}

// End of protos/perfetto/trace/ps/process_tree.proto

// Begin of protos/perfetto/trace/remote_clock_sync.proto

// Records the parameters for aligning clock readings between machines.
message RemoteClockSync {
  // Synchronized clock snapshots taken on both sides of the relay port (the
  // tracing service and the relay service). A round of clock synchronization
  // IPC takes emits 2 SyncedClocks messages, i.e., client snapshot -> host
  // snapshot -> client snapshot -> host snapshot.
  message SyncedClocks {
    optional ClockSnapshot client_clocks = 2;
    optional ClockSnapshot host_clocks = 3;
  }

  repeated SyncedClocks synced_clocks = 1;
}

// End of protos/perfetto/trace/remote_clock_sync.proto

// Begin of protos/perfetto/trace/statsd/statsd_atom.proto

// Deliberate empty message. See comment on StatsdAtom#atom below.
message Atom {}

// One or more statsd atoms. This must continue to match:
// perfetto/protos/third_party/statsd/shell_data.proto
// So that we can efficiently add data from statsd directly to the
// trace.
message StatsdAtom {
  // Atom should be filled with an Atom proto from:
  // https://cs.android.com/android/platform/superproject/main/+/main:frameworks/proto_logging/stats/atoms.proto?q=f:stats%2Fatoms.proto$%20message%5C%20Atom
  // We don't reference Atom directly here since we don't want to import
  // Atom.proto and all its transitive dependencies into Perfetto.
  // atom and timestamp_nanos have the same cardinality
  repeated Atom atom = 1;
  repeated int64 timestamp_nanos = 2;
}

// End of protos/perfetto/trace/statsd/statsd_atom.proto

// Begin of protos/perfetto/trace/sys_stats/sys_stats.proto

// Various Linux system stat counters from /proc.
// The fields in this message can be reported at different rates and with
// different granularity. See sys_stats_config.proto.
message SysStats {
  // Counters from /proc/meminfo. Values are in KB.
  message MeminfoValue {
    optional MeminfoCounters key = 1;
    optional uint64 value = 2;
  };
  repeated MeminfoValue meminfo = 1;

  // Counter from /proc/vmstat. Units are often pages, not KB.
  message VmstatValue {
    optional VmstatCounters key = 1;
    optional uint64 value = 2;
  };
  repeated VmstatValue vmstat = 2;

  // Times in each mode, since boot. Unit: nanoseconds.
  message CpuTimes {
    optional uint32 cpu_id = 1;

    // Time spent in user mode.
    optional uint64 user_ns = 2;

    // Time spent in user mode (low prio).
    optional uint64 user_nice_ns = 3;

    // Time spent in system mode.
    optional uint64 system_mode_ns = 4;

    // Time spent in the idle task.
    optional uint64 idle_ns = 5;

    // Time spent waiting for I/O.
    optional uint64 io_wait_ns = 6;

    // Time spent servicing interrupts.
    optional uint64 irq_ns = 7;

    // Time spent servicing softirqs.
    optional uint64 softirq_ns = 8;

    // Time spent executing something else on host than this guest.
    optional uint64 steal_ns = 9;
  }
  // One entry per cpu.
  repeated CpuTimes cpu_stat = 3;

  // Num processes forked since boot.
  // Populated only if FORK_COUNT in config.stat_counters.
  optional uint64 num_forks = 4;

  message InterruptCount {
    optional int32 irq = 1;
    optional uint64 count = 2;
  }

  // Number of interrupts, broken by IRQ number.
  // Populated only if IRQ_COUNTS in config.stat_counters.

  // Total num of irqs serviced since boot.
  optional uint64 num_irq_total = 5;
  repeated InterruptCount num_irq = 6;

  // Number of softirqs, broken by softirq number.
  // Populated only if SOFTIRQ_COUNTS in config.stat_counters.

  // Total num of softirqs since boot.
  optional uint64 num_softirq_total = 7;

  // Per-softirq count.
  repeated InterruptCount num_softirq = 8;

  // The time at which we finish collecting this set of samples;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 9;

  // Frequencies for /sys/class/devfreq/ entries in kHz.
  message DevfreqValue {
    optional string key = 1;
    optional uint64 value = 2;
  };

  // One entry per device.
  repeated DevfreqValue devfreq = 10;

  // Cpu current frequency from
  // /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq in kHz.
  // One entry per cpu. Report 0 for offline cpu
  repeated uint32 cpufreq_khz = 11;

  message BuddyInfo {
    optional string node = 1;
    optional string zone = 2;
    repeated uint32 order_pages = 3;
  }
  // One entry per each node's zones.
  repeated BuddyInfo buddy_info = 12;

  // Counters from /proc/diskstats.
  message DiskStat {
    optional string device_name = 1;
    optional uint64 read_sectors = 2;
    optional uint64 read_time_ms = 3;
    optional uint64 write_sectors = 4;
    optional uint64 write_time_ms = 5;
    optional uint64 discard_sectors = 6;
    optional uint64 discard_time_ms = 7;
    optional uint64 flush_count = 8;
    optional uint64 flush_time_ms = 9;
  }
  // One entry per disk device.
  repeated DiskStat disk_stat = 13;

  // Reading from /proc/pressure/*.
  message PsiSample {
    // Type of resource that may have exhibited pressure stalls.
    //    * _SOME indicates some resource tasks stalled.
    //    * _FULL indicates all non-idle resource tasks stalled simultaneously.
    enum PsiResource {
      PSI_RESOURCE_UNSPECIFIED = 0;
      PSI_RESOURCE_CPU_SOME = 1;
      PSI_RESOURCE_CPU_FULL = 2;
      PSI_RESOURCE_IO_SOME = 3;
      PSI_RESOURCE_IO_FULL = 4;
      PSI_RESOURCE_MEMORY_SOME = 5;
      PSI_RESOURCE_MEMORY_FULL = 6;
    }
    optional PsiResource resource = 1;

    // Total absolute stall time (in nanos) for a given resource.
    // While PSI readings are in micros, we store in nanos for consistency with
    // most other time-based counters.
    optional uint64 total_ns = 2;

    // Note that /proc/pressure/* exposes historical average utilization values
    // (as a %), but we don't yet sample those. They could easily be added as
    // additional fields should the total stall time readings be insufficient.
  }
  // One entry per PsiResource type.
  repeated PsiSample psi = 14;

  // Reading from /sys/class/thermal/*.
  message ThermalZone {
    optional string name = 1;
    optional uint64 temp = 2;
    optional string type = 3;
  }
  repeated ThermalZone thermal_zone = 15;

  // Reading from /sys/devices/system/cpu/cpu*/cpuidle/state*.
  message CpuIdleStateEntry {
    // Name of the idle state, e.g. C1-C10
    optional string state = 1;
    optional uint64 duration_us = 2;
  }
  message CpuIdleState {
    optional uint32 cpu_id = 1;
    repeated CpuIdleStateEntry cpuidle_state_entry = 2;
  }
  repeated CpuIdleState cpuidle_state = 16;

  // Read GPU frequency info on Intel/AMD devices.
  repeated uint64 gpufreq_mhz = 17;
}

// End of protos/perfetto/trace/sys_stats/sys_stats.proto

// Begin of protos/perfetto/trace/system_info/cpu_info.proto

// Information about CPUs from procfs and sysfs.
message CpuInfo {
  message ArmCpuIdentifier {
    // Implementer code
    optional uint32 implementer = 1;

    // Architecture code
    optional uint32 architecture = 2;

    // CPU variant
    optional uint32 variant = 3;

    // CPU part
    optional uint32 part = 4;

    // CPU revision
    optional uint32 revision = 5;
  }

  // Information about a single CPU.
  message Cpu {
    // Value of "Processor" field from /proc/cpuinfo for this CPU.
    // Example: "AArch64 Processor rev 12 (aarch64)"
    optional string processor = 1;

    // Frequencies from
    // /sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies
    // where X is the index of this CPU.
    repeated uint32 frequencies = 2;

    // Cpu capacity from /sys/devices/system/cpu/cpuX/cpu_capacity where X is
    // the index of this CPU.
    optional uint32 capacity = 3;

    // Code to identify the CPU
    oneof identifier {
      ArmCpuIdentifier arm_identifier = 4;
    }

    // Features is a bitmap containing a bit set for each feature defined in
    // kCpuInfoFlags (cpu_info_flags_allowlist.h) for the corresponding array
    // index.
    optional uint64 features = 5;
  }

  // Describes available CPUs, one entry per CPU.
  repeated Cpu cpus = 1;
}

// End of protos/perfetto/trace/system_info/cpu_info.proto

// Begin of protos/perfetto/trace/test_event.proto

// Event used by testing code.
message TestEvent {
  // Arbitrary string used in tests.
  optional string str = 1;

  // The current value of the random number sequence used in tests.
  optional uint32 seq_value = 2;

  // Monotonically increased on each packet.
  optional uint64 counter = 3;

  // No more packets should follow (from the current sequence).
  optional bool is_last = 4;

  message TestPayload {
    repeated string str = 1;
    repeated TestPayload nested = 2;

    optional string single_string = 4;

    optional int32 single_int = 5;
    repeated int32 repeated_ints = 6;

    // When 0 this is the bottom-most nested message.
    optional uint32 remaining_nesting_depth = 3;

    repeated DebugAnnotation debug_annotations = 7;
  }
  optional TestPayload payload = 5;
}

// End of protos/perfetto/trace/test_event.proto

// Begin of protos/perfetto/trace/trace_packet_defaults.proto

// Default values for TracePacket fields that hold for a particular TraceWriter
// packet sequence. This message contains a subset of the TracePacket fields
// with matching IDs. When provided, these fields define the default values
// that should be applied, at import time, to all TracePacket(s) with the same
// |trusted_packet_sequence_id|, unless otherwise specified in each packet.
//
// Should be reemitted whenever incremental state is cleared on the sequence.
message TracePacketDefaults {
  optional uint32 timestamp_clock_id = 58;

  // Default values for TrackEvents (e.g. default track).
  optional TrackEventDefaults track_event_defaults = 11;

  // Defaults for perf profiler packets (PerfSample).
  optional PerfSampleDefaults perf_sample_defaults = 12;

  // Defaults for V8 code packets (V8JsCode, V8InternalCode, V8WasmCode,
  // V8RegexpCode)
  optional V8CodeDefaults v8_code_defaults = 99;
}
// End of protos/perfetto/trace/trace_packet_defaults.proto

// Begin of protos/perfetto/trace/trace_uuid.proto

// A random unique ID that identifies the trace.
// This message has been introduced in v32. Prior to that, the UUID was
// only (optionally) present in the TraceConfig.trace_uuid_msb/lsb fields.
// This has been moved to a standalone packet to deal with new use-cases for
// go/gapless-aot, where the same tracing session can be serialized several
// times, in which case the UUID is changed on each snapshot and does not match
// the one in the TraceConfig.
message TraceUuid {
  optional int64 msb = 1;
  optional int64 lsb = 2;
}

// End of protos/perfetto/trace/trace_uuid.proto

// Begin of protos/perfetto/trace/track_event/process_descriptor.proto

// Describes a process's attributes. Emitted as part of a TrackDescriptor,
// usually by the process's main thread.
//
// Next id: 9.
message ProcessDescriptor {
  optional int32 pid = 1;
  repeated string cmdline = 2;
  optional string process_name = 6;

  optional int32 process_priority = 5;
  // Process start time in nanoseconds.
  // The timestamp refers to the trace clock by default. Other clock IDs
  // provided in TracePacket are not supported.
  optional int64 start_timestamp_ns = 7;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // See chromium's content::ProcessType.
  enum ChromeProcessType {
    PROCESS_UNSPECIFIED = 0;
    PROCESS_BROWSER = 1;
    PROCESS_RENDERER = 2;
    PROCESS_UTILITY = 3;
    PROCESS_ZYGOTE = 4;
    PROCESS_SANDBOX_HELPER = 5;
    PROCESS_GPU = 6;
    PROCESS_PPAPI_PLUGIN = 7;
    PROCESS_PPAPI_BROKER = 8;
  }
  optional ChromeProcessType chrome_process_type = 4;

  // To support old UI. New UI should determine default sorting by process_type.
  optional int32 legacy_sort_index = 3;

  // Labels can be used to further describe properties of the work performed by
  // the process. For example, these can be used by Chrome renderer process to
  // provide titles of frames being rendered.
  repeated string process_labels = 8;
}

// End of protos/perfetto/trace/track_event/process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/range_of_interest.proto

// This message specifies the "range of interest" for track events. With the
// `drop_track_event_data_before` option set to `kTrackEventRangeOfInterest`,
// Trace Processor drops track events outside of this range.
message TrackEventRangeOfInterest {
  optional int64 start_us = 1;
}
// End of protos/perfetto/trace/track_event/range_of_interest.proto

// Begin of protos/perfetto/trace/track_event/thread_descriptor.proto

// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer.
//
// Next id: 9.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;

  optional string thread_name = 5;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  enum ChromeThreadType {
    CHROME_THREAD_UNSPECIFIED = 0;

    CHROME_THREAD_MAIN = 1;
    CHROME_THREAD_IO = 2;

    // Scheduler:
    CHROME_THREAD_POOL_BG_WORKER = 3;
    CHROME_THREAD_POOL_FG_WORKER = 4;
    CHROME_THREAD_POOL_FB_BLOCKING = 5;
    CHROME_THREAD_POOL_BG_BLOCKING = 6;
    CHROME_THREAD_POOL_SERVICE = 7;

    // Compositor:
    CHROME_THREAD_COMPOSITOR = 8;
    CHROME_THREAD_VIZ_COMPOSITOR = 9;
    CHROME_THREAD_COMPOSITOR_WORKER = 10;

    // Renderer:
    CHROME_THREAD_SERVICE_WORKER = 11;

    // Tracing related threads:
    CHROME_THREAD_MEMORY_INFRA = 50;
    CHROME_THREAD_SAMPLING_PROFILER = 51;
  };
  optional ChromeThreadType chrome_thread_type = 4;

  // Deprecated. Use ClockSnapshot in combination with TracePacket's timestamp
  // and timestamp_clock_id fields instead.
  optional int64 reference_timestamp_us = 6;

  // Absolute reference values. Clock values in subsequent TrackEvents can be
  // encoded accumulatively and relative to these. This reduces their var-int
  // encoding size.
  // TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
  optional int64 reference_thread_time_us = 7;
  optional int64 reference_thread_instruction_count = 8;

  // To support old UI. New UI should determine default sorting by thread_type.
  optional int32 legacy_sort_index = 3;
}

// End of protos/perfetto/trace/track_event/thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/chrome_process_descriptor.proto

// Describes the attributes for a Chrome process. Must be paired with a
// ProcessDescriptor in the same TrackDescriptor.
//
// Next id: 6.
message ChromeProcessDescriptor {
  // This is a chrome_enums::ProcessType from
  // //protos/third_party/chromium/chrome_enums.proto. The enum definition can't
  // be imported here because of a dependency loop.
  optional int32 process_type = 1;

  optional int32 process_priority = 2;

  // To support old UI. New UI should determine default sorting by process_type.
  optional int32 legacy_sort_index = 3;

  // Name of the hosting app for WebView. Used to match renderer processes to
  // their hosting apps.
  optional string host_app_package_name = 4;

  // The ID to link crashes to trace.
  // Notes:
  // * The ID is per process. So, each trace may contain many IDs, and you need
  //   to look for the ID from crashed process to find the crash report.
  // * Having a "chrome-trace-id" in crash doesn't necessarily mean we can
  //   get an uploaded trace, since uploads could have failed.
  // * On the other hand, if there was a crash during the session and trace was
  //   uploaded, it is very likely to find a crash report with the trace ID.
  // * This is not crash ID or trace ID. It is just a random 64-bit number
  //   recorded in both traces and crashes. It is possible to have collisions,
  //   though very rare.
  optional uint64 crash_trace_id = 5;
}

// End of protos/perfetto/trace/track_event/chrome_process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/chrome_thread_descriptor.proto

// Describes a Chrome thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer. Must be paired with a ThreadDescriptor
// in the same TrackDescriptor.
//
// Next id: 3.
message ChromeThreadDescriptor {
  // This is a chrome_enums::ThreadType from
  // //protos/third_party/chromium/chrome_enums.proto. The enum definition can't
  // be imported here because of a dependency loop.
  optional int32 thread_type = 1;

  // To support old UI. New UI should determine default sorting by thread_type.
  optional int32 legacy_sort_index = 2;

  // Indicates whether the thread's tid specified in the thread descriptor is
  // namespaced by Chromium's sandbox. Only set on Linux, and from Chrome M140.
  optional bool is_sandboxed_tid = 3;
}

// End of protos/perfetto/trace/track_event/chrome_thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/counter_descriptor.proto

// Defines properties of a counter track, e.g. for built-in counters (thread
// time, instruction count, ..) or user-specified counters (e.g. memory usage of
// a specific app component).
//
// Counter tracks only support TYPE_COUNTER track events, which specify new
// values for the counter. For counters that require per-slice values, counter
// values can instead be provided in a more efficient encoding via TrackEvent's
// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
// slice-type events cannot be emitted onto a counter track.
//
// Values for counters that are only emitted on a single packet sequence can
// optionally be delta-encoded, see |is_incremental|.
//
// Next id: 7.
message CounterDescriptor {
  // Built-in counters, usually with special meaning in the client library,
  // trace processor, legacy JSON format, or UI. Trace processor will infer a
  // track name from the enum value if none is provided in TrackDescriptor.
  enum BuiltinCounterType {
    COUNTER_UNSPECIFIED = 0;

    // Thread-scoped counters. The thread's track should be specified via
    // |parent_uuid| in the TrackDescriptor for such a counter.

    // implies UNIT_TIME_NS.
    COUNTER_THREAD_TIME_NS = 1;

    // implies UNIT_COUNT.
    COUNTER_THREAD_INSTRUCTION_COUNT = 2;
  }

  // Type of the values for the counters - to supply lower granularity units,
  // see also |unit_multiplier|.
  enum Unit {
    UNIT_UNSPECIFIED = 0;
    UNIT_TIME_NS = 1;
    UNIT_COUNT = 2;
    UNIT_SIZE_BYTES = 3;
    // TODO(eseckler): Support more units as necessary.
  }

  // For built-in counters (e.g. thread time). Custom user-specified counters
  // (e.g. those emitted by TRACE_COUNTER macros of the client library)
  // shouldn't set this, and instead provide a counter name via TrackDescriptor.
  optional BuiltinCounterType type = 1;

  // Names of categories of the counter (usually for user-specified counters).
  // In the client library, categories are a way to turn groups of individual
  // counters (or events) on or off.
  repeated string categories = 2;

  // Type of the counter's values. Built-in counters imply a value for this
  // field.
  optional Unit unit = 3;

  // In order to use a unit not defined as a part of |Unit|, a free-form unit
  // name can be used instead.
  optional string unit_name = 6;

  // Multiplication factor of this counter's values, e.g. to supply
  // COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
  optional int64 unit_multiplier = 4;

  // Whether values for this counter are provided as delta values. Only
  // supported for counters that are emitted on a single packet-sequence (e.g.
  // thread time). Counter values in subsequent packets on the current packet
  // sequence will be interpreted as delta values from the sequence's most
  // recent value for the counter. When incremental state is cleared, the
  // counter value is considered to be reset to 0. Thus, the first value after
  // incremental state is cleared is effectively an absolute value.
  optional bool is_incremental = 5;

  // TODO(eseckler): Support arguments describing the counter (?).
  // repeated DebugAnnotation debug_annotations;

  // When visualizing multiple counter tracks, it is often useful to have them
  // share the same Y-axis range. This allows for easy comparison of their
  // values.
  //
  // All counter tracks with the same |y_axis_share_key| and the same parent
  // track (e.g. grouped under the same process track) will share their y-axis
  // range in the UI.
  optional string y_axis_share_key = 7;
}

// End of protos/perfetto/trace/track_event/counter_descriptor.proto

// Begin of protos/perfetto/trace/track_event/track_descriptor.proto

// Defines a track for TrackEvents. Slices and instant events on the same track
// will be nested based on their timestamps, see TrackEvent::Type.
//
// A TrackDescriptor only needs to be emitted by one trace writer / producer and
// is valid for the entirety of the trace. To ensure the descriptor isn't lost
// when the ring buffer wraps, it should be reemitted whenever incremental state
// is cleared.
//
// As a fallback, TrackEvents emitted without an explicit track association will
// be associated with an implicit trace-global track (uuid = 0), see also
// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
// TrackDescriptor for this implicit track.
//
// Next id: 18.
message TrackDescriptor {
  // Unique ID that identifies this track. This ID is global to the whole trace.
  // Producers should ensure that it is unlikely to clash with IDs emitted by
  // other producers. A value of 0 denotes the implicit trace-global track.
  //
  // For example, legacy TRACE_EVENT macros may use a hash involving the async
  // event id + id_scope, pid, and/or tid to compute this ID.
  optional uint64 uuid = 1;

  // A parent track reference can be used to describe relationships between
  // tracks. For example, to define an asynchronous track which is scoped to a
  // specific process, specify the uuid for that process's process track here.
  // Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
  // thread, specify the uuid for that thread's thread track here. In general,
  // setting a parent will *nest* that track under the parent in the UI and in
  // the trace processor data model (with the important exception noted below).
  //
  // If not specified, the track will be a root track, i.e. not nested under any
  // other track.
  //
  // Note: if the `thread` or `process` fields are set, this value will be
  // *ignored* as priority is given to those fields.
  //
  // Note: if the parent is set to a track with `thread` or `process` fields
  // set, the track will *not* be nested under the parent in the UI and in the
  // trace processor data model. Instead, the track will inherit the parent's
  // thread/process association and will appear as a *sibling* of the parent.
  // This semantic exists for back-compat reasons as the UI used to work this
  // way for years and changing this leads to a lot of traces subtly breaking.
  // If you want to force nesting, create *another* intermediate track to act as
  // the parent.
  optional uint64 parent_uuid = 5;

  // Name of the track.
  //
  // Optional but *strongly recommended* to be specified in a `TrackDescriptor`
  // emitted before any `TrackEvent`s on the same track.
  //
  // Note: any name specified here will be *ignored* for the root thread scoped
  // tracks when `disallow_merging_with_system_tracks` is not set, as in this
  // case, the name of the track is shared by many different data sources and so
  // is centrally controlled by trace processor.
  //
  // It's strongly recommended to only emit the name for a track uuid *once*. If
  // a descriptor *has* to be emitted multiple times (e.g. between different
  // processes), it's recommended to ensure that the name is consistent across
  // all TrackDescriptors with the same `uuid`.
  //
  // If the the above recommendation is not followed and the same uuid is
  // emitted with different names, it is implementation defined how the final
  // name will be chosen and may change at any time.
  //
  // The current implementation of trace processor chooses the name in the
  // following way, depending on the value of the `sibling_merge_behavior`
  // field:
  //
  // 1. If `sibling_merge_behavior` is set to `SIBLING_MERGE_BEHAVIOR_NONE`:
  //   * The *last* non-null name in the whole trace according to trace order
  //     will be used.
  //   * If no non-null name is present in the whole trace, the trace processor
  //     may fall back to other sources to provide a name for the track (e.g.
  //     the first event name for slice tracks, the counter name for counter
  //     tracks). This is implementation defined and may change at any time.
  //
  // 2. If `sibling_merge_behavior` is set to any other value:
  //   * The first non-null name before the first event on the track *or on any
  //     descendant tracks* is processed will be used. For example, consider
  //     the following sequence of events:
  //       ts=100: TrackDescriptor(uuid=A)
  //       ts=200: TrackDescriptor(uuid=B, parent_uuid=A)
  //       ts=300: TrackDescriptor(uuid=A, name="Track A")
  //       ts=400: TrackEvent(track_uuid=B)
  //     In this case, the name for track A will be "Track A" because the
  //     descriptor with the name was emitted before the first event on a
  //     descendant track (B).
  //   * If no non-null name is present before the event is processed, the trace
  //     processor may fall back to other sources to provide a name for the
  //     track (e.g. the first event name for slice tracks, the counter name for
  //     counter tracks). This is implementation defined and may change at any
  //     time.
  //   * Note on processing order: In the standard trace processor pipeline,
  //     `TrackDescriptor`s are processed during a "tokenization" phase, which
  //     occurs before any `TrackEvent`s are parsed. This means that for a given
  //     track, all its descriptors in the trace are processed before its
  //     events. Consequently, the "first non-null name before the first event"
  //     will be the name from the first `TrackDescriptor` for that track in the
  //     trace file that has a non-null name. However, in a streaming parsing
  //     scenario, the timestamp order of descriptors and events is significant,
  //     and a descriptor arriving after an event has been processed will not be
  //     used to name the track.
  oneof static_or_dynamic_name {
    string name = 2;
    // This field is only set by the SDK when perfetto::StaticString is
    // provided.
    string static_name = 10;
    // Equivalent to name, used just to mark that the data is coming from
    // android.os.Trace.
    string atrace_name = 13;
  }

  // A human-readable description of the track providing more context about its
  // data. In the UI, this is shown in a popup when the track's help button is
  // clicked.
  optional string description = 14;

  // Associate the track with a process, making it the process-global track.
  // There should only be one such track per process (usually for instant
  // events; trace processor uses this fact to detect pid reuse). If you need
  // more (e.g. for asynchronous events), create child tracks using parent_uuid.
  //
  // Trace processor will merge events on a process track with slice-type events
  // from other sources (e.g. ftrace) for the same process into a single
  // timeline view.
  optional ProcessDescriptor process = 3;
  optional ChromeProcessDescriptor chrome_process = 6;

  // Associate the track with a thread, indicating that the track's events
  // describe synchronous code execution on the thread. There should only be one
  // such track per thread (trace processor uses this fact to detect tid reuse).
  //
  // Trace processor will merge events on a thread track with slice-type events
  // from other sources (e.g. ftrace) for the same thread into a single timeline
  // view.
  optional ThreadDescriptor thread = 4;
  optional ChromeThreadDescriptor chrome_thread = 7;

  // Descriptor for a counter track. If set, the track will only support
  // TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
  // |extra_counter_values|).
  optional CounterDescriptor counter = 8;

  // If true, forces Trace Processor to use separate tracks for track events
  // and system events for the same thread.
  //
  // Track events timestamps in Chrome have microsecond resolution, while
  // system events use nanoseconds. It results in broken event nesting when
  // track events and system events share a track.
  optional bool disallow_merging_with_system_tracks = 9;

  // Specifies how the UI should display child tracks of this track (i.e. tracks
  // where `parent_uuid` is specified to this track `uuid`). Note that this
  // value is simply a *hint* to the UI: the UI is not guarnateed to respect
  // this if it has a good reason not to do so.
  //
  // Note: for tracks where `thread` or `process` are set, this option is
  // *ignored*. See `parent_uuid` for details.
  enum ChildTracksOrdering {
    // The default ordering, with no bearing on how the UI will visualise the
    // tracks.
    UNKNOWN = 0;

    // Order tracks by `name` or `static_name` depending on which one has been
    // specified.
    LEXICOGRAPHIC = 1;

    // Order tracks by the first `ts` event in a track.
    CHRONOLOGICAL = 2;

    // Order tracks by `sibling_order_rank` of child tracks. Child tracks with
    // the lower values will be shown before tracks with higher values. Tracks
    // with no value will be treated as having 0 rank.
    EXPLICIT = 3;
  }
  optional ChildTracksOrdering child_ordering = 11;

  // An opaque value which allows specifying how two sibling tracks should be
  // ordered relative to each other: tracks with lower ranks will appear before
  // tracks with higher ranks. An unspecified rank will be treated as a rank of
  // 0.
  //
  // Note: this option is only relevant for tracks where the parent has
  // `child_ordering` set to `EXPLICIT`. It is ignored otherwise.
  //
  // Note: for tracks where the parent has `thread` or `process` are set, this
  // option is *ignored* (even if the parent's `child_ordering` is `EXPLICIT``).
  // See `parent_uuid` for details.
  optional int32 sibling_order_rank = 12;

  // Specifies how the analysis tools should "merge" different sibling
  // TrackEvent tracks.
  //
  // For two or more tracks to be merged, they must be "eligible" siblings.
  // Eligibility is determined by the following rules:
  // 1. All tracks must have the same parent.
  // 2. All tracks must have the same `sibling_merge_behavior`. The only
  //    exception is `SIBLING_MERGE_BEHAVIOR_UNSPECIFIED` which is treated as
  //    `SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME`.
  // 3. Depending on the behavior, the corresponding key must match (e.g. `name`
  //    for `BY_TRACK_NAME`, `sibling_merge_key` for `BY_SIBLING_MERGE_KEY`).
  //
  // Specifically:
  //   - in the UI, all tracks which are merged together will be
  //     displayed as a single "visual" track.
  //   - in the trace processor, all tracks which are merged together will be
  //     "multiplexed" into n "analysis" tracks where n is the maximum number
  //     of tracks which have an active event at the same time.
  //
  // When tracks are merged togther, the properties for the merged track will be
  // chosen from the source tracks based on the following rules:
  //   - for `sibling_order_rank`: the rank of the merged track will be the
  //     smallest rank among the source tracks.
  //   - for all other properties: the property taken is unspecified and can
  //     be any value provided by one of the source tracks. This can lead to
  //     non-deterministic behavior.
  //      - examples of other properties include `name`, `child_ordering` etc.
  //      - because of this, it's strongly recommended to ensure that all source
  //        tracks have the same value for these properties.
  //      - the trace processor will also emit an error stat if it detects
  //        that the properties are not the same across all source tracks.
  //
  // Note: merging is done *recursively* so entire trees of tracks can be merged
  // together. To make this clearer, consider an example track hierarchy (in
  // the diagrams: "smk" refers to "sibling_merge_key", the first word on a
  // track line, like "Updater", is its 'name' property):
  //
  //   Initial track hierarchy:
  //     SystemActivity
  //      AuthService (smk: "auth_main_cluster")
  //         LoginOp (smk: "login_v1")
  //      AuthService (smk: "auth_main_cluster")
  //         LoginOp (smk: "login_v1")
  //      AuthService (smk: "auth_backup_cluster")
  //         GuestOp (smk: "guest_v1")
  //      UserProfileService (smk: "profile_cluster")
  //          GetProfileOp (smk: "getprofile_v1")
  //
  // Merging outcomes:
  //
  // Scenario 1: Merging by `SIBLING_MERGE_BEHAVIOR_BY_SIBLING_MERGE_KEY`
  //   - The first two "AuthService" tracks merge because they share
  //     `smk: "auth_main_cluster"`. Their names are consistent ("AuthService"),
  //     aligning with recommendations. The merged track is named "AuthService".
  //   - The third "AuthService" track (with `smk: "auth_backup_cluster"`)
  //     remains separate, as its `sibling_merge_key` is different.
  //   - "UserProfileService" also remains separate.
  //   - Within the merged "AuthService" (from "auth_main_cluster"):
  //     "LoginOp" get merged as they have the same sibling merge key.
  //
  //   Resulting UI (when merging by SIBLING_MERGE_KEY):
  //     SystemActivity
  //      AuthService (merged by smk: "auth_main_cluster")
  //         LoginOp (merged by smk: "login_v1")
  //      AuthService (smk: "auth_backup_cluster")
  //         GuestOp (smk: "guest_v1")
  //      UserProfileService (smk: "profile_cluster")
  //          GetProfileOp (smk: "getprofile_v1")
  //
  // Scenario 2: Merging by `SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME`
  //   - All three tracks named "AuthService" merge because they share the same
  //     name. The merged track is named "AuthService". The `sibling_merge_key`
  //     for this merged track would be taken from one of the source tracks
  //     (e.g., "auth_main_cluster" or "auth_backup_cluster"), which could be
  //     relevant if its children had key-based merge behaviors.
  //   - "UserProfileService" remains separate due to its different name.
  //   - Within the single merged "AuthService" track:
  //     "LoginOp", "GuestOp" become siblings. "LoginOp" tracks gets merged as
  //     they have the same name.
  //
  //   Resulting UI (when merging by SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME):
  //     SystemActivity
  //      AuthService (merged from 3 "AuthService" tracks)
  //         LoginOp (smk: "login_v1")
  //         GuestOp (smk: "guest_v1")
  //      UserProfileService (smk: "profile_cluster")
  //          GetProfileOp (smk: "getprofile_v1")
  //
  // Note: for tracks where `thread` or `process` are set, this option is
  // *ignored*. See `parent_uuid` for details.
  enum SiblingMergeBehavior {
    // When unspecified or not set, defaults to
    // `SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME`.
    SIBLING_MERGE_BEHAVIOR_UNSPECIFIED = 0;

    // Merge this track with eligible siblings which have the same `name`.
    //
    // This is the default behavior.option.
    //
    // Fun fact: this is the default beahavior for legacy reasons as the UI has
    // worked this way for years and inherited this behavior from
    // chrome://tracing which has worked this way for even longer
    SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME = 1;

    // Never merge this track with any siblings. Useful if if this track has a
    // specific meaning and you want to see separately from any others.
    SIBLING_MERGE_BEHAVIOR_NONE = 2;

    // Merge this track with eligible siblings which have the same
    // `sibling_merge_key`.
    SIBLING_MERGE_BEHAVIOR_BY_SIBLING_MERGE_KEY = 3;
  }
  optional SiblingMergeBehavior sibling_merge_behavior = 15;

  // An opaque value which allows specifying which tracks should be merged
  // together.
  //
  // Only meaningful when `sibling_merge_behavior` is set to
  // `SIBLING_MERGE_BEHAVIOR_BY_SIBLING_MERGE_KEY`.
  oneof sibling_merge_key_field {
    string sibling_merge_key = 16;
    uint64 sibling_merge_key_int = 17;
  }
}

// End of protos/perfetto/trace/track_event/track_descriptor.proto

// Begin of protos/perfetto/trace/translation/translation_table.proto

// Translation rules for the trace processor.
// See the comments for each rule type for specific meaning.
message TranslationTable {
  oneof table {
    ChromeHistorgramTranslationTable chrome_histogram = 1;
    ChromeUserEventTranslationTable chrome_user_event = 2;
    ChromePerformanceMarkTranslationTable chrome_performance_mark = 3;
    SliceNameTranslationTable slice_name = 4;
    ProcessTrackNameTranslationTable process_track_name = 5;
    ChromeStudyTranslationTable chrome_study = 6;
  }
}

// Chrome histogram sample hash -> name translation rules.
message ChromeHistorgramTranslationTable {
  map<uint64, string> hash_to_name = 1;
}

// Chrome user event action hash -> name translation rules.
message ChromeUserEventTranslationTable {
  map<uint64, string> action_hash_to_name = 1;
}

// Chrome performance mark translation rules.
message ChromePerformanceMarkTranslationTable {
  map<uint32, string> site_hash_to_name = 1;
  map<uint32, string> mark_hash_to_name = 2;
};

// Raw -> deobfuscated slice name translation rules.
message SliceNameTranslationTable {
  map<string, string> raw_to_deobfuscated_name = 1;
};

// Raw -> deobfuscated process track name translation rules.
message ProcessTrackNameTranslationTable {
  map<string, string> raw_to_deobfuscated_name = 1;
};

// Chrome study hash -> name translation rules.
message ChromeStudyTranslationTable {
  map<uint64, string> hash_to_name = 1;
};

// End of protos/perfetto/trace/translation/translation_table.proto

// Begin of protos/perfetto/trace/trigger.proto

// When a TracingSession receives a trigger it records the boot time nanoseconds
// in the TracePacket's timestamp field as well as the name of the producer that
// triggered it. We emit this data so filtering can be done on triggers received
// in the trace.
message Trigger {
  // Name of the trigger which was received.
  optional string trigger_name = 1;
  // The actual producer that activated |trigger|.
  optional string producer_name = 2;
  // The verified UID of the producer.
  optional int32 trusted_producer_uid = 3;
  // The value of stop_delay_ms from the configuration.
  optional uint64 stop_delay_ms = 4;
}

// End of protos/perfetto/trace/trigger.proto

// Begin of protos/perfetto/trace/ui_state.proto

// Common state for UIs visualizing Perfetto traces.
// This message can be appended as a TracePacket by UIs to save the
// visible state (e.g. scroll position/zoom state) for future opening
// of the trace.
// Design doc: go/trace-ui-state.
message UiState {
  // The start and end bounds of the viewport of the UI in nanoseconds.
  //
  // This is the absolute time associated to slices and other events in
  // trace processor tables (i.e. the |ts| column of most tables)
  optional int64 timeline_start_ts = 1;
  optional int64 timeline_end_ts = 2;

  // Indicates that the given process should be highlighted by the UI.
  message HighlightProcess {
    oneof selector {
      // The pid of the process to highlight. This is useful for UIs to focus
      // on tracks of a particular process in the trace.
      //
      // If more than one process in a trace has the same pid, it is UI
      // implementation specific how the process to be focused will be
      // chosen.
      uint32 pid = 1;

      // The command line of the process to highlight; for most Android apps,
      // this is the package name of the app. This is useful for UIs to focus
      // on a particular app in the trace.
      //
      // If more than one process hasthe same cmdline, it is UI implementation
      // specific how the process to be focused will be chosen.
      string cmdline = 2;
    }
  }
  optional HighlightProcess highlight_process = 3;
}
// End of protos/perfetto/trace/ui_state.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// TracePacket is the root object of a Perfetto trace.
// A Perfetto trace is a linear sequence of TracePacket(s).
//
// The tracing service guarantees that all TracePacket(s) written by a given
// TraceWriter are seen in-order, without gaps or duplicates. If, for any
// reason, a TraceWriter sequence becomes invalid, no more packets are returned
// to the Consumer (or written into the trace file).
// TracePacket(s) written by different TraceWriter(s), hence even different
// data sources, can be seen in arbitrary order.
// The consumer can re-establish a total order, if interested, using the packet
// timestamps, after having synchronized the different clocks onto a global
// clock.
//
// The tracing service is agnostic of the content of TracePacket, with the
// exception of few fields (e.g.. trusted_*, trace_config) that are written by
// the service itself.
//
// See the [Buffers and Dataflow](/docs/concepts/buffers.md) doc for details.
//
// Next reserved id: 14 (up to 15).
// Next id: 124.
message TracePacket {
  // The timestamp of the TracePacket.
  // By default this timestamps refers to the trace clock (CLOCK_BOOTTIME on
  // Android). It can be overridden using a different timestamp_clock_id.
  // The clock domain definition in ClockSnapshot can also override:
  // - The unit (default: 1ns).
  // - The absolute vs delta encoding (default: absolute timestamp).
  optional uint64 timestamp = 8;

  // Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
  // one of the built-in types from ClockSnapshot::BuiltinClocks, or a
  // producer-defined clock id.
  // If unspecified and if no default per-sequence value has been provided via
  // TracePacketDefaults, it defaults to BuiltinClocks::BOOTTIME.
  optional uint32 timestamp_clock_id = 58;

  oneof data {
    ProcessTree process_tree = 2;
    ProcessStats process_stats = 9;
    InodeFileMap inode_file_map = 4;
    ChromeEventBundle chrome_events = 5;
    ClockSnapshot clock_snapshot = 6;
    SysStats sys_stats = 7;
    TrackEvent track_event = 11;

    // IDs up to 15 are reserved. They take only one byte to encode their
    // preamble so should be used for frequent events.

    TraceUuid trace_uuid = 89;
    TraceConfig trace_config = 33;
    FtraceStats ftrace_stats = 34;
    TraceStats trace_stats = 35;
    ProfilePacket profile_packet = 37;
    StreamingAllocation streaming_allocation = 74;
    StreamingFree streaming_free = 75;
    BatteryCounters battery = 38;
    PowerRails power_rails = 40;
    AndroidLogPacket android_log = 39;
    SystemInfo system_info = 45;
    Trigger trigger = 46;
    ChromeTrigger chrome_trigger = 109;
    PackagesList packages_list = 47;
    ChromeBenchmarkMetadata chrome_benchmark_metadata = 48;
    PerfettoMetatrace perfetto_metatrace = 49;
    ChromeMetadataPacket chrome_metadata = 51;
    GpuCounterEvent gpu_counter_event = 52;
    GpuRenderStageEvent gpu_render_stage_event = 53;
    StreamingProfilePacket streaming_profile_packet = 54;
    HeapGraph heap_graph = 56;
    GraphicsFrameEvent graphics_frame_event = 57;
    VulkanMemoryEvent vulkan_memory_event = 62;
    GpuLog gpu_log = 63;
    VulkanApiEvent vulkan_api_event = 65;
    PerfSample perf_sample = 66;
    CpuInfo cpu_info = 67;
    SmapsPacket smaps_packet = 68;
    TracingServiceEvent service_event = 69;
    InitialDisplayState initial_display_state = 70;
    GpuMemTotalEvent gpu_mem_total_event = 71;
    MemoryTrackerSnapshot memory_tracker_snapshot = 73;
    FrameTimelineEvent frame_timeline_event = 76;
    AndroidEnergyEstimationBreakdown android_energy_estimation_breakdown = 77;
    UiState ui_state = 78;
    AndroidCameraFrameEvent android_camera_frame_event = 80;
    AndroidCameraSessionStats android_camera_session_stats = 81;
    TranslationTable translation_table = 82;
    AndroidGameInterventionList android_game_intervention_list = 83;
    StatsdAtom statsd_atom = 84;
    AndroidSystemProperty android_system_property = 86;
    EntityStateResidency entity_state_residency = 91;

    // Only used in profile packets.
    ModuleSymbols module_symbols = 61;
    DeobfuscationMapping deobfuscation_mapping = 64;

    // Only used by TrackEvent.
    TrackDescriptor track_descriptor = 60;

    // Deprecated, use TrackDescriptor instead.
    ProcessDescriptor process_descriptor = 43;

    // Deprecated, use TrackDescriptor instead.
    ThreadDescriptor thread_descriptor = 44;

    // Events from the Linux kernel ftrace infrastructure.
    FtraceEventBundle ftrace_events = 1;

    // This field is emitted at periodic intervals (~10s) and
    // contains always the binary representation of the UUID
    // {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
    // efficiently partition long traces without having to fully parse them.
    bytes synchronization_marker = 36;

    // Zero or more proto encoded trace packets compressed using deflate.
    // Each compressed_packets TracePacket (including the two field ids and
    // sizes) should be less than 512KB.
    bytes compressed_packets = 50;

    // Data sources can extend the trace proto with custom extension protos (see
    // docs/design-docs/extensions.md). When they do that, the descriptor of
    // their extension proto descriptor is serialized in this packet. This
    // allows trace_processor to deserialize extended messages using reflection
    // even if the extension proto is not checked in the Perfetto repo.
    ExtensionDescriptor extension_descriptor = 72;

    // Represents a single packet sent or received by the network.
    NetworkPacketEvent network_packet = 88;

    // Represents one or more packets sent or received by the network.
    NetworkPacketBundle network_packet_bundle = 92;

    // The "range of interest" for track events. See the message definition
    // comments for more details.
    TrackEventRangeOfInterest track_event_range_of_interest = 90;

    // Winscope traces
    LayersSnapshotProto surfaceflinger_layers_snapshot = 93;
    TransactionTraceEntry surfaceflinger_transactions = 94;
    ShellTransition shell_transition = 96;
    ShellHandlerMappings shell_handler_mappings = 97;
    ProtoLogMessage protolog_message = 104;
    ProtoLogViewerConfig protolog_viewer_config = 105;
    WinscopeExtensions winscope_extensions = 112;

    // Events from the Windows etw infrastructure.
    EtwTraceEventBundle etw_events = 95;

    V8JsCode v8_js_code = 99;
    V8InternalCode v8_internal_code = 100;
    V8WasmCode v8_wasm_code = 101;
    V8RegExpCode v8_reg_exp_code = 102;
    V8CodeMove v8_code_move = 103;
    // Clock synchronization with remote machines.
    RemoteClockSync remote_clock_sync = 107;

    PixelModemEvents pixel_modem_events = 110;
    PixelModemTokenDatabase pixel_modem_token_database = 111;

    Trigger clone_snapshot_trigger = 113;

    BluetoothTraceEvent bluetooth_trace_event = 114;

    KernelWakelockData kernel_wakelock_data = 115;

    AppWakelockBundle app_wakelock_bundle = 116;

    // Generic events for a standard kernel implementation
    GenericKernelTaskStateEvent generic_kernel_task_state_event = 117;
    GenericKernelCpuFrequencyEvent generic_kernel_cpu_freq_event = 118;
    GenericKernelTaskRenameEvent generic_kernel_task_rename_event = 120;
    GenericKernelProcessTree generic_kernel_process_tree = 122;

    CpuPerUidData cpu_per_uid_data = 119;

    EvdevEvent evdev_event = 121;

    UserList user_list = 123;

    // This field is only used for testing.
    // In previous versions of this proto this field had the id 268435455
    // This caused many problems:
    // - protozero decoder does not handle field ids larger than 999.
    // - old versions of protoc produce Java bindings with syntax errors when
    //   the field id is large enough.
    TestEvent for_testing = 900;
  }

  // AndroidInputEvent android_input_event (moved to winscope_extensions)
  reserved 106;

  // removed ProfiledFrameSymbols profiled_frame_symbols
  reserved 55;

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid {
    int32 trusted_uid = 3;
  };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }

  // Trusted process id of the producer which generated this packet, written by
  // the service.
  optional int32 trusted_pid = 79;

  // Incrementally emitted interned data, valid only on the packet's sequence
  // (packets with the same |trusted_packet_sequence_id|). The writer will
  // usually emit new interned data in the same TracePacket that first refers to
  // it (since the last reset of interning state). It may also be emitted
  // proactively in advance of referring to them in later packets.
  optional InternedData interned_data = 12;

  enum SequenceFlags {
    SEQ_UNSPECIFIED = 0;

    // Set by the writer to indicate that it will re-emit any incremental data
    // for the packet's sequence before referring to it again. This includes
    // interned data as well as periodically emitted data like
    // Process/ThreadDescriptors. This flag only affects the current packet
    // sequence (see |trusted_packet_sequence_id|).
    //
    // When set, this TracePacket and subsequent TracePackets on the same
    // sequence will not refer to any incremental data emitted before this
    // TracePacket. For example, previously emitted interned data will be
    // re-emitted if it is referred to again.
    //
    // When the reader detects packet loss (|previous_packet_dropped|), it needs
    // to skip packets in the sequence until the next one with this flag set, to
    // ensure intact incremental data.
    SEQ_INCREMENTAL_STATE_CLEARED = 1;

    // This packet requires incremental state, such as TracePacketDefaults or
    // InternedData, to be parsed correctly. The trace reader should skip this
    // packet if incremental state is not valid on this sequence, i.e. if no
    // packet with the SEQ_INCREMENTAL_STATE_CLEARED flag has been seen on the
    // current |trusted_packet_sequence_id|.
    SEQ_NEEDS_INCREMENTAL_STATE = 2;
  };
  optional uint32 sequence_flags = 13;

  // DEPRECATED. Moved to SequenceFlags::SEQ_INCREMENTAL_STATE_CLEARED.
  optional bool incremental_state_cleared = 41;

  // Default values for fields of later TracePackets emitted on this packet's
  // sequence (TracePackets with the same |trusted_packet_sequence_id|).
  // It must be reemitted when incremental state is cleared (see
  // |incremental_state_cleared|).
  // Requires that any future packet emitted on the same sequence specifies
  // the SEQ_NEEDS_INCREMENTAL_STATE flag.
  // TracePacketDefaults always override the global defaults for any future
  // packet on this sequence (regardless of SEQ_NEEDS_INCREMENTAL_STATE).
  optional TracePacketDefaults trace_packet_defaults = 59;

  // Flag set by the service if, for the current packet sequence (see
  // |trusted_packet_sequence_id|), either:
  // * this is the first packet, or
  // * one or multiple packets were dropped since the last packet that the
  //   consumer read from the sequence. This can happen if chunks in the trace
  //   buffer are overridden before the consumer could read them when the trace
  //   is configured in ring buffer mode.
  //
  // When packet loss occurs, incrementally emitted data (including interned
  // data) on the sequence should be considered invalid up until the next packet
  // with SEQ_INCREMENTAL_STATE_CLEARED set.
  optional bool previous_packet_dropped = 42;

  // Flag set by a producer (starting from SDK v29) if, for the current packet
  // sequence (see |trusted_packet_sequence_id|), this is the first packet.
  //
  // This flag can be used for distinguishing the two situations when
  // processing the trace:
  // 1. There are no prior events for the sequence because of data loss, e.g.
  //    due to ring buffer wrapping.
  // 2. There are no prior events for the sequence because it didn't start
  //    before this packet (= there's definitely no preceding data loss).
  //
  // Given that older SDK versions do not support this flag, this flag not
  // being present for a particular sequence does not necessarily imply data
  // loss.
  optional bool first_packet_on_sequence = 87;

  // The machine ID for identifying trace packets in a multi-machine tracing
  // session. Is emitted by the tracing service for producers running on a
  // remote host (e.g. a VM guest). For more context: go/crosetto-vm-tracing.
  optional uint32 machine_id = 98;
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto
