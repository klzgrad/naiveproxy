// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ui.mojom;

import "mojo/common/text_direction.mojom";
import "ui/events/mojo/event.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/gfx/range/mojo/range.mojom";

// Specifies where to display the candidate window.
enum CandidateWindowPosition {
  // Candidate window follows the cursor.
  kCursor,

  // Candidate window is locked to the beginning of the composition.
  kComposition
};

struct CandidateWindowProperties {
  // Number of candidates to display per page.
  int32 page_size;

  // Should candidate window be rendered vertical or horizontal.
  bool vertical;

  // Text that is shown at the bottom of the candidate window.
  string auxiliary_text;

  // True to display auxiliary text, false to hide it.
  bool auxiliary_text_visible;

  // Position and visibility of cursor in the candidate window.
  int32 cursor_position;
  bool cursor_visible;

  // Where to display the candidate window.
  CandidateWindowPosition window_position;
};

// Represents a candidate window entry.
struct CandidateWindowEntry {
  // Value of the candidate.
  string value;

  // Short string displayed next to the candidate, often the shortcut key or
  // index.
  string label;

  // Additional text describing the candidate.
  string annotation;

  // The usage or detailed description of the candidate.
  string description_title;
  string description_body;
};

// See comments for ui::ImeTextSpan::Type for more details.
enum ImeTextSpanType {
  kComposition,
  kSuggestion,
  kMisspellingSuggestion,
};

// Represents an underlined segment of text currently composed by IME.
// Corresponds to ui::ImeTextSpan.
struct ImeTextSpan {
  ImeTextSpanType type;
  uint32 start_offset;
  uint32 end_offset;
  uint32 underline_color;
  bool thick;
  uint32 background_color;
  uint32 suggestion_highlight_color;
  array<string> suggestions;
};

// Represents a text currently being composed by IME. Corresponds to
// ui::CompositionText.
struct CompositionText {
  string text;
  array<ImeTextSpan> ime_text_spans;
  gfx.mojom.Range selection;
};

// See comments for ui::TextInputType for more details.
enum TextInputType {
  kNone,
  kText,
  kPassword,
  kSearch,
  kEmail,
  kNumber,
  kTelephone,
  kUrl,
  kDate,
  kTime,
  kDateTime,
  kDateTimeLocal,
  kMonth,
  kWeek,
  kTextArea,
  kContentEditable,
  kDateTimeField
};

// See comments for ui::TextInputMode for more details.
enum TextInputMode {
  kDefault,
  kVerbatim,
  kLatin,
  kLatinName,
  kLatinProse,
  kFullWidthLatin,
  kKana,
  kKanaName,
  kKatakana,
  kNumeric,
  kTel,
  kEmail,
  kUrl,
};

// Parameters needed to start an IME session.
struct StartSessionDetails {
  TextInputClient client;
  InputMethod& input_method_request;

  // Initial details about |client| required by IMEDriver.
  TextInputType text_input_type;
  TextInputMode text_input_mode;
  mojo.common.mojom.TextDirection text_direction;
  int32 text_input_flags;
  gfx.mojom.Rect caret_bounds;
};

// A service which provides the IMEDriver interface is responsible for doing
// the composition logic. After starting a session, it receives events from
// the client via the InputMethod interface, and sends composition events to
// the client via the TextInputClient.
interface IMEDriver {
  StartSession(StartSessionDetails details);
};

// An IME driver register should register itself to Mus using the IMERegistrar
// interface.
interface IMERegistrar {
  RegisterDriver(IMEDriver driver);
};

// A client sends updates to the IME driver using the InputMethod interface.
// This interface is provided by IME drivers, and also by Mus as a lightweight
// proxy between IME drivers and clients.
interface InputMethod {
  OnTextInputTypeChanged(TextInputType text_input_type);

  // Client sends |caret_bounds| in focused window coordinates,
  // Mus translates it to global coordinates and sends it to IME app.
  OnCaretBoundsChanged(gfx.mojom.Rect caret_bounds);

  // Called to process a key event. The callback function will be called to
  // notify the client if the event was handled or not. A handled event may
  // generate zero or more composition events which will be sent to the client
  // using the "input method result" functions of TextInputClient interface.
  ProcessKeyEvent(ui.mojom.Event key_event) => (bool handled);

  CancelComposition();
};

// IME drivers send updates to clients using the TextInputClient interface.
interface TextInputClient {
  // Functions corresponding to "input method result" functions of
  // ui::TextInputClient. See comments for InputMethod::ProcessKeyEvent() for
  // when these are called.

  // Sets composition text and attributes. See comments for
  // ui::TextInputClient::SetCompositionText() for more details.
  SetCompositionText(CompositionText composition);

  // Converts current composition text into final content.
  ConfirmCompositionText();

  // Removes current composition text.
  ClearCompositionText();

  // Inserts a given text at the insertion point. Current composition text or
  // selection will be removed. This method should never be called when the
  // current text input type is TEXT_INPUT_TYPE_NONE.
  InsertText(string text);

  // Inserts a single character at the insertion point. Unlike InsertText(),
  // the character is not processed. See ui::TextInputClient::InsertChar()
  // for more details.
  InsertChar(ui.mojom.Event event);

  // Dispatch a key event skipping IME. Returns true if event was consumed.
  DispatchKeyEventPostIME(ui.mojom.Event event) => (bool stopped_propagation);

  // Sending visibility status of candidate pop up window to client.
  SetCandidateWindowVisible(bool visible);

  // TODO(moshayedi): Add functions corresponding to ui::TextInputClient for:
  // - Input context information
  // - Document content operations
  // - Miscellaneous functions
  // crbug.com/631527.
};
